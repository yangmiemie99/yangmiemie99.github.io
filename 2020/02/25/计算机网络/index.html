<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/yangmiemie99.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/yangmiemie99.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/yangmiemie99.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/yangmiemie99.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/yangmiemie99.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/yangmiemie99.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/yangmiemie99.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="计算机网络,">










<meta name="description" content="计算机网络概述网络的网络网络把主机连接起来，而互连网是把多种不同的网络连接起来，因此互连网是网络的网络。而因特网（Internet）是全球范围的互连网。 因特网的一些部件，主机（端系统），服务器，移动设备，路由器，链路交换机，调制解调器，基站，智能手机，蜂窝电话塔。 端系统通过因特网服务提供商（internet Service Provider）ISP接入因特网。 因特网还可以从应用程序提供服务的">
<meta name="keywords" content="计算机网络">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络总结">
<meta property="og:url" content="https://yangmiemie99.github.io/2020/02/25/计算机网络/index.html">
<meta property="og:site_name" content="MieMieBlog">
<meta property="og:description" content="计算机网络概述网络的网络网络把主机连接起来，而互连网是把多种不同的网络连接起来，因此互连网是网络的网络。而因特网（Internet）是全球范围的互连网。 因特网的一些部件，主机（端系统），服务器，移动设备，路由器，链路交换机，调制解调器，基站，智能手机，蜂窝电话塔。 端系统通过因特网服务提供商（internet Service Provider）ISP接入因特网。 因特网还可以从应用程序提供服务的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/计算机网络/1.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/计算机网络/2.jpg">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/计算机网络/3.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%BF%AD%E4%BB%A3.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%80%92%E5%BD%92.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/ssl.webp">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/UDP%E6%A0%A1%E9%AA%8C%E5%92%8C.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/TCP%E6%8A%A5%E6%96%87.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%8F%A1%E6%89%8B.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/IPv4.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/ICMP.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/ICMP%E5%88%86%E7%B1%BB.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%87%8D%E5%AE%9A%E5%90%91ICMP.png">
<meta property="og:image" content="https://yangmiemie99.github.io/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/ARP.png">
<meta property="og:updated_time" content="2020-03-24T14:56:23.226Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机网络总结">
<meta name="twitter:description" content="计算机网络概述网络的网络网络把主机连接起来，而互连网是把多种不同的网络连接起来，因此互连网是网络的网络。而因特网（Internet）是全球范围的互连网。 因特网的一些部件，主机（端系统），服务器，移动设备，路由器，链路交换机，调制解调器，基站，智能手机，蜂窝电话塔。 端系统通过因特网服务提供商（internet Service Provider）ISP接入因特网。 因特网还可以从应用程序提供服务的">
<meta name="twitter:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/计算机网络/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/yangmiemie99.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yangmiemie99.github.io/2020/02/25/计算机网络/">





  <title>计算机网络总结 | MieMieBlog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/yangmiemie99.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MieMieBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/yangmiemie99.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/yangmiemie99.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/yangmiemie99.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/yangmiemie99.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/yangmiemie99.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yang MieMie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/yangmiemie99.github.io/images/touxiang.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MieMieBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">计算机网络总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T11:45:12+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yangmiemie99.github.io/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h1 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h1><p>网络把主机连接起来，而互连网是把多种不同的网络连接起来，因此互连网是网络的网络。而因特网（Internet）是全球范围的互连网。</p>
<p>因特网的一些部件，主机（端系统），服务器，移动设备，路由器，链路交换机，调制解调器，基站，智能手机，蜂窝电话塔。</p>
<p><strong>端系统</strong>通过因特网服务提供商（internet Service Provider）ISP接入因特网。</p>
<p>因特网还可以从应用程序提供服务的基础设施的角度来描述因特网。将因特网描述为应用程序的平台。应用程序可以包括：电子邮件，即时通讯，社交网络，流式视频，分布式游戏，Peer to peer 文件共享，因特网电视等等。</p>
<h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p>
<p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/计算机网络/1.png" alt></p>
<h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>端系统交换报文，源端系统将长报文划分乘较小的数据块，称为分组。</p>
<p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p>
<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>
<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>由因特网端系统的分组交换机和链路构成的网状网络。</p>
<h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><ul>
<li>处理时延：主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。（通常是微秒级以下）等。</li>
<li>排队时延：在队列中，当分组在链路缓存中<strong>等待传输</strong>时，它经受排队时延。 到达组的分组数量是到达该队列的流量强度的函数。</li>
<li>传输时延：用L比特表示分组的长度，用R b/s表示从路由器A到路由器B的链路传输速率。传输时延是L/R。这是<strong>将所有分组比特推向链路所需要的时间</strong>。实际的传输时延通常在毫秒到微秒级。是包从路由器A中被推出去的时间。与两路由器的距离无关。</li>
<li>传播时延：电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。从该链路的<strong>起点到路由器B的传播所需要的时间</strong>是传播时延。</li>
<li>传输时延可以看做是车队（包）过收费站（路由器）的时间，而传播时延可看作路上花费的时间。</li>
<li>节点总时延 = 处理时延 + 排队时延 + 传输时延 + 传播时延 一般来说处理时延通常是微不足道的。</li>
</ul>
<p><img src="/yangmiemie99.github.io/2020/02/25/计算机网络/2.jpg" alt></p>
<h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p><img src="/yangmiemie99.github.io/2020/02/25/计算机网络/3.png" alt></p>
<h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><p>写信为例子</p>
<p><strong>应用层</strong>（信的格式）：应用程序以及他们的应用层协议留存的地方。应用层协议分布在多个端系统上，<strong>一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。</strong></p>
<ul>
<li>我们把应用层的信息称为<strong>报文</strong>。</li>
<li>典型协议如<code>HTTP</code>、<code>FTP</code>、<code>SMTP(电邮)</code>、<code>DNS</code>。</li>
</ul>
<p><strong>运输层</strong>（加入对方名字的信封）：在应用程序端点之间传输应用层报文的协议。</p>
<ul>
<li>因特网中常用的有两个，即<code>TCP</code>和<code>UDP</code>。</li>
<li>TCP：<strong>面向连接</strong>，分割长报文，拥塞控制机制，<strong>可靠传递</strong>，双方速率匹配。</li>
<li>UDP：无连接，最大努力的数据传输服务。</li>
<li>处于运输层的分组叫做<strong>报文段</strong>(segement)</li>
</ul>
<p><strong>网络层</strong> （邮局和邮政服务）：负责将数据报(datagram，处于网络层的分组)从主机移动到另一主机，使两端能够互连且决定最佳路径。<strong>数据报</strong></p>
<ul>
<li>从运输层拿到报文段和目标地址。然后进行<code>路由</code>（路由选择协议）。</li>
<li>网络层的典型协议是<code>IP</code>协议，用来识别目标地址。</li>
<li>另一典型协议是<code>网络控制消息协定（ICMP）</code>，它是IP的主要部分，一般不用于在两点间传输数据。它通常不由网络程序直接使用，除了<code>ping</code>和<code>traceroute</code>这两个特例。</li>
</ul>
<p><strong>链路层</strong> （信运输员）在两个网络实体之间提供数据链路连接的创建、维持和释放管理。</p>
<ul>
<li>构成链路层的分组（称之<strong>数据帧或帧</strong>），并对帧定界、同步、收发顺序的控制。</li>
<li>负责传输过程中的流量控制,差错检测和差错控制等方面。</li>
<li>数据链路层中的数据封装是指：封装的数据信息中，包含了地址段和数据段等。地址段含有点对点发送节点和接收节点的地址（如<code>MAC</code>），控制段用来表示数格连接帧的类型，数据段包含实际要传输的数据。</li>
<li>网络层将数据报下发给链路层，链路层传输后，上报给目标结点的网络层。</li>
<li>典型协议：<code>异步传输模式（ATM）</code>、<code>帧中继（frame relay）</code>、<code>高级数据链路控制（HDLC）</code>。</li>
<li>交换机、桥接器是本层设备。而集线器是物理层设备，不是数据链路层设备。</li>
</ul>
<p>物理层（公路和车）：将一个比特一个比特移动。</p>
<ul>
<li>典型协议如：<code>蓝牙协议</code>、<code>数字用户线路（DSL）</code>等等</li>
<li>常见物理层设备：网卡、光纤、集线器</li>
</ul>
<p>OSI</p>
<ul>
<li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>
<li><strong>会话层</strong> ：建立会话，数据交换定界和同步功能，包括建立检查点和恢复方案的方法。</li>
</ul>
<blockquote>
<ul>
<li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li>
<li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
<li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>
<li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>
<li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
</ul>
</blockquote>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="1-DNS的概念，用途，DNS查询的实现算法"><a href="#1-DNS的概念，用途，DNS查询的实现算法" class="headerlink" title="1 DNS的概念，用途，DNS查询的实现算法"></a>1 DNS的概念，用途，DNS查询的实现算法</h2><p>概念：</p>
<ul>
<li>DNS(domian Name system)域名系统，是一个由分层的DNS服务器实现的分布式的数据库，提供了主机名和IP地址之间的相互转换的服务。</li>
<li>域名解析就是我们平常输入的比如说<a href="http://www.baidu.com转化为ip地址，能够是用户方便的访问互联网，而不用去记住能够被机器直接读取的ip地址" target="_blank" rel="noopener">www.baidu.com转化为ip地址，能够是用户方便的访问互联网，而不用去记住能够被机器直接读取的ip地址</a></li>
<li>DNS协议大部分情况下使用UDP传输，使用端口号53。要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性。在两种情况下会使用TCP进行传输：<ul>
<li>返回的响应超过512字节，（UDP最大只支持521字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）</li>
</ul>
</li>
</ul>
<p>主机域名解析顺序</p>
<ul>
<li><p>浏览器缓存</p>
</li>
<li><p>本机hosts文件</p>
</li>
<li><p>路由器缓存</p>
</li>
<li><p>找DNS服务器（本地域名服务器，权威域名服务器，顶级域名服务器，根域名服务器）</p>
<ul>
<li>迭代查询</li>
</ul>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%BF%AD%E4%BB%A3.png" alt></p>
<ul>
<li>递归查询</li>
</ul>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%80%92%E5%BD%92.png" alt></p>
</li>
</ul>
<p>DNS缓存</p>
<p>为了改善时延性能并减少因特网上到处传输DNS报文的数量，当莫个DNS服务器接收到一个DNS回答，他能将此回答中的信息缓存在本地存储器上。</p>
<h2 id="2-http协议"><a href="#2-http协议" class="headerlink" title="2 http协议"></a>2 http协议</h2><p>超文本传输协议：一个专门在计算机世界里专门在两个点之间传输文字，图片，视频等超文本数据的约定和规范。首部行里存有各种字段</p>
<p>http有两种报文请求报文和相应报文</p>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt></p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求行，正在请求的对象 http版本号</span></span><br><span class="line">GET /some/dir/page.html HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="comment">//指定服务器的域名，可以将请求发往同一台服务器上的不同网站</span></span><br><span class="line">Host: www.someschool.edu</span><br><span class="line"><span class="comment">//一个可复用的TCP连接就建立了，直到客户端或者服务器主动断开连接。</span></span><br><span class="line">connection:keep-Alive</span><br><span class="line"><span class="comment">// 服务器在发完被请求的对象之后关闭连接</span></span><br><span class="line">connection:close</span><br><span class="line"><span class="comment">// 浏览器的类型和版本</span></span><br><span class="line">User-agent:Mozilla/<span class="number">1.0</span></span><br><span class="line"><span class="comment">// 声明自己能够接收的请求</span></span><br><span class="line">Accept:*/ *    <span class="comment">//都能收</span></span><br><span class="line"><span class="comment">// 语言类型</span></span><br><span class="line">Accept-Lauguage:en-us</span><br><span class="line"><span class="comment">//我可以接收什么哪些压缩方式</span></span><br><span class="line">Accept-Encoding:gzip,deflate</span><br></pre></td></tr></table></figure>

<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt></p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Http/<span class="number">1.1</span> <span class="number">200</span> Ok</span><br><span class="line"><span class="comment">//发送完报文关闭tcp连接</span></span><br><span class="line">Connection:close</span><br><span class="line"><span class="comment">// 服务器产生该响应并且发送响应报文的时间</span></span><br><span class="line">data:Tue,<span class="number">09.</span>Aug..</span><br><span class="line"><span class="comment">//服务器类型</span></span><br><span class="line">Server:..</span><br><span class="line"><span class="comment">//最后对象修改的日期</span></span><br><span class="line">Last-Modified:</span><br><span class="line"><span class="comment">//被发送对象的字节数</span></span><br><span class="line">Content-Length:<span class="number">6180</span></span><br><span class="line">Content-Type:test/html</span><br><span class="line"><span class="comment">//我采用什么压缩方式</span></span><br><span class="line">Contest-Encoding:gzip</span><br></pre></td></tr></table></figure>

<h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p>200 OK:请求成功，信息在返回响应的报文之中</p>
<p>301 Moved Permanently: 请求的对象被永久转移了，新的URL在定义相应报文段的location字段中，浏览器自动重定向新的URL</p>
<p>400 Bad request:一个通用差错编码，指示请求不能被服务器理解。</p>
<p>404 Not Found:请求的文档不再服务器上</p>
<p>505 HTTP Version Not Supported:服务器不支持请报文使用的HTTP协议版本。</p>
<h3 id="GET和Post的区别"><a href="#GET和Post的区别" class="headerlink" title="GET和Post的区别"></a>GET和Post的区别</h3><p>Get方法的含义是请求服务器获取资源，这个资源可以是静态的文本，页面，图片视频等。</p>
<p>而Post方法则是相反的操作，他向URL指定的资源中中提交数据，比如说一个人的博客可以留言，我写完留言点击提交，我的留言就会执行一次post请求。</p>
<p>Get方法是安全并且幂等的，也就是说get是一个只读操作，无论执行多少次，服务器上的数据都是安全的，并且每次的结果都是相同的。</p>
<p>Post方法不是安全的并且不是幂等的，Post因为是新增或者提交数据，会修改服务器上的资源，所以不是安全的，并多次提交数据会执行多次操作创建多个资源，所以不是幂等的。</p>
<p>Get 能够被缓存,而 post 不可以;<br>Get 参数保留在浏览器历史中,而 post 参数不会保留在浏览器历史中;<br>当发生数据时,get 方法向 URL 添加数据,URL 的数据长度是受限的,而 post没有数据长度限制;<br>Get 只允许 ASCII 编码,而 post 没有限制;<br>Get 安全性没有 post 安全性好;<br>Get 数据在 URL 中对所有人是可见的,而在 post 中数据不会显示在 URL 中。<br>Get 产生一个 TCP 数据包,post 产生两个 TCP 数据包;对于 get 方式的请求,<br>浏览器会把 header 和 data 一并发送出去;对于 post,浏览器先发送 header再发送 data;</p>
<h3 id="Cookies和session的区别"><a href="#Cookies和session的区别" class="headerlink" title="Cookies和session的区别"></a>Cookies和session的区别</h3><ul>
<li>登录网站，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。</li>
<li>session一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。</li>
</ul>
<p>cookies:一个web站点通常希望能够识别用户，将内容和用户身份连接起来。当客户端发送http请求的时候，服务器就会在返回的报文中含有set-cookies字段，并且这个字段保存在客户端的硬盘上，这样客户端再次发送请求的时候就会加上自己的cookeis，从而服务器就可以识别用户。可以用来在莫个站点持久的保存数据。但是也会造成隐私泄漏问题，结合cookies和用户的账户信息，购物信息等等，Web站点可以知道很多关于用户的信息。cookie存在于客户端，所以也可以伪造</p>
<p>session:Session是存在服务器的一种用来存放用户数据的类HashTable结构。当浏览器第一次发起请求的时候，服务器就会自动生成session id 和 hashTable，当第二次发起请求的时候，将前一次服务器响应的session id放在请求中一并发给服务器 ，这时服务器进行和原来的session Id进行对比，就可以找到这个用户的hashTable</p>
<p>cookie数据保存在客户端，session保存在服务器端。</p>
<h2 id="3-一次完整的http-请求所经历的步骤"><a href="#3-一次完整的http-请求所经历的步骤" class="headerlink" title="3 一次完整的http 请求所经历的步骤"></a>3 一次完整的http 请求所经历的步骤</h2><p>1 浏览器键入URL,通过DNS服务器请求解析该URL中域名对应的IP地址</p>
<p>2 解析出Ip地址之后，根据该IP地址和默认端口80,和服务器建立TCP连接;</p>
<p>3 浏览器发出读取文件（URL中域名后边的部分）的HTTP请求，该请求报文作为TCP三次握手的底数哪个报文的数据发送给服务器;</p>
<p>4 HTTP服务器从TCP套解字读取HTTP GET 报文，生成一个HTTP响应报文，并把相应的html文本放入到相应报文主体中，发送给浏览器</p>
<p>6 浏览器将接收HTTP响应报文，抽取WEB页面内容，之后进行渲染显示</p>
<p>7 释放TCP链接</p>
<h2 id="4-http-和https的区别"><a href="#4-http-和https的区别" class="headerlink" title="4 http 和https的区别"></a>4 http 和https的区别</h2><p>1 http是超文本传输协议，信息传输是明文，存在安全风险。Https则解决了HTTP不安全的缺陷，在TCP和http网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输。</p>
<p>2 http连接的建立相对见大按，TCP三次握手之后便可以进行http传输。而https协议在三次握手之后还要进行</p>
<p>SSl/Tls的握手过程，才能加入加密报文传输</p>
<p>3 HTTP端口号是80,HTTPS端口号是443</p>
<p>4 HTTPS协议需要向CA(证书权威机构申请证书)，确保服务器的身份是可信的。</p>
<p>Https解决了HTTP哪些问题？</p>
<p>窃听风险，比如通信链路上可以 获取通信内容，用户号容易没。</p>
<p>篡改风险，比如强制加入垃圾广告</p>
<p>冒充风险，比如冒充淘宝网站，用户钱容易没</p>
<p>HTTPs可以很好的解决上述问题：</p>
<p>信息加密：交互信息无法被窃取。采用<strong>混合加密</strong>的方式，对称加密，非对称加密。</p>
<p>校验机制:无法篡改通信内容，篡改了就不能正常显示。使用<strong>摘要算法</strong>实现完整性，他能够为数据生成独一无二的指纹，指纹用于校验数据的完整性，解决了篡改的风险。</p>
<p>身份证书：证明淘宝网真是淘宝网，将服务器的公钥放到<strong>数字证书</strong>中去。</p>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png" alt></p>
<h3 id="SSL-TLS协议的基本流程"><a href="#SSL-TLS协议的基本流程" class="headerlink" title="SSL/TLS协议的基本流程"></a>SSL/TLS协议的基本流程</h3><ul>
<li>客户端向服务器所要并验证服务器公钥</li>
<li>双方协商产生会话秘钥</li>
<li>双反次熬夜嗯会话秘钥进行加密通信</li>
</ul>
<p>前两步就是涉及握手阶段的四次通信</p>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/ssl.webp" alt></p>
<p>步骤：</p>
<p>1 ClientHello:客户端发送给服务器一个随机数，还有支持的TLS协议版本，还有我能使用的加密算法。</p>
<p>2 serverHello: </p>
<ul>
<li>确认TLs版本，版本的相同我们才能继续加密通信。</li>
<li>我服务器也产生一个随机数，用于产生会话秘钥。确认咱们的加密算法</li>
<li>然后我将我的公钥和我的CA数据签名发给客户端。</li>
</ul>
<p>3 客户端回应，</p>
<ul>
<li>首先通过客户端浏览器的CA公钥，对服务器发来的数字签名进行验证取出服务端的公钥。</li>
<li>然后再次向服务端发送一个随机数，这时候这个随机数就被公钥加密，</li>
<li>因为客户端和服务器利用之前两步产生的三个随机数利用加密算法产生秘钥。随后的加密都将使用秘钥加密。</li>
<li>客户端握手结束通知，表示客户端握手结束，同时对以前的内容做一个摘要，供给服务器校验</li>
</ul>
<p>4 服务器最后响应</p>
<ul>
<li>服务器通过三个随机数通过加密算法，得到会话秘钥，向客户端发送最后的信息，加密算法改变通知，之后都用秘钥加密。</li>
<li>握手结束，所有内容摘要供给客户端检验。</li>
</ul>
<h2 id="5-http的演进和改变"><a href="#5-http的演进和改变" class="headerlink" title="5 http的演进和改变"></a>5 http的演进和改变</h2><p>http1.1 相比http1.0提高了什么性能</p>
<ul>
<li>使用TCP长连接的方式改善了http1.0锻炼解造成的性能开希哦啊</li>
<li><strong>支持管道网络传输</strong>，只要一个请求发出去了，不必等待它的相应回来，就可以发送第二个请求出去，可以减少整体的响应时间。</li>
</ul>
<p>但是HTTP/1.1还是有性能瓶颈：</p>
<ul>
<li>请求/响应头部没有进行压缩就进行发送，首部信息越多延迟越大，智能压缩Body部分;</li>
<li>发送冗长的首部。每次相互发送相同的内容量浪费较多;</li>
<li>服务器按照请求顺序相应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头堵塞。</strong></li>
<li>没有请求优先级控制</li>
<li>请求只能从客户端开始，服务端只能被动响应。</li>
</ul>
<p>Http2相比http1进行性能改进</p>
<ul>
<li>HTTP2会<strong>压缩头</strong>部信息，同时发送多个请求，他们的头是相似的，协议会帮你消除重复的部分。</li>
<li>全面采用二进制格式，不再采用HTTP1.1纯文本的格式。</li>
<li>多路复用，Http2可以在一个连接中并发多个请求或者回应，而不用按照顺序意义对应。移除了HTTP1.1中的串行请求，不再有头部阻塞的问题，降低了延迟，大幅度提高了连接的利用率。</li>
<li>服务器推送，一定程度改善了请求应答模式，服务器不再是被动相应，可以主动向客户端发送消息。</li>
</ul>
<p>HTTP3做了什么呢？</p>
<p>http2中的问题在于，多个http请求复用一个TCP连接，下层的TCP协议不知道有多少个HTTP请求的。一旦发生丢包现象，就会出发TCP重传机制，在这样的一个TCP连接机制中<strong>所有的HTTP请求都必须等待这个丢了的包重新传回来。</strong></p>
<p>这是基于TCP传输层的问题，所以HTTP把HTTP下层的TCP改成了UDP!大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>TCP和UDP是传输层两个最基本的协议，最基本的职责是将两个在端系统间IP的交付服务扩展为在端系统的两个进程之间的交付服务。</p>
<h2 id="6-TCP和UDP的区别"><a href="#6-TCP和UDP的区别" class="headerlink" title="6 TCP和UDP的区别"></a>6 TCP和UDP的区别</h2><p><strong>可靠性</strong></p>
<p>TCP是可靠交付：无差错，不丢失，不重复。</p>
<p>UDP是尽最大努力交付，不保证可靠交付。</p>
<p><strong>拥塞控制，流量控制</strong></p>
<p>TCP有拥塞控制和流量控制保证数据传输的安全性，UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</p>
<p><strong>报文长度</strong></p>
<p>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</p>
<p>UDP面向报文，不合并，拆分，保留上面串下来的报文边界。</p>
<p><strong>首部开销</strong></p>
<p>TCP首部开销大，占20个字节，UDP占8个字节（源端口，目的端口，数据长度，校验和）</p>
<p><strong>适用场景</strong></p>
<p>若通信数据完整性比实时性重要，比如传送邮件，反之则用UDP，如视频传输，实时通信等。</p>
<h2 id="7-UDP的校验和是怎么计算的"><a href="#7-UDP的校验和是怎么计算的" class="headerlink" title="7 UDP的校验和是怎么计算的"></a>7 UDP的校验和是怎么计算的</h2><p>注意：校验和是可选的。（TCP是必选的）。UDP的校验和是药剂算首部和数据部分。首部还包括伪首部。</p>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/UDP%E6%A0%A1%E9%AA%8C%E5%92%8C.png" alt></p>
<p>多了十二字节的伪首部，注意UDP长度被计算了两次，如果校验和有错，则UDP数据报被悄悄丢弃，不产生任何差错报文。</p>
<p>校验方式：发送方对报文段所有16比特的和进行反码运算，加和其间任何其间出现溢出都会回卷。接收方将所有的比特加在一起，如果没有差错，最后的和是全为1的。</p>
<h2 id="8-TCP最大传输单元"><a href="#8-TCP最大传输单元" class="headerlink" title="8 TCP最大传输单元"></a>8 TCP最大传输单元</h2><p>TCP最大可以从缓存中取出来并放入报文段中的数量受限于最大报文段长度（MSS maxium segment size）最初确定的由本地发送主机的最大链路帧长度（最大传输单元 maximum Transmission union）MTU一般为1500字节，MSS典型值为1460字节，TCP/IP首部长度一般占40字节。</p>
<h2 id="9-TCP报文段结构"><a href="#9-TCP报文段结构" class="headerlink" title="9 TCP报文段结构"></a>9 TCP报文段结构</h2><p>TCP首部一般占20字节</p>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/TCP%E6%8A%A5%E6%96%87.png" alt></p>
<p>包括</p>
<ul>
<li>源端口号，目的端口号</li>
<li>32比特序号字段，32比特确认号字段，实现<strong>可靠数据传输服务。</strong><ul>
<li>序号：序号建立在传送字节流上，序号就是该报文段首个字节编号。</li>
<li>确认号：主机A填写的确认号是主机A希望从主机B收到的确认号。</li>
</ul>
</li>
<li>16比特接收窗口字段，<strong>用于流量控制</strong>。指示接收方愿意接受的字节数量</li>
<li>4比特<strong>首部长度</strong>字段，<strong>选择字段</strong>，协商最大报文长度MSS，或者在告诉网络环境下做窗口调节因子使用。</li>
<li>接收窗口字段，发送字节还剩下多少空间</li>
<li>6比特<strong>标志字段</strong>，ACK用于指示确认字段中的值是幼小的，即该报文包括一个对已被成功接收报文段的确认。RST,SYN和FIN分别用于连接建立和拆除。PSH被设置代表接收方应立即将数据报传输给上层。URG用来指示报文段中存在着被发送端上层实体设置为紧急的任务。紧急数据由最后的紧急数据指针字段指出。</li>
</ul>
<h2 id="10-流量控制服务和拥塞控制的区别"><a href="#10-流量控制服务和拥塞控制的区别" class="headerlink" title="10 流量控制服务和拥塞控制的区别"></a>10 流量控制服务和拥塞控制的区别</h2><p>TCP接收正确、按序到达的字节后，直接放入接收缓存。相关进程会从当前缓存读取数据，但是<strong>不一定是立即读取</strong>。接收方应用或许在忙其他方面的业务，如果发送方读取数据缓慢，就会很容易的使该连接接受缓存溢出。</p>
<ul>
<li><p><strong>流量控制服务</strong>：消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配的服务，即发送方的发送速率和接受方应用程序的读取速率相匹配。</p>
<ul>
<li><p>让发送方维护一个称为<strong>接受窗口</strong>（rwnd Recieve window）的变量来提供流量控制。接受窗口用于给发送方一个提示——该接收方窗口还有多少可用的空间。<strong>发送方控制发送出去的字节数小于接受窗口的大小。</strong></p>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.png" alt></p>
</li>
<li><p>小问题：发送方维护的rwnd为0。接收方清空缓存，但是并不向发送方发送带有新值的rwnd段。解决当主机B的接收窗口为0的时候，主机A继续发送只有一个字节的数据报段，这样B就可以返回非零的rwnd的值。</p>
</li>
</ul>
</li>
</ul>
<p><strong>拥塞控制</strong>：TCP发送方有可能因为IP网络的拥塞而被一直：这种形式的发送方控制叫做拥塞控制。</p>
<h2 id="11-简述一下TCP的三次握手四次挥手"><a href="#11-简述一下TCP的三次握手四次挥手" class="headerlink" title="11 简述一下TCP的三次握手四次挥手"></a>11 简述一下TCP的三次握手四次挥手</h2><p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%8F%A1%E6%89%8B.png" alt></p>
<ul>
<li>握手  （确认号是我想要接受的序号）</li>
</ul>
<p>1：客户算将报文段首部SYN标志位设置为1,随机生成序号seq = x，发送给服务器,客户端进入Client_sent状态。</p>
<p>2:服务器接收到包含SYN=1的数据包知道了客户端要建立请求连接，客户端将标志位SYN和ACK都置为1,将<strong>确认号</strong>置为x+1,随机生成一个序号seq=y,将数据包发回客户端确认连接请求，服务器进入SYN_recieved状态。</p>
<p>3 客户端收到数据包检查接受的确认号是否为x+1，ACK是否为1 ，如果正确将确认号设置为y+1发送给服务器，服务器检查确认号是否为y+1，ack是否为1，如果是则建立连接成功，客户端和服务器进入established状态，可以互相发送数据了。</p>
<ul>
<li>挥手</li>
</ul>
<p>TCP是全双工连接的，每一方都需要单独关闭，原则是发送FIN来终止任务，首先一方执行主动关闭，另一方执行被动关闭。</p>
<p>1 数据传输结束，客户端应用进行发出连接解释报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接受数据。</p>
<p>2 服务器接收FIN后，发送一个ACK给客户端，确认号为收到序号加1,服务器进入COLSE_WAIT状态，客户端进入FIN_WAIT2状态。</p>
<p>3 当客户端没有数据据要发送时，服务器向客户端发送一个FIN报文，此时服务器进入LAST_WAIT状态。</p>
<p>4 客户端接收到服务器的报文FIN之后，给服务器发送一个ACK报文，确认序号是收到序号+1.此时客户端进入TIME_WAIT状态，等待一段时间（报文最大生存时间）关闭连接。</p>
<h3 id="为什么是3次握手"><a href="#为什么是3次握手" class="headerlink" title="为什么是3次握手"></a>为什么是3次握手</h3><p><strong>防止本来因该失效的连接请求报文有突然回到服务器端造成服务器的浪费。</strong>例如，客户端发送一个SYN，由于网络堵塞，服务器并没有收到这个数据包。然后客户端有重新传了这个SYN数据报并且正确建立TCP连接了，传送完数据，关闭了TCP连接。这是之前发送的SYN数据包来到服务器，服务器发出应答报文段。如果没采用三次握手连接，此时服务器发送应答报文段表示已经建立起了连接，一直等着发送数据。因为客户端没有发起新的请求，会丢弃服务器的SYN。此时服务器会一直等待客户端发送数据而造成 资源的浪费。</p>
<h3 id="为什么是4次挥手"><a href="#为什么是4次挥手" class="headerlink" title="为什么是4次挥手"></a>为什么是4次挥手</h3><p>为了能够保证数据完成传输，当关闭连接时，当收到FIN报文通知的时候，它仅仅表示对方没有数据发送给你了;但是你的数据未必全部发送给了对方，所以你可以不立刻关闭SOCKET，你还可以继续传输数据给对方。你发送FIN给对方表示你同意喜爱内在可以关闭连接了，所以这里的FIN和ACK都是分开发送的。</p>
<h2 id="12-请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"><a href="#12-请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文" class="headerlink" title="12 请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"></a>12 请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文</h2><p>根据端口区分；</p>
<p>看ip头中的协议标识字段，17是udp，6是tcp</p>
<h2 id="13-TCP拥塞机制"><a href="#13-TCP拥塞机制" class="headerlink" title="13 TCP拥塞机制"></a>13 TCP拥塞机制</h2><p>主要是下面四种机制</p>
<ul>
<li>慢开始<ul>
<li>慢开始指的是TCP开始发送设置拥塞窗口cwnd=1。不要一开始就发送大量数据，先探测一下网络的拥塞程度，经过一个轮次的传输，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，防止cwnd增长过大。</li>
</ul>
</li>
<li>拥塞避免<ul>
<li>每经过一个RTT时间按，cwnd就增长1。</li>
<li>在慢开始和拥塞避免的过程中一旦发现网络拥塞，就把慢开始门限设置为当前cwnd的一半，重新设置cwnd为1</li>
</ul>
</li>
<li>快重传<ul>
<li>接收方每次接收到一个失序的报文段之后就应该立即发出重复确认，发送方只要连续次收到三个重复确认就立即重传。</li>
</ul>
</li>
<li>快速回复<ul>
<li>当发送方接受到三个连续的重复确认时，就是型乘法减小算法，把慢开始门限设置原来的一半，将cwnd设置为慢开始门限大小，执行拥塞避免算法。</li>
</ul>
</li>
</ul>
<h2 id="14-UDP-中一个包的大小最大能多大"><a href="#14-UDP-中一个包的大小最大能多大" class="headerlink" title="14 UDP 中一个包的大小最大能多大"></a>14 UDP 中一个包的大小最大能多大</h2><p>1) 以太网(Ethernet)数据帧的长度必须在 46-1500 字节之间,这是由以太网的物理特性<br>决定的.这个 1500 字节被称为链路层的 MTU(最大传输单元).但这并不是指链路层的长度<br>被限制在 1500 字节,其实这这个 MTU 指的是链路层的数据区.<br>2) 并不包括链路层的首部和尾部的 18 个字节.所以,事实上,这个 1500 字节就是网络层<br>IP 数据报的长度限制.因为 IP 数据报的首部为 20 字节,所以 IP 数据报的数据区长度最大为<br>1480 字节.<br>3) 而这个 1480 字节就是用来放 TCP 传来的 TCP 报文段或 UDP 传来的 UDP 数据报的.<br>又因为 UDP 数据报的首部 8 字节,所以 UDP 数据报的数据区最大长度为 1472 字节.这个1472 字节就是我们可以使用的字节数。</p>
<h2 id="15-TCP粘包"><a href="#15-TCP粘包" class="headerlink" title="15 TCP粘包"></a>15 TCP粘包</h2><p>发送端为了将多个发往接收端的包,更有效的发到对方,使用了优化方法<br>(Nagle 算法),将多次间隔较小、数据量小的数据,合并成一个大的数据块,<br>然后进行封包。这样,接收端,就难于分辨出来了,必须提供科学的拆包机制。</p>
<p><strong>TCP 粘包</strong> 是指发送方发送的若干包数据到接收方接收时粘成一包,从接收缓冲区看,后一包数据的头紧接着前一包数据的尾;</p>
<p><strong>发送方原因</strong><br>我们知道,TCP 默认会使用 Nagle 算法。而 Nagle 算法主要做两件事:1)只<br>有上一个分组得到确认,才会发送下一个分组;2)收集多个小分组,在一个确<br>认到来时一起发送。所以,正是 Nagle 算法造成了发送方有可能造成粘包现象。</p>
<p><strong>接收方原因</strong></p>
<p>TCP 接收到分组时,并不会立刻送至应用层处理,或者说,应用层并不一定会立即处理;实际上,T<strong>CP 将收到的分组保存至接收缓存里,然后应用程序主动从缓</strong><br><strong>存里读收到的分组。</strong>这样一来,如果 TCP 接收分组的速度大于应用程序读分组的速度,多个包就会被存至缓存,应用程序读时,就会读到多个首尾相接粘到一起的包。</p>
<p>4) 解决方法<br>1 发送方<br>对于发送方造成的粘包现象,我们可以通过关闭 Nagle 算法来解决,使用TCP_NODELAY 选项来关闭 Nagle 算法。<br>2<br>接收方</p>
<p>遗憾的是 TCP 并没有处理接收方粘包现象的机制,我们只能在应用层进行<br>处理。<br>3<br>应用层处理<br>应用层的处理简单易行!并且不仅可以解决接收方造成的粘包问题,还能解决发送方造成的粘包问题。</p>
<h2 id="16-TCP有极大定时器"><a href="#16-TCP有极大定时器" class="headerlink" title="16 TCP有极大定时器"></a>16 TCP有极大定时器</h2><ul>
<li>重传计时器<ul>
<li>在一个TCP连接中，TCP没发送一个报文段，就对此报文段设置一个超时重传计时器。若该计时器截至期到了还没有收到应答报文，则重传此报文段，并将计时器复位。</li>
</ul>
</li>
<li>持续计时器<ul>
<li>为了应对，零窗口大小通知rwnd = 0;假定服务器发送报文段，我的接收窗口为0.那么客户端就停止发送数据，直到客户端接收到一个服务器发送过来接收窗口部不为零的报文段。若这个报文段传输过程中丢了。双方定时器都会永远等着对方发送数据。为了打破这种死锁，TCP为每一个连接使用一个持续计时器，当发送方将诶收到一个<strong>窗口大小为0</strong>的确认时，就启动持续计时器。当持续定时器到时间了，发送方就发送一个特殊的报文段，叫探测报文段。这个报文段只有一个字节的数据，特有一个序号，但是他的序号不需要被确认。探测报文段提醒对端若是发生丢失，必须重传。</li>
</ul>
</li>
<li>保活计时器<ul>
<li>防止两个TCP连接之间出现长时间的空闲。假定客户打开了到服务器的连接，传送一些数据，然后就保持静默了，。在这个情况下，这个连接就永远处于打开状态。</li>
</ul>
</li>
<li>时间等待计时器<ul>
<li>在终止其间使用的。当TCP关闭一个连接时候，他不认为这个连接就真正的关闭了。在时间等待其间中，连接还处于一种中间过度状态。客户端对服务器的FIN报文段，发送ACK后进行确认后进入TIME_WAIT状态。假定ACK丢失，TIME_WAIT状态使得客户端重传最都的确认报文。经过等待后，连接正式关闭，kehudaun所有资源被释放。</li>
</ul>
</li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="17-如何理解不可靠和无连接"><a href="#17-如何理解不可靠和无连接" class="headerlink" title="17 如何理解不可靠和无连接"></a>17 如何理解不可靠和无连接</h2><p>不可靠：指的是不能保证数据报成功的到达目的地。</p>
<p>发生错误的时候，丢弃该数据报包，发送ICMP消息给信源端。可靠性由上层提供。</p>
<p>无连接：IP不维护后续数据报的的状态信息。</p>
<p>IP数据可以不安顺序发送和接收。A发送连续的数据报。达到B不一定是连续的，来回的路由选择也可能不一样。路线不一样，达到的先后顺序也不一样。</p>
<h2 id="18-IP报文的格式和各个字段的含义"><a href="#18-IP报文的格式和各个字段的含义" class="headerlink" title="18 IP报文的格式和各个字段的含义"></a>18 IP报文的格式和各个字段的含义</h2><p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/IPv4.png" alt></p>
<ul>
<li>版本号：IPV4就是4,ipv6就是6.（4）</li>
<li>首部长度：IPV4可以包含一些可变参数选项，说一需要一个参数指示数据部分从哪里开始，一般IP4数据报具有20个字节的首部。（4）</li>
<li>服务类型：不常用(8)</li>
<li>数据报长度：这个IP数据报的总长度，最多可以传送65535字节的IP数据包。一般不超过1500字节。（16）</li>
<li>标识（16） 、标志（3）、片偏移（13）：这三个字段与所谓IP分片有关。</li>
<li>生存时间TTL:经过一个路由器减1。字段为0时，数据报被丢弃，并且发送ICMP报文通知源主机。（8）</li>
<li>协议：区分上层协议（8）</li>
<li>首部校验和：将首部字段和的反码存入该字段(16)</li>
<li>源和目的IP地址(64)</li>
<li>选项：平常用不到</li>
</ul>
<h2 id="19-介绍一下IP分片"><a href="#19-介绍一下IP分片" class="headerlink" title="19 介绍一下IP分片"></a>19 介绍一下IP分片</h2><p>IP之所以分片是因为。不是所有链路层都能承载相同长度的网络分组。例如，以太网帧能承载不超过1500字节的数据。而某些广域网链路智能承载不超过576字节的数据。一个链路能承载的最大数据量叫做最大传输单元（Maxmium Transmission Unit）。每种链路可能采用不同的链路层协议，每种协议可能有不同的MTU。</p>
<p>假如在传输的过程中，收到的IP数据报字节数比我要转发出去的那条链路的MTU还要大，这个时候就需要将IP进行分解，逐个传输。</p>
<p>标识：数据报被拆分称片后具有相同的标识。</p>
<p>标志：最后一个片的标志为0,前边的为1。</p>
<p>偏移：偏移指示该片应该放到初始IP数据报的哪个位置。8字节为单位</p>
<h2 id="20-子网掩码有什么用？"><a href="#20-子网掩码有什么用？" class="headerlink" title="20 子网掩码有什么用？"></a>20 子网掩码有什么用？</h2><p>子网掩码是一种用来指明一个IP地址所标示的主机处于哪个子网当中，子网掩码不能单独存在，它还必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络部分和主机部分。使得路由更方便，先到达子网，在确定是哪个主机。</p>
<h2 id="21-子网掩码的类型"><a href="#21-子网掩码的类型" class="headerlink" title="21 子网掩码的类型"></a>21 子网掩码的类型</h2><p>因特网地址分配策略为<strong>无类别区间路由选择</strong>（CIDR）。寻址将子网哪个寻址的概念一般化了。对于组网寻址。32比特的IP地址划分成两部分，并且也具有点分十进制格式a.b.c.d/x。x最高比特构成IP地址中的网络部分，在外部路由仅仅需要考虑前x个比特。</p>
<p>具有8,16,24比特子网地址的子网哪个称为A，B,C类地址，能容纳2^24个地址。B类可容纳65534台主机。C类可容纳254台主机。</p>
<h2 id="22-IP首部校验和是怎么计算的"><a href="#22-IP首部校验和是怎么计算的" class="headerlink" title="22 IP首部校验和是怎么计算的"></a>22 IP首部校验和是怎么计算的</h2><p>与ICMP，IGMP，TCP,UDP的首部校验和有什么区别与共同点。</p>
<p>(1) 先把校验和字段置 0。<br>(2) 对首部中每个 16 位比特进行二进制反码求和。<br>(3) 结果存在检验和字段中。<br>(4) 收到一份 IP 数据包后,同样对首部中每个 16bit 二进制反码求和。<br>(5) 最后结果全为 1,表示正确,否则表示错误。<br>(6) 如果是错误的,IP 就丢弃该数据报,但是不生成差错报文,由上层去处理。<br>共同点:用到的算法都是一样的。<br>区别<strong>:IP 计算的时候没有将数据包括在内。</strong><br>ICMP,IGMP,TCP,UDP 同时覆盖首部和数据检验码。</p>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="23-RIP路由协议（因特网自治系统内部路由选择）"><a href="#23-RIP路由协议（因特网自治系统内部路由选择）" class="headerlink" title="23 RIP路由协议（因特网自治系统内部路由选择）"></a>23 RIP路由协议（因特网自治系统内部路由选择）</h2><p>弗洛伊德算法</p>
<p>1 网络中的每一个路由器都要维护他自己到其他每一个目标网络的间距离记录</p>
<p>2 距离又称跳数，规定从一个路由器直接连接的网络跳数为1,而且每经过一个路由器，则距离加一。</p>
<p>3 RIP认为好的路由就是通过的路由器最少;</p>
<p>4 RIP默认一条路径上最多有15个路由器，因此规定最大跳数是16;</p>
<p>5 RIP默认每30秒广播一次RIP更新信息。</p>
<p>每个路由器包括三个内容：目的网络、距离、下一跳路由器。</p>
<p>1、对地址为 X 的路由器发过来的路由表 ,先修改此路由表中的所有项目:把 ” 下一<br>跳 ” 字段中的地址改为 X ,并把所有 ” 距离 ” 字段都加 1。<br>2、对修改后的路由表中的每一个项目,进行以下步骤:<br>2.1、将 X 的路由表(修改过的),与 S 的路由表的目的网络进行对比。<br>若在 X 中出现,在 S 中没出现,则将 X 路由表中的这一条项目添加到 S 的路由表<br>中。<br>2.2、对于目的网络在 S 和 X 路由表中都有的项目进行下面步骤<br>2.2.1、在 S 的路由表中,若下一跳地址是 x<br>则直接用 X 路由表中这条项目替换 S 路由表中的项目。<br>2.2.2、在 S 的路由表中,若下一跳地址不是 x<br>若 X 路由表项目中的距离 d 小于 S 路由表中的距离,则进行更新。<br>3、若 3 分钟还没有收到相邻路由器的更新表,则把此相邻路由器记为不可到达路由器,即把距离设置为 16。</p>
<h2 id="24-自治系统间的路由选择BGP"><a href="#24-自治系统间的路由选择BGP" class="headerlink" title="24 自治系统间的路由选择BGP"></a>24 自治系统间的路由选择BGP</h2><h2 id="25-ICMP报文的分类"><a href="#25-ICMP报文的分类" class="headerlink" title="25 ICMP报文的分类"></a>25 ICMP报文的分类</h2><p>ICMP的层次和作用</p>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/ICMP.png" alt></p>
<p>​    UDP端口不可达到例子中返回的ICMP报文</p>
<p>ICMP一般被认为是IP的一部分。从体系结构上位于IP之上，ICMP报文是承载在IP分组中的。主要传递差错报文和其他要注意的信息。</p>
<p>ICMP报文的分类</p>
<p>ICMP分为两类ICMP查询报文，另一类是ICMP差错报文</p>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/ICMP%E5%88%86%E7%B1%BB.png" alt></p>
<p>终点不可达什么情况下发出</p>
<p>路由器给主机寻路时，没有找到相应路径，向源IP发回ICMP主机不可达</p>
<p>什么情况下不会产生ICMP差错报文？</p>
<p>目的地址是广播地址或者多播地址的IP数据报</p>
<p>链路广播的数据报</p>
<p>不是IP分片的第一片</p>
<p>源地址不是单个主机的数据报</p>
<p>ICMP 重定向差错报文是怎么来的,在何种场合出现?</p>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%87%8D%E5%AE%9A%E5%90%91ICMP.png" alt></p>
<p>1 主机发送IP数据报给R1,因为主机默认路由指向的下一跳是R1。</p>
<p>2 R1收到数据报检查他的路由表。发现下一跳是R2。当它把数据报发送给R2的时候，发现发送接口与接收该数据报的端口是一样的，因此发送一个ICMP重定向报文给主机。</p>
<p>3 主机接收到ICMP重定向报文，接下来将数据报直接发送给R2，不再发送给R1</p>
<p>重定向报文只能是路由器生成，给主机使用。</p>
<h2 id="26-为什么要有MAC地址"><a href="#26-为什么要有MAC地址" class="headerlink" title="26 为什么要有MAC地址"></a>26 为什么要有MAC地址</h2><p>事实上并不是所有的主机或者路由器具有链路层地址，而是他们的适配器（网络接口）具有链路层地址。。因此就会有多个网络接口的主机或者路由器将具有多个链路层地址，也就像他具有与之相关联的IP地址一样。</p>
<p><strong>局域网设计是为人意的网络层协议而设计的，而不只是用于IP和因特网。如果适配器指派的是IP地址而不是MAC地址，则适配器不能方便的支持其他的网络层协议。其次网络层地址必须存储在RAM中，在每次适配器移动的时候要从新配置。用MAC地址和IP地址两个地址，用于分别表示物理地址和逻辑地址是有好处的。这样分层可以使网络层与链路层的协议更灵活地替换，网络层不一定非要用『IP』协议，链路层也不一定非用『以太网』协议。</strong></p>
<h2 id="27-ARP协议"><a href="#27-ARP协议" class="headerlink" title="27 ARP协议"></a>27 ARP协议</h2><p><strong>ARP为IP地址得到对应的硬件地址提供动态映射</strong></p>
<p>ARP只能为同一个子网上的主机和路由器解析IP地址。</p>
<p>ARP(地址解析协议)，当主机要发送一个IP包的时候，会先查自己的ARP高速缓存表，如果查询的IP-MAC的值不存在，主机向网络广播一个ARP请求，这个包里有等待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那就回应一个ARP应答包，源主机拿到ARP应答包后会更新自己的ARP缓存表。源主机根据ARP缓存表准备好数据链路层的数据报发送工作。</p>
<p>点对点链路使用ARP吗？</p>
<p>不使用</p>
<p>ARP高效运行的关键是什么？</p>
<p>关键是每个主机都有一个ARP的告诉缓存。</p>
<p>ARP的各个字段及含义？</p>
<p><img src="/media/brook/OS/C++%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/ARP.png" alt></p>
<p>帧类型:ARP:0x0806 (2)<br>ARP 首部:<br>硬件类型:硬件地址的类型,1 表示以太网地址。(2)<br>协议类型:协议地址的类型,0x0800 表示 IP 地址。(2)<br>硬件地址长度:字节为单位 6 (1)<br>协议地址长度:字节为单位 4 (1)<br>操作类型:2 个字节。 ARP 请求 1,ARP 回复 2,RARP 请求 3,RARP 应答 4。(2)<br>发送者硬件地址:6 个字节(6)<br>发送者 IP 地址:4 个字节(4)<br>目标硬件地址:6 个字节(6)<br>目标 IP 地址:4 个字节(4)<br>CRC 校验:4 个字节 (4)</p>
<p>总结:<br>arp 总共 28 个字节。<br>记忆方法: 以太网先目地后源,ARP 先发送端后目地端。先硬件后协议</p>
<p>ARP协议有什么缺点？</p>
<p>1 缓存：主机的地址映射是基于高速缓存的，动态更新的。地址刷新是有时间限制的。以通过哦下次更新之前修改计算机上的地址缓存，造成拒绝服务攻击或者ARP欺骗。</p>
<p>2 广播：可以伪装成ARP应答</p>
<p>3ARP应答没有认证，都是合法的。可以在不接受到请求的时候发出应答包。</p>
<p>ARP代理的概念？</p>
<p>若ARP请求是一个网络主机发送到另一个网络上的主机。那么连接这两个网络的路由器就可以回答该请求，这个过程叫做ARP代理。ARP代理路由器响应ARP请求的MAC地址为路由器的MAC地址而非ARP请求主机的MAC地址。</p>
<p>28 数据链路层MTU的最大值和最小值分别为多少？</p>
<p>1 数据链路层的最小MTU为64字节。最大为1500字节</p>
<p>　要保证以太网的重传，<strong>必须保证A收到碰撞信号的时候，数据包没有传完</strong>，要实现这一要求，A和B之间的距离很关键，也就是说信号在A和B之间传输的来回时间必须控制在一定范围之内。IEEE定义了这个标准，一个碰撞域内，<strong>最远的两台机器之间的round-trip time 要小于512bit time</strong>.(来回时间小于512位时，所谓位时就是传输一个比特需要的时间）。</p>
<p>对于 IEEE802.3,两个站点的最远距离不超过 2500m,<br>由 4 个中继器连接而成,其冲突窗口为 51.2us(2 倍电缆传播延迟加上 4 个中继器的双向延<br>迟).对于 10Mbps 的 IEEE802.3 来说,这个时间等于发送 64 字节,即 512 位的时间,64 字<br>节就是由此而来的。如果一个站点已经传输了 512bit,就认为它已经占用了这个信道。</p>
<h2 id="28-知道各个层使用的是哪个数据交换设备。"><a href="#28-知道各个层使用的是哪个数据交换设备。" class="headerlink" title="28:知道各个层使用的是哪个数据交换设备。"></a>28:知道各个层使用的是哪个数据交换设备。</h2><p>(交换机、路由器、网关)</p>
<p>网关：应用层，传输层（网关在传输层以上实现网络互联，是最复杂的网络互联设备，仅仅用于两个高层协议不同的网络互联。）</p>
<p>路由器:网络层（路由选择，存储转发）</p>
<p>交换机：数据链路层、网络层（识别数据包的MAC地址信息，根据MAC地址进行转发，并将这些地址与相应的端口记录在一个表中）</p>
<p>网桥：数据链路层，两个LAN连接起来，根据MAC转发</p>
<p>集线器：物理层设备（主要用来连接计算机等网络终端）</p>
<p>中继器：物理层，在比特级对网络信号进行再生和重定时，使得他们能够在网络上传输更长的距离。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/yangmiemie99.github.io/tags/计算机网络/" rel="tag"># 计算机网络</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/yangmiemie99.github.io/2020/02/24/Linux基础篇/" rel="next" title="Linux基础篇">
                <i class="fa fa-chevron-left"></i> Linux基础篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/" rel="prev" title="LeetCode分类解题记录">
                LeetCode分类解题记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/yangmiemie99.github.io/images/touxiang.jpeg" alt="Yang MieMie">
            
              <p class="site-author-name" itemprop="name">Yang MieMie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/yangmiemie99.github.io/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/yangmiemie99.github.io/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/yangmiemie99.github.io/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yangmiemie99" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络概述"><span class="nav-number">1.</span> <span class="nav-text">计算机网络概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络的网络"><span class="nav-number">2.</span> <span class="nav-text">网络的网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ISP"><span class="nav-number">2.1.</span> <span class="nav-text">ISP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#电路交换与分组交换"><span class="nav-number">2.2.</span> <span class="nav-text">电路交换与分组交换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#电路交换"><span class="nav-number">2.2.1.</span> <span class="nav-text">电路交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组交换"><span class="nav-number">2.2.2.</span> <span class="nav-text">分组交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络核心"><span class="nav-number">2.2.3.</span> <span class="nav-text">网络核心</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时延"><span class="nav-number">2.3.</span> <span class="nav-text">时延</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机体系结构"><span class="nav-number">2.4.</span> <span class="nav-text">计算机体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#五层协议"><span class="nav-number">2.4.1.</span> <span class="nav-text">五层协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#应用层"><span class="nav-number">3.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-DNS的概念，用途，DNS查询的实现算法"><span class="nav-number">3.1.</span> <span class="nav-text">1 DNS的概念，用途，DNS查询的实现算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-http协议"><span class="nav-number">3.2.</span> <span class="nav-text">2 http协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的状态码"><span class="nav-number">3.2.1.</span> <span class="nav-text">常见的状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET和Post的区别"><span class="nav-number">3.2.2.</span> <span class="nav-text">GET和Post的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookies和session的区别"><span class="nav-number">3.2.3.</span> <span class="nav-text">Cookies和session的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-一次完整的http-请求所经历的步骤"><span class="nav-number">3.3.</span> <span class="nav-text">3 一次完整的http 请求所经历的步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-http-和https的区别"><span class="nav-number">3.4.</span> <span class="nav-text">4 http 和https的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SSL-TLS协议的基本流程"><span class="nav-number">3.4.1.</span> <span class="nav-text">SSL/TLS协议的基本流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-http的演进和改变"><span class="nav-number">3.5.</span> <span class="nav-text">5 http的演进和改变</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#传输层"><span class="nav-number">4.</span> <span class="nav-text">传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-TCP和UDP的区别"><span class="nav-number">4.1.</span> <span class="nav-text">6 TCP和UDP的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-UDP的校验和是怎么计算的"><span class="nav-number">4.2.</span> <span class="nav-text">7 UDP的校验和是怎么计算的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-TCP最大传输单元"><span class="nav-number">4.3.</span> <span class="nav-text">8 TCP最大传输单元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-TCP报文段结构"><span class="nav-number">4.4.</span> <span class="nav-text">9 TCP报文段结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-流量控制服务和拥塞控制的区别"><span class="nav-number">4.5.</span> <span class="nav-text">10 流量控制服务和拥塞控制的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-简述一下TCP的三次握手四次挥手"><span class="nav-number">4.6.</span> <span class="nav-text">11 简述一下TCP的三次握手四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么是3次握手"><span class="nav-number">4.6.1.</span> <span class="nav-text">为什么是3次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么是4次挥手"><span class="nav-number">4.6.2.</span> <span class="nav-text">为什么是4次挥手</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"><span class="nav-number">4.7.</span> <span class="nav-text">12 请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-TCP拥塞机制"><span class="nav-number">4.8.</span> <span class="nav-text">13 TCP拥塞机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-UDP-中一个包的大小最大能多大"><span class="nav-number">4.9.</span> <span class="nav-text">14 UDP 中一个包的大小最大能多大</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-TCP粘包"><span class="nav-number">4.10.</span> <span class="nav-text">15 TCP粘包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-TCP有极大定时器"><span class="nav-number">4.11.</span> <span class="nav-text">16 TCP有极大定时器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络层"><span class="nav-number">5.</span> <span class="nav-text">网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#17-如何理解不可靠和无连接"><span class="nav-number">5.1.</span> <span class="nav-text">17 如何理解不可靠和无连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-IP报文的格式和各个字段的含义"><span class="nav-number">5.2.</span> <span class="nav-text">18 IP报文的格式和各个字段的含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-介绍一下IP分片"><span class="nav-number">5.3.</span> <span class="nav-text">19 介绍一下IP分片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-子网掩码有什么用？"><span class="nav-number">5.4.</span> <span class="nav-text">20 子网掩码有什么用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-子网掩码的类型"><span class="nav-number">5.5.</span> <span class="nav-text">21 子网掩码的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-IP首部校验和是怎么计算的"><span class="nav-number">5.6.</span> <span class="nav-text">22 IP首部校验和是怎么计算的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链路层"><span class="nav-number">6.</span> <span class="nav-text">链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#23-RIP路由协议（因特网自治系统内部路由选择）"><span class="nav-number">6.1.</span> <span class="nav-text">23 RIP路由协议（因特网自治系统内部路由选择）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-自治系统间的路由选择BGP"><span class="nav-number">6.2.</span> <span class="nav-text">24 自治系统间的路由选择BGP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-ICMP报文的分类"><span class="nav-number">6.3.</span> <span class="nav-text">25 ICMP报文的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-为什么要有MAC地址"><span class="nav-number">6.4.</span> <span class="nav-text">26 为什么要有MAC地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-ARP协议"><span class="nav-number">6.5.</span> <span class="nav-text">27 ARP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-知道各个层使用的是哪个数据交换设备。"><span class="nav-number">6.6.</span> <span class="nav-text">28:知道各个层使用的是哪个数据交换设备。</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yang MieMie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/yangmiemie99.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
