<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/yangmiemie99.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/yangmiemie99.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/yangmiemie99.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/yangmiemie99.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/yangmiemie99.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/yangmiemie99.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/yangmiemie99.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="剑指Offer,算法,数据结构,LeetCode,">










<meta name="description" content="数组剑指Offer题目3：找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 1234567891011121314// 利用哈希表思想，作出    int findRepeatNumber(vector&amp;lt;int&amp;gt;&amp;amp; nu">
<meta name="keywords" content="剑指Offer,算法,数据结构,LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode分类解题记录">
<meta property="og:url" content="https://yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/index.html">
<meta property="og:site_name" content="MieMieBlog">
<meta property="og:description" content="数组剑指Offer题目3：找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 1234567891011121314// 利用哈希表思想，作出    int findRepeatNumber(vector&amp;lt;int&amp;gt;&amp;amp; nu">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/ip%E6%8B%86%E5%88%86.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/Ip%E7%94%BB%E8%A1%A8.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/ABC.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E5%A4%8D%E5%8E%9FIP.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E7%94%B5%E8%AF%9D%E5%8F%B7.png">
<meta property="og:updated_time" content="2020-03-23T18:18:25.684Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode分类解题记录">
<meta name="twitter:description" content="数组剑指Offer题目3：找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 1234567891011121314// 利用哈希表思想，作出    int findRepeatNumber(vector&amp;lt;int&amp;gt;&amp;amp; nu">
<meta name="twitter:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/ip%E6%8B%86%E5%88%86.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/yangmiemie99.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/">





  <title>LeetCode分类解题记录 | MieMieBlog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/yangmiemie99.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MieMieBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/yangmiemie99.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/yangmiemie99.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/yangmiemie99.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/yangmiemie99.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/yangmiemie99.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yang MieMie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/yangmiemie99.github.io/images/touxiang.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MieMieBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode分类解题记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T16:50:23+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yangmiemie99.github.io/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="剑指Offer题目3：找出数组中重复的数字。"><a href="#剑指Offer题目3：找出数组中重复的数字。" class="headerlink" title="剑指Offer题目3：找出数组中重复的数字。"></a>剑指Offer题目3：找出数组中重复的数字。</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用哈希表思想，作出</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hashVec(length,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; length;++i)&#123;</span><br><span class="line">            hashVec[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashVec[i] &gt;=<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer题目4：二维数组中的查找"><a href="#剑指Offer题目4：二维数组中的查找" class="headerlink" title="剑指Offer题目4：二维数组中的查找"></a>剑指Offer题目4：二维数组中的查找</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<blockquote>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题考虑了一会儿，发现从左上角开始查询判断会出现列来回走的情况，判断只要从右上角开始查询，大了左，小了向下查询就可以。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">    <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(cols == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> col = cols<span class="number">-1</span>,row = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从右上角开始，大了向左，小了向下</span></span><br><span class="line">    <span class="keyword">while</span>(col &gt;=<span class="number">0</span> &amp;&amp; row &lt; rows)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer29-顺时针打印数组"><a href="#剑指Offer29-顺时针打印数组" class="headerlink" title="剑指Offer29:顺时针打印数组"></a>剑指Offer29:顺时针打印数组</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>思路：确定好循环次数，考虑好特殊情况就可以了，犯的错误为确定循环次数的时候。注意细节</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">    <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(cols == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 这里应该是小的数确定循环次数</span></span><br><span class="line">    <span class="keyword">int</span> maxLengthOrWide = rows &lt; cols ? rows: cols;</span><br><span class="line">    <span class="keyword">if</span>(maxLengthOrWide &amp; <span class="number">0x01</span> == <span class="number">1</span>)</span><br><span class="line">        maxLengthOrWide+=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环的次数</span></span><br><span class="line">    <span class="keyword">int</span> circleTimes = (maxLengthOrWide &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; circleTimes;++i)&#123;</span><br><span class="line">        <span class="comment">// 打印第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; cols-i; ++j)&#123;</span><br><span class="line">            res.push_back(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印右边的一列，考虑只有一行的情况</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; rows - <span class="number">1</span>- i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; rows -i;++j)&#123;</span><br><span class="line">                res.push_back(matrix[j][cols-i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印最下边的一行，考虑只有一列,或者只有一行的情况</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; cols-i<span class="number">-1</span> &amp;&amp; i &lt; rows-i<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = cols-i<span class="number">-2</span>; j&gt;=i;--j)&#123;</span><br><span class="line">                res.push_back(matrix[rows-i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印最左边的一行，只有一列 或者两行之内都不打印</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; cols<span class="number">-1</span>-i &amp;&amp; i &lt; rows-i<span class="number">-2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = rows-i<span class="number">-2</span>; j &gt; i; --j)&#123;</span><br><span class="line">                res.push_back(matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer53-在排序数组中查找数字"><a href="#剑指Offer53-在排序数组中查找数字" class="headerlink" title="剑指Offer53:在排序数组中查找数字"></a>剑指Offer53:在排序数组中查找数字</h2><p>统计一个数字在排序数组中出现的次数。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>利用二分查找的思想，找到最左边的数字和最右边的数字。犯的错误总结：要<strong>先判断相等</strong>在判断其他的，<strong>否则当数字出现在边界的时候会出现无限循环的情况。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//二分查找思想</span></span><br><span class="line">       <span class="comment">//先找到左边相等的元素</span></span><br><span class="line">       <span class="keyword">int</span> length = nums.size();</span><br><span class="line">       <span class="keyword">if</span>(length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> right = length <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">int</span> leftTarget = <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">int</span> rightTarget = <span class="number">-1</span>;</span><br><span class="line">       <span class="comment">//等于号一定要有</span></span><br><span class="line">       <span class="keyword">while</span>(right &gt;= left)&#123;</span><br><span class="line">           <span class="keyword">int</span> middle = (left + right) &gt;&gt;<span class="number">1</span>;                </span><br><span class="line">           <span class="keyword">if</span>(nums[middle] == target)&#123;</span><br><span class="line">               <span class="keyword">if</span>(middle == <span class="number">0</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   leftTarget = <span class="number">0</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle <span class="number">-1</span>] &lt; target)</span><br><span class="line">               &#123;</span><br><span class="line">                   leftTarget = middle;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;            </span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(nums[middle] &gt;= target)</span><br><span class="line">               <span class="comment">//记得要加减1否则会跳不出循环</span></span><br><span class="line">               right = middle <span class="number">-1</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)</span><br><span class="line">               left = middle + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       left = <span class="number">0</span>;</span><br><span class="line">       right = length <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">while</span>(right &gt;= left)&#123;</span><br><span class="line">       <span class="keyword">int</span> middle = (left + right) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>(nums[middle] == target)&#123;</span><br><span class="line">           <span class="keyword">if</span>(middle == length <span class="number">-1</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               rightTarget = length<span class="number">-1</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle +<span class="number">1</span>] &gt; target)</span><br><span class="line">           &#123;</span><br><span class="line">               rightTarget = middle;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(nums[middle] &gt; target)</span><br><span class="line">           right = middle <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt;= target)</span><br><span class="line">           left = middle +<span class="number">1</span>;</span><br><span class="line">       &#125;   </span><br><span class="line">       <span class="comment">// 这里是大于等于零，写错了</span></span><br><span class="line">       <span class="keyword">if</span>(leftTarget &gt;=<span class="number">0</span> &amp;&amp; rightTarget&gt;=<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> (rightTarget - leftTarget +<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer53-0-n-1中缺失的数字"><a href="#剑指Offer53-0-n-1中缺失的数字" class="headerlink" title="剑指Offer53:0-n-1中缺失的数字"></a>剑指Offer53:0-n-1中缺失的数字</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>要考虑好特殊情况，缺失的数字出现在边界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> length = nums.size();</span><br><span class="line">     <span class="keyword">if</span>(length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     <span class="comment">// 依然利用二分查找思想</span></span><br><span class="line">     <span class="keyword">int</span> left =<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> right  = length <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">int</span> mid;</span><br><span class="line">     <span class="keyword">while</span>(right &gt;= left)&#123;</span><br><span class="line">         mid = (left+right) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(nums[mid] == mid)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(mid == length <span class="number">-1</span>)</span><br><span class="line">                 <span class="keyword">return</span> mid +<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid +<span class="number">1</span>] &gt; mid +<span class="number">1</span>)</span><br><span class="line">                 <span class="keyword">return</span> mid +<span class="number">1</span>;</span><br><span class="line">             left = mid +<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(nums[mid] &gt; mid)&#123;</span><br><span class="line">             <span class="keyword">if</span>(mid == <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">             right = mid <span class="number">-1</span>;</span><br><span class="line">         &#125;    </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h1><h2 id="两类查找问题"><a href="#两类查找问题" class="headerlink" title="两类查找问题"></a>两类查找问题</h2><p>查找有无</p>
<ul>
<li>元素a是否存在？ set;集合</li>
</ul>
<p>查找对应关系</p>
<ul>
<li>元素a 出现了几次？ map;字典</li>
</ul>
<p>通常语言的标准库中都内置set,map </p>
<ul>
<li>容器类</li>
<li>屏蔽实现细节</li>
</ul>
<p>常见操作：</p>
<ul>
<li>insert</li>
<li>find</li>
<li>erase</li>
<li>change(map)</li>
</ul>
<p>来看几道题熟悉一下</p>
<h2 id="剑指Offer50-第一个只出现一次的字符"><a href="#剑指Offer50-第一个只出现一次的字符" class="headerlink" title="剑指Offer50:第一个只出现一次的字符"></a>剑指Offer50:第一个只出现一次的字符</h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; charMap;</span><br><span class="line">    <span class="keyword">int</span> length = s.size();</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; length;++i)&#123;</span><br><span class="line">        charMap[s[i]] +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(charMap[s[i]] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer48-最长不含重复的子字符串××××"><a href="#剑指Offer48-最长不含重复的子字符串××××" class="headerlink" title="剑指Offer48:最长不含重复的子字符串××××"></a>剑指Offer48:最长不含重复的子字符串××××</h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>利用一个map,存入相应字符和出现的位置，max始终记录出现最长的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Slength = s.size();</span><br><span class="line">    <span class="keyword">if</span>(Slength == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; maxStrLen;</span><br><span class="line">    <span class="keyword">int</span> tmpLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 不重复子串起始位置</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; Slength; ++i)&#123;</span><br><span class="line">        <span class="comment">// 找到和之前一样的元素了</span></span><br><span class="line">        <span class="keyword">if</span>(maxStrLen.find(s[i]) != maxStrLen.end() &amp;&amp; maxStrLen[s[i]] &gt;= start)&#123;</span><br><span class="line">            <span class="comment">// 更新起始位置------------一定要考虑清楚</span></span><br><span class="line">            start = maxStrLen[s[i]] +<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新长度</span></span><br><span class="line">            tmpLen = i - maxStrLen[s[i]];</span><br><span class="line">            maxStrLen[s[i]] = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 新元素</span></span><br><span class="line">            maxStrLen[s[i]] = i;</span><br><span class="line">            tmpLen += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmpLen &gt; max)</span><br><span class="line">            max = tmpLen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode349-两个数组的交集"><a href="#LeetCode349-两个数组的交集" class="headerlink" title="LeetCode349:两个数组的交集"></a>LeetCode349:两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我直接写的，两个map解决问题,整体时间复杂度O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度O(n)</span></span><br><span class="line"><span class="comment">// 使用unordered_map解决问题时间空间复杂度都为O(n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line"> <span class="comment">//       unordered_set&lt;int&gt; nums1Set;</span></span><br><span class="line"> <span class="comment">//       unordered_set&lt;int&gt; nums2Set;        </span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums1Set;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums2Set;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(length1 ==<span class="number">0</span> || length2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; length1;++i)&#123;</span><br><span class="line">            <span class="comment">// O(nlogn)  unor</span></span><br><span class="line">            nums1Set.insert(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; length2;++i)&#123;</span><br><span class="line">            <span class="comment">// O(nlogn)</span></span><br><span class="line">            nums2Set.insert(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(nlogn)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = nums1Set.begin(); i != nums2Set.end(); ++i)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums2Set.find(*i) != nums2Set.end())&#123;</span><br><span class="line">                res.push_back(*i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums1Set(nums1.begin(),nums1.end());</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums2Set(nums2.begin(),nums2.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(length1 ==<span class="number">0</span> || length2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = nums1Set.begin(); i != nums2Set.end(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2Set.find(*i) != nums2Set.end())&#123;</span><br><span class="line">                res.push_back(*i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 再简化一下，换个思路，效率变低，还是第一个最快</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums1Set(nums1.begin(),nums1.end());</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; resSet;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; nums2.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1Set.find(nums2[i]) != nums1Set.end())&#123;</span><br><span class="line">                resSet.insert(nums2[i]);  <span class="comment">// set中没有重复元素。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(resSet.begin(),resSet.end());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode350-两个数组的交集"><a href="#LeetCode350-两个数组的交集" class="headerlink" title="LeetCode350 两个数组的交集"></a>LeetCode350 两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; nums1Map;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(length1 == <span class="number">0</span> || length2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// O(nlogn)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; length1;++i)&#123;</span><br><span class="line">            nums1Map[nums1[i]] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(nlogn)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; length2;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1Map[nums2[i]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                res.push_back(nums2[i]);</span><br><span class="line">                nums1Map[nums2[i]] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map默认值"><a href="#Map默认值" class="headerlink" title="Map默认值"></a>Map默认值</h2><p>在Map中如果打印不存在的元素，默认值为0，一旦访问查找了一个元素，那么这个元素会插入map默认值为0。所以映射值为0并不代表这个元素不再这个map中。想要真正删除元素 map.erase(). </p>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><table>
<thead>
<tr>
<th></th>
<th>普通数组实现</th>
<th>顺序数组实现</th>
<th>二分搜索树（平衡）</th>
<th>哈希表</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(logn)</td>
<td>O(1)</td>
</tr>
<tr>
<td>查找</td>
<td>O(n)</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td>O(1)</td>
</tr>
<tr>
<td>删除</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(logn)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>哈希表失去了顺序性质</p>
<p>set 和map的底层实现就是一个平衡的二分搜索树</p>
<h2 id="数据顺序型的作用"><a href="#数据顺序型的作用" class="headerlink" title="数据顺序型的作用"></a>数据顺序型的作用</h2><p>数据集中的最大值和最小值</p>
<p>某个元素的前驱和后继</p>
<p>莫个与那素的floor和ceil</p>
<p>莫个元素的排位rank</p>
<p>选择莫个排位的元素select</p>
<p>unordered_map 和unordered_set底层为哈希表的实现</p>
<h2 id="LeetCode有效的字母异位词"><a href="#LeetCode有效的字母异位词" class="headerlink" title="LeetCode有效的字母异位词"></a>LeetCode有效的字母异位词</h2><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Slength = s.size();</span><br><span class="line">        <span class="keyword">int</span> Tlength = t.size();</span><br><span class="line">        <span class="keyword">if</span>(Slength == <span class="number">0</span> || Tlength == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(Slength != Tlength)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; hashTmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; Slength; ++i)&#123;</span><br><span class="line">            hashTmp[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Tlength;++i)&#123;</span><br><span class="line">            hashTmp[t[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里写错了一下，应该是两个参数《char,int》</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator itr = hashTmp.begin(); itr != hashTmp.end(); ++itr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(itr -&gt; second != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看了一下别人的，可以用数组模拟哈希，因为只有26个字母，好很多</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthS = s.size();</span><br><span class="line">        <span class="keyword">int</span> lengthT = t.size();</span><br><span class="line">        <span class="keyword">if</span>(lengthS!=lengthT)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(lengthS == <span class="number">0</span> || lengthT ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iElement:s)&#123;</span><br><span class="line">            hash[iElement - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iElement :t)&#123;</span><br><span class="line">            hash[iElement -<span class="string">'a'</span>] --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-290单词规律（花费时间长）"><a href="#LeetCode-290单词规律（花费时间长）" class="headerlink" title="LeetCode 290单词规律（花费时间长）"></a>LeetCode 290单词规律（花费时间长）</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>利用一个map, 构建字母到单词的映射，先找字母是否在map中出现，出现过判断再次出现的单词是否与之前的映射相等。如果没出现过，还要判断映射到的单词是否与之前映射的单词相等，如果相等还是不行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthP = pattern.size();</span><br><span class="line">    <span class="keyword">int</span> lengthS = str.size();</span><br><span class="line">    <span class="keyword">if</span>(lengthS == <span class="number">0</span> &amp;&amp; lengthP == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; tempMap;</span><br><span class="line">    <span class="built_in">string</span> tmpWord;        </span><br><span class="line">    <span class="keyword">int</span> pStr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthP;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(pStr &lt; lengthS &amp;&amp; str[pStr] != <span class="string">' '</span>)&#123;</span><br><span class="line">            tmpWord += str[pStr++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把空格去掉别忘了</span></span><br><span class="line">        pStr++;</span><br><span class="line">        <span class="keyword">if</span>(tempMap.find(pattern[i]) != tempMap.end())&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempMap[pattern[i]] != tmpWord)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 这里原来没想到，不同的字母映射到相同的单词是不行的。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> itr = tempMap.begin(); itr != tempMap.end();++itr)&#123;</span><br><span class="line">                <span class="keyword">if</span>(itr -&gt; second == tmpWord)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入映射</span></span><br><span class="line">            tempMap[pattern[i]] = tmpWord;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        tmpWord.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//别忘了加1，</span></span><br><span class="line">    <span class="keyword">if</span>(pStr == lengthS+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthP = pattern.size();</span><br><span class="line">    <span class="keyword">int</span> lengthS = str.size();</span><br><span class="line">    <span class="keyword">if</span>(lengthS == <span class="number">0</span> &amp;&amp; lengthP == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; tempMap;</span><br><span class="line">    <span class="comment">// 定义出现过的字符</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; used;</span><br><span class="line">    <span class="built_in">string</span> tmpWord;        </span><br><span class="line">    <span class="keyword">int</span> pStr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthP;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(pStr &lt; lengthS &amp;&amp; str[pStr] != <span class="string">' '</span>)&#123;</span><br><span class="line">            tmpWord += str[pStr++];</span><br><span class="line">        &#125;</span><br><span class="line">        pStr++;</span><br><span class="line">        <span class="keyword">if</span>(tempMap.find(pattern[i]) != tempMap.end())&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempMap[pattern[i]] != tmpWord)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//改进思路：之前的时间复杂度为O(n^2) 判断之前出现过单词可以用另一个哈希表来实现。</span></span><br><span class="line">            <span class="keyword">if</span>(used[tmpWord] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            used[tmpWord]++;</span><br><span class="line">            tempMap[pattern[i]] = tmpWord;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        tmpWord.clear();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(pStr == lengthS+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进思路：之前的时间复杂度为O(n^2) 判断之前出现过单词可以用另一个哈希表来实现。看一下别人的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; m;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; used;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pos!=<span class="number">-1</span>)<span class="comment">//读取str中的单词</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos=str.find_first_of(<span class="string">' '</span>,i);<span class="comment">//相当于返回每个空格的索引值,如果找不到空格则-1</span></span><br><span class="line">            <span class="built_in">string</span> temp=str.substr(i,pos-i);<span class="comment">//截取单词</span></span><br><span class="line">            vs.push_back(temp);<span class="comment">//插入单词元素</span></span><br><span class="line">            i=pos+<span class="number">1</span>;<span class="comment">//相当于每个单词的首位索引值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vs.size()!=pattern.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pattern.size();i++)&#123;<span class="comment">//遍历左边数组</span></span><br><span class="line">            s = vs[i];<span class="comment">//依次赋值单词字符串</span></span><br><span class="line">            <span class="keyword">if</span>(m.count(pattern[i])==<span class="number">0</span>) <span class="comment">//如果左边(pattern)数组出现新字母时,执行</span></span><br><span class="line">                <span class="keyword">if</span>(used[s]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//因为每个新字母对应一个新单词,不能新字母对应旧字符串</span></span><br><span class="line">                                        <span class="comment">//所以出现新字母时,要保证单词也是新的,如果是已经出现过的字符串则返回false</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    m[pattern[i]] = s;  <span class="comment">//匹配键值对</span></span><br><span class="line">                    used[s]++;         <span class="comment">//相当于标记某个单词已经出现过了</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s!=m[pattern[i]]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//判断str中第i个的字符串是否与映射表中第i位所对应的字符串相等</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="创建链表，打印链表"><a href="#创建链表，打印链表" class="headerlink" title="创建链表，打印链表"></a>创建链表，打印链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ListNode* <span class="title">creatLinkedList</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(arr[<span class="number">0</span>]);</span><br><span class="line">    ListNode* curNode = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        curNode -&gt; next = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">        curNode = curNode -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    ListNode* curNode = head;</span><br><span class="line">    <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; curNode -&gt; val &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">        curNode = curNode -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteLinkedList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    ListNode* curNode = head;</span><br><span class="line">    <span class="keyword">while</span>(curNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ListNode* delNode = curNode;</span><br><span class="line">        curNode = curNode -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> curNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下之前自己做的剑指Offer上的题目，从来一遍。</p>
<h2 id="剑指Offer18，删除链表的节点"><a href="#剑指Offer18，删除链表的节点" class="headerlink" title="剑指Offer18，删除链表的节点"></a>剑指Offer18，删除链表的节点</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。<strong>注意：</strong>此题对比原题有改动</p>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p>
<p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<p>说明：</p>
<p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 简单，别定义错了这里定义的是节点指针</span></span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur -&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> cur -&gt; next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre -&gt; next = cur -&gt; next;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer面试题22：链表中倒数第k个节点"><a href="#剑指Offer面试题22：链表中倒数第k个节点" class="headerlink" title="剑指Offer面试题22：链表中倒数第k个节点"></a>剑指Offer面试题22：链表中倒数第k个节点</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* lastK = head;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//考虑不足k个</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cur = cur -&gt; next;</span><br><span class="line">        lastK = lastK -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer24-反转链表"><a href="#剑指Offer24-反转链表" class="headerlink" title="剑指Offer24:反转链表"></a>剑指Offer24:反转链表</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<h3 id="思路：定义三个指针解决问题"><a href="#思路：定义三个指针解决问题" class="headerlink" title="思路：定义三个指针解决问题"></a>思路：定义三个指针解决问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* prePointer = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curPointer = head;</span><br><span class="line">        ListNode* nxtPointer = head -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(curPointer != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            curPointer -&gt; next = prePointer;</span><br><span class="line">            prePointer = curPointer;</span><br><span class="line">            curPointer = nxtPointer;</span><br><span class="line">            <span class="comment">// 空的指针没有next!!!</span></span><br><span class="line">            <span class="keyword">if</span>(nxtPointer != <span class="literal">nullptr</span>)</span><br><span class="line">                nxtPointer = nxtPointer -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回的是pre******</span></span><br><span class="line">        <span class="keyword">return</span> prePointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样少判断一下</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* prePointer = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curPointer = head;</span><br><span class="line">        ListNode* nxtPointer = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(curPointer != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nxtPointer = curPointer -&gt; next;</span><br><span class="line">            curPointer -&gt; next = prePointer;</span><br><span class="line">            prePointer = curPointer;</span><br><span class="line">            curPointer = nxtPointer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode92-反转链表2"><a href="#LeetCode92-反转链表2" class="headerlink" title="LeetCode92:反转链表2 ****"></a>LeetCode92:反转链表2 <strong>****</strong></h2><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思考要严谨，特殊的情况要想到，只有一个node,反转从1开始等等特殊情况在做题之前就要考虑好    </span></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       ListNode* cur = head;</span><br><span class="line"><span class="comment">//        while(cur != nullptr)&#123;</span></span><br><span class="line">  <span class="comment">//          cur = cur -&gt; next;</span></span><br><span class="line">  <span class="comment">//          length++;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"> <span class="comment">//       if(m &lt; 0 || n &lt; m || n &gt; length)</span></span><br><span class="line"><span class="comment">//            return nullptr;</span></span><br><span class="line">        ListNode * pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 经过分析还需要保存反转段之前的一个node,和反转开始的node</span></span><br><span class="line">        ListNode* revePreNode = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* reveBeginNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nxt = cur -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(i == m)&#123;</span><br><span class="line">                <span class="comment">// 记录反转的前一个node</span></span><br><span class="line">                revePreNode = pre;</span><br><span class="line">                <span class="comment">//记录开始反转的node</span></span><br><span class="line">                reveBeginNode = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m &amp;&amp; i &lt;=n)&#123;</span><br><span class="line">                cur -&gt; next = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">                <span class="comment">// 反转开始的下一个node，这里要判断一下 next不能为nullptr</span></span><br><span class="line">                <span class="keyword">if</span>(revePreNode != <span class="literal">nullptr</span>)</span><br><span class="line">                    revePreNode -&gt; next = cur;</span><br><span class="line">                    <span class="comment">// 反转开始的node</span></span><br><span class="line">                <span class="keyword">if</span>(reveBeginNode != <span class="literal">nullptr</span>)</span><br><span class="line">                    reveBeginNode -&gt; next = nxt;    </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            pre =cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(revePreNode != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果反转之前没有数字，反转过来的cur就是起始</span></span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer35-复杂链表的复制"><a href="#剑指Offer35-复杂链表的复制" class="headerlink" title="剑指Offer35:复杂链表的复制**"></a>剑指Offer35:复杂链表的复制**</h2><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>利用一个map，把两个链表之间的位置对应起来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node* pNode = head;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; DoubleList;</span><br><span class="line">    <span class="comment">// 将两个链表的位置对应起来，后面好整了。</span></span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(pNode -&gt; val);</span><br><span class="line">        DoubleList[pNode] = newNode;</span><br><span class="line">        pNode = pNode -&gt; next;   </span><br><span class="line">    &#125;</span><br><span class="line">    pNode = head;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        DoubleList[pNode] -&gt; next = DoubleList[pNode -&gt;next];</span><br><span class="line">        DoubleList[pNode] -&gt; random = DoubleList[pNode -&gt; random];</span><br><span class="line">        pNode = pNode -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DoubleList[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer52-两个链表的第一个公共节点"><a href="#剑指Offer52-两个链表的第一个公共节点" class="headerlink" title="剑指Offer52:两个链表的第一个公共节点"></a>剑指Offer52:两个链表的第一个公共节点</h2><p>输入两个链表，找出它们的第一个公共节点。</p>
<p>注意：</p>
<p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 先对其在挨个找就行</span></span><br><span class="line">    <span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line">    ListNode* pNodeA = headA;</span><br><span class="line">    ListNode* pNodeB = headB;</span><br><span class="line">    <span class="keyword">while</span>(pNodeA != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        lengthA++;</span><br><span class="line">        pNodeA = pNodeA -&gt; next;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pNodeB != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        lengthB++;</span><br><span class="line">        pNodeB = pNodeB -&gt; next;            </span><br><span class="line">    &#125;</span><br><span class="line">    pNodeA = headA;</span><br><span class="line">    pNodeB =  headB;</span><br><span class="line">    <span class="keyword">while</span>(lengthA != lengthB)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lengthA &gt; lengthB)&#123;</span><br><span class="line">            pNodeA = pNodeA -&gt; next;</span><br><span class="line">            lengthA--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pNodeB = pNodeB -&gt; next;</span><br><span class="line">            lengthB--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pNodeA != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 两个等号，写成一个了，重大失误</span></span><br><span class="line">        <span class="keyword">if</span>(pNodeA == pNodeB)</span><br><span class="line">            <span class="keyword">return</span> pNodeA;</span><br><span class="line">        pNodeA = pNodeA -&gt; next;</span><br><span class="line">        pNodeB = pNodeB -&gt; next;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode83删除排序链表中的重复元素"><a href="#LeetCode83删除排序链表中的重复元素" class="headerlink" title="LeetCode83删除排序链表中的重复元素"></a>LeetCode83删除排序链表中的重复元素</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pNode = head;</span><br><span class="line">    ListNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        pNext = pNode -&gt; next;</span><br><span class="line">        <span class="comment">// 删除重复元素，pNode指向不重复元素</span></span><br><span class="line">        <span class="keyword">while</span>(pNext != <span class="literal">nullptr</span> &amp;&amp; pNode-&gt;val == pNext -&gt; val)&#123;</span><br><span class="line">            ListNode* tmp = pNext;</span><br><span class="line">            pNext = pNext -&gt; next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">            pNode -&gt; next = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode = pNode -&gt; next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode86-分离链表××××××××××"><a href="#LeetCode86-分离链表××××××××××" class="headerlink" title="LeetCode86:分离链表××××××××××"></a>LeetCode86:分离链表××××××××××</h2><p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建2个左右的虚拟节点来放大于 小于等于的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* lDummyNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* rDummyNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* lTmpNode = lDummyNode;</span><br><span class="line">        ListNode* rTmpNode = rDummyNode;</span><br><span class="line">        ListNode* pNode = head;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode -&gt; val &lt; x)&#123;</span><br><span class="line">                lTmpNode -&gt; next = pNode;</span><br><span class="line">                lTmpNode = pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                rTmpNode -&gt; next = pNode;</span><br><span class="line">                rTmpNode = pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        lTmpNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        rTmpNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* resNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 至少一个里面有数据</span></span><br><span class="line">        <span class="keyword">if</span>(lDummyNode -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            resNode = lDummyNode -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resNode = rDummyNode -&gt; next;</span><br><span class="line">        <span class="keyword">if</span>(rDummyNode -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            lTmpNode -&gt; next = rDummyNode -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 别着急删除，最后在删除</span></span><br><span class="line">        <span class="keyword">delete</span> lDummyNode;</span><br><span class="line">        <span class="keyword">delete</span> rDummyNode;</span><br><span class="line">         <span class="keyword">return</span> resNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种后进先出的数据结构即LIFO。<br>通常，插入操作在栈中被称作入栈，在栈的末尾添加一个新元素。删除操作被称作出栈，删除操作也发生在栈的末尾。即对于栈来说插入和删除操作均发生在栈的同一端。<br>如下图，在LIFO数据结构中，将首先处理添加到队列中的最新元素。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出的数据结构。<br>通常，插入操作被称为入队，新元素始终被添加在队列的末尾。删除操作也被称作出队，通常出队发生在对头，即只能移除目前的第一个元素。<br>如下图，在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。</p>
<p>  包含栈头文件：</p>
<p>#include&lt; stack&gt;</p>
<p>包含队列头文件：</p>
<p>#include&lt; queue&gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用函数</span></span><br><span class="line"></span><br><span class="line">s.push(item);<span class="comment">//将item压入栈顶</span></span><br><span class="line">s.pop();<span class="comment">//删除栈顶的元素，但是不会返回</span></span><br><span class="line">s.top();<span class="comment">//返回栈顶的元素，但是不会删除</span></span><br><span class="line">s.size();<span class="comment">//返回栈中元素的个数</span></span><br><span class="line">s.empty();<span class="comment">//检查栈是否为空，如果为空返回ture，否则返回false；</span></span><br><span class="line"></span><br><span class="line">q.push(item)<span class="comment">//将item压入队列尾部</span></span><br><span class="line">q.pop();<span class="comment">//删除队尾首元素，但不返回</span></span><br><span class="line">q.front();<span class="comment">//返回队尾元素，但不删除</span></span><br><span class="line">q.back();<span class="comment">//返回队尾元素，但不删除</span></span><br><span class="line">q.size();<span class="comment">//返回队列中元素的个数</span></span><br><span class="line">q.empty();<span class="comment">//检查队列是否为空，如果为空返回ture，否则返回false</span></span><br></pre></td></tr></table></figure>

<p> 双端队列  deque</p>
<h2 id="剑指Offer09-用两个栈实现队列"><a href="#剑指Offer09-用两个栈实现队列" class="headerlink" title="剑指Offer09 用两个栈实现队列"></a>剑指Offer09 用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        p.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> popNum;</span><br><span class="line">        <span class="keyword">if</span>(!q.empty())&#123;</span><br><span class="line">            popNum = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.empty())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!p.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = p.top();</span><br><span class="line">                    q.push(tmp);</span><br><span class="line">                    p.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                    popNum = q.top();</span><br><span class="line">                    q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> popNum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        p.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> popNum;</span><br><span class="line">        <span class="keyword">if</span>(q.empty() &amp;&amp; p.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!p.empty() &amp;&amp; q.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!p.empty)&#123;</span><br><span class="line">                q.push(p.top());</span><br><span class="line">                p.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        popNum = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">return</span> popNum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer30-包含min函数的栈"><a href="#剑指Offer30-包含min函数的栈" class="headerlink" title="剑指Offer30:包含min函数的栈"></a>剑指Offer30:包含min函数的栈</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ordinaryStack.empty())&#123;</span><br><span class="line">            ordinaryStack.push(x);</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt;= minStack.top())&#123;</span><br><span class="line">            ordinaryStack.push(x);</span><br><span class="line">            minStack.push(minStack.top());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; minStack.top())&#123;</span><br><span class="line">            ordinaryStack.push(x);</span><br><span class="line">            minStack.push(x);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ordinaryStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ordinaryStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ordinaryStack;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer59-滑动串口的最大值"><a href="#剑指Offer59-滑动串口的最大值" class="headerlink" title="剑指Offer59 滑动串口的最大值* ** ** * *** *"></a>剑指Offer59 滑动串口的最大值* ** ** * *** *</h2><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<blockquote>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<p>思路：</p>
<p>将有可能成为最大值的元素存入deque，最大值存在开头</p>
<p>应当存在队列里是数组的下标，而不是数值。当一个数字的下标移除了当前的窗口，那么将这个数字弹出就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 保存最大元素的位置</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxQue;</span><br><span class="line">    <span class="keyword">int</span> length = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; k || k &lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt;k;++i)&#123;</span><br><span class="line">        <span class="comment">// 队列顶保存最大值的位置,这里是while写错了，这样判断是从后弹出</span></span><br><span class="line">        <span class="keyword">while</span>(!maxQue.empty() &amp;&amp; nums[i] &gt;= nums[maxQue.back()])</span><br><span class="line">            maxQue.pop_back();</span><br><span class="line">        <span class="comment">// 这里是pop_back</span></span><br><span class="line">        maxQue.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =k; i &lt; length; ++i)&#123;</span><br><span class="line">        res.push_back(nums[maxQue.front()]);        </span><br><span class="line">        <span class="comment">// 还是令最大值的位置在队首</span></span><br><span class="line">        <span class="keyword">while</span>(!maxQue.empty() &amp;&amp; nums[i] &gt;= nums[maxQue.back()])</span><br><span class="line">            maxQue.pop_back();</span><br><span class="line">        <span class="comment">// 如果最大值开始的位置出了滑动窗口的位置</span></span><br><span class="line">        <span class="keyword">while</span>(!maxQue.empty() &amp;&amp; (i - k + <span class="number">1</span>) &gt; maxQue.front())</span><br><span class="line">            maxQue.pop_front();</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">         maxQue.push_back(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(nums[maxQue.front()]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer59队列的最大值"><a href="#剑指Offer59队列的最大值" class="headerlink" title="剑指Offer59队列的最大值"></a>剑指Offer59队列的最大值</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    MaxQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!maxQue.empty())</span><br><span class="line">            <span class="keyword">return</span> maxQue.front();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!maxQue.empty() &amp;&amp; value &gt; maxQue.back())</span><br><span class="line">            maxQue.pop_back();</span><br><span class="line">        maxQue.push_back(value);</span><br><span class="line">        normalQue.push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">if</span>(normalQue.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        tmp = normalQue.front();        </span><br><span class="line">        <span class="keyword">if</span>(maxQue.front() == tmp)</span><br><span class="line">            maxQue.pop_front();</span><br><span class="line">        normalQue.pop_front();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; normalQue;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxQue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h1><p><strong>首先要包含头文件#include&lt; queue&gt;</strong>, 他和<code>queue</code>不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。</p>
<p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">和队列基本操作相同:</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>top 访问队头元素</span><br><span class="line"><span class="number">2.</span>empty 队列是否为空</span><br><span class="line"><span class="number">3.</span>size 返回队列内元素个数</span><br><span class="line"><span class="number">4.</span>push 插入元素到队尾 (并排序)</span><br><span class="line"><span class="number">5.</span>emplace 原地构造一个元素并插入队列</span><br><span class="line"><span class="number">6.</span>pop 弹出队头元素</span><br><span class="line"><span class="number">7.</span>swap 交换内容</span><br></pre></td></tr></table></figure>

<p>定义：priority_queue&lt;Type, Container, Functional&gt;<br>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。</p>
<p>当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列 小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列 大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer40-最小的k个数"><a href="#剑指Offer40-最小的k个数" class="headerlink" title="剑指Offer40:最小的k个数"></a>剑指Offer40:最小的k个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">     <span class="comment">//维护一个大顶堆，这个堆里最多有k个元素</span></span><br><span class="line">     <span class="comment">//接下来的数比大顶小，弹出堆顶元素插入小的元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(k);</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; minK;</span><br><span class="line">    <span class="keyword">int</span> length = arr.size();</span><br><span class="line">    <span class="comment">// 等于0也是特殊情况，别忘了</span></span><br><span class="line">    <span class="keyword">if</span>(length &lt; k || k ==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        minK.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =k; i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; minK.top())&#123;</span><br><span class="line">            minK.pop();</span><br><span class="line">            minK.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-1</span>; i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        res[i] = minK.top();</span><br><span class="line">        minK.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer41-数据流中的中位数"><a href="#剑指Offer41-数据流中的中位数" class="headerlink" title="剑指Offer41:数据流中的中位数"></a>剑指Offer41:数据流中的中位数</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接往大顶堆里插</span></span><br><span class="line">        <span class="keyword">if</span>(BigTopQue.empty() || num &lt;= BigTopQue.top())&#123;</span><br><span class="line">            BigTopQue.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            smallTopQue.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一旦不平衡调节两个堆的大小</span></span><br><span class="line">        <span class="keyword">if</span>(BigTopQue.size() == smallTopQue.size() + <span class="number">2</span>)&#123;</span><br><span class="line">            smallTopQue.push(BigTopQue.top());</span><br><span class="line">            BigTopQue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(smallTopQue.size() == BigTopQue.size() +<span class="number">1</span>)&#123;</span><br><span class="line">            BigTopQue.push(smallTopQue.top());</span><br><span class="line">            smallTopQue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = BigTopQue.size() + smallTopQue.size();</span><br><span class="line">        <span class="comment">// 这里一定要加括号，等于等于优先级高</span></span><br><span class="line">        <span class="keyword">if</span>((length &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (BigTopQue.top() + smallTopQue.top()) /<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> BigTopQue.top();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; BigTopQue;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; smallTopQue;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>先做一下以前的题</p>
<h2 id="剑指Offer34-二差树中和为某一值的路径×××××"><a href="#剑指Offer34-二差树中和为某一值的路径×××××" class="headerlink" title="剑指Offer34 二差树中和为某一值的路径×××××"></a>剑指Offer34 二差树中和为某一值的路径×××××</h2><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<h3 id="后序遍历，非递归实现。"><a href="#后序遍历，非递归实现。" class="headerlink" title="后序遍历，非递归实现。"></a>后序遍历，非递归实现。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty() || cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 根节点左边节点全部压栈</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            path.push_back(cur -&gt; val);</span><br><span class="line">            sum -= cur -&gt;val;</span><br><span class="line">            nodes.push(cur);</span><br><span class="line">            cur = cur -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = nodes.top();</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; !sum)</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        <span class="comment">//左边处理结束，看看如果没有右节点或者右节点被访问过，弹出该节点</span></span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;right || pre == cur -&gt; right)&#123;</span><br><span class="line">            sum += cur -&gt;val;</span><br><span class="line">            path.pop_back();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = <span class="literal">nullptr</span>;  <span class="comment">// 回溯，不继续访问左边的节点，看栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur -&gt; right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深度优先搜素，递归实现"><a href="#深度优先搜素，递归实现" class="headerlink" title="深度优先搜素，递归实现"></a>深度优先搜素，递归实现</h3><p>递归实现的时候栈里自动保存出现过的值，不用操作了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    pathSum(root,res,path,sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.push_back(root -&gt; val);</span><br><span class="line">    <span class="keyword">if</span>( !root-&gt;left &amp;&amp; !root -&gt; right)&#123;</span><br><span class="line">        <span class="comment">// 这里不是等于零，最后判断是不是等于剩下的值</span></span><br><span class="line">        <span class="keyword">if</span>(sum == root -&gt; val)</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="comment">// 这里一定要return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pathSum(root -&gt; left,res,path,sum - root-&gt;val);</span><br><span class="line">    pathSum(root -&gt; right,res,path,sum -root -&gt; val);</span><br><span class="line">    <span class="comment">// 该节点本身和左右都访问过了，没有找到答案直接弹出就行</span></span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer54-二叉搜索树的第k大节点"><a href="#剑指Offer54-二叉搜索树的第k大节点" class="headerlink" title="剑指Offer54:二叉搜索树的第k大节点"></a>剑指Offer54:二叉搜索树的第k大节点</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>对于二叉搜索树，中序遍历可以顺序输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 思路 按照右根左遍历，找到第k个数即可</span></span><br><span class="line">	<span class="comment">// 循环</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty() || cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                nodes.push(cur);</span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* tmp = nodes.top();</span><br><span class="line">            num+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num == k)</span><br><span class="line">                <span class="keyword">return</span> tmp -&gt; val;</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="keyword">if</span>(tmp -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                cur = tmp -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 递归实现，不太好，慢了很多，必须都遍历完</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        kthLargest(root,k,count,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root ,<span class="keyword">int</span> k,<span class="keyword">int</span>&amp; i,<span class="keyword">int</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        kthLargest(root -&gt; right,k,i,res);</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">if</span>(i == k)</span><br><span class="line">            res = root -&gt; val;</span><br><span class="line">        kthLargest(root-&gt;left,k,i,res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer32-从上到下打印二叉树"><a href="#剑指Offer32-从上到下打印二叉树" class="headerlink" title="剑指Offer32: 从上到下打印二叉树"></a>剑指Offer32: 从上到下打印二叉树</h2><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(nodes.front() -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(nodes.front() -&gt; left);</span><br><span class="line">        <span class="keyword">if</span>(nodes.front() -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(nodes.front() -&gt; right);</span><br><span class="line">        res.push_back(nodes.front() -&gt; val);</span><br><span class="line">        nodes.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。记录每一个节点的层数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelTmp;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt; nodes;</span><br><span class="line">        <span class="keyword">int</span> lastLevel = <span class="number">1</span>;</span><br><span class="line">        nodes.push(make_pair(root,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = nodes.front().first;</span><br><span class="line">            <span class="keyword">int</span> level = nodes.front().second;</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; left !=<span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(make_pair(cur-&gt;left,level+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(make_pair(cur -&gt; right, level+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(level == lastLevel)</span><br><span class="line">                levelTmp.push_back(cur -&gt; val);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(level != lastLevel)&#123;</span><br><span class="line">                res.push_back(levelTmp);</span><br><span class="line">                levelTmp.clear();</span><br><span class="line">                levelTmp.push_back(cur -&gt; val);</span><br><span class="line">            &#125;</span><br><span class="line">            lastLevel = level;</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后这句别忘了</span></span><br><span class="line">        res.push_back(levelTmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">// 看别人代码的思路，知道每层需要打印的个数就行</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sizeN = nodes.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; sizeN; ++i)&#123;</span><br><span class="line">                TreeNode* cur = nodes.front();</span><br><span class="line">                tmp.push_back(cur -&gt; val);</span><br><span class="line">                <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    nodes.push(cur -&gt; left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur  -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                    nodes.push(cur -&gt; right);</span><br><span class="line">                nodes.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="comment">// 打印第几层</span></span><br><span class="line">    <span class="keyword">int</span> level =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthLevel = nodes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(lengthLevel);</span><br><span class="line">        <span class="comment">// 奇数层，从左向右存入 偶数层相反</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; lengthLevel;++i)&#123;</span><br><span class="line">            TreeNode* cur = nodes.front();</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur -&gt; left);</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur -&gt; right);</span><br><span class="line">            <span class="keyword">if</span>((level &amp; <span class="number">0x01</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[i] = cur -&gt; val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[lengthLevel -i <span class="number">-1</span>] = cur -&gt; val;</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer07-重建二叉树-××"><a href="#剑指Offer07-重建二叉树-××" class="headerlink" title="剑指Offer07 重建二叉树 ××"></a>剑指Offer07 重建二叉树 ××</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>思路：递归思想，先创造出根节点，在中序遍历中找到左右子树的大小，再根据左右子树的大小找到前序遍历中根节点的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preLen = preorder.size();</span><br><span class="line">    <span class="keyword">int</span> inLen = inorder.size();</span><br><span class="line">    <span class="keyword">if</span>(preLen != inLen || preLen == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;    </span><br><span class="line">    <span class="keyword">return</span> buildTree(preorder,<span class="number">0</span>,preLen<span class="number">-1</span>,inorder,<span class="number">0</span>,inLen<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回当前子树的根节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="keyword">int</span> preLeft,<span class="keyword">int</span> prerRight,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创造根节点</span></span><br><span class="line">    TreeNode* pNode = <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line">    <span class="keyword">if</span>(preLeft == prerRight)</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    <span class="comment">// 记录中序遍历找到根的位置</span></span><br><span class="line">    <span class="keyword">int</span> findPos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = inLeft; i &lt;= inRight;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == pNode -&gt; val)</span><br><span class="line">            findPos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftSize = findPos - inLeft;</span><br><span class="line">    <span class="comment">// 一定要先判断是否还存在左右节点，否则将会出现越界情况</span></span><br><span class="line">    <span class="keyword">if</span>(findPos <span class="number">-1</span> &gt;= inLeft)</span><br><span class="line">        pNode -&gt; left = buildTree(preorder,preLeft+<span class="number">1</span>,preLeft+leftSize,inorder,inLeft,findPos<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(inRight &gt;= findPos +<span class="number">1</span>)</span><br><span class="line">        pNode -&gt; right = buildTree(preorder,preLeft+leftSize+<span class="number">1</span>,prerRight,inorder,findPos+<span class="number">1</span>,inRight);</span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer37-序列化二差树"><a href="#剑指Offer37-序列化二差树" class="headerlink" title="剑指Offer37 序列化二差树  **  ** **"></a>剑指Offer37 序列化二差树  **  ** **</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<blockquote>
<p>你可以将以下二叉树：</p>
<pre><code>1</code></pre><p>   / <br>  2   3<br>     / <br>    4   5</p>
<p>序列化为 “[1,2,3,null,null,4,5]”</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root,<span class="built_in">string</span> &amp; SerializeString)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            SerializeString += <span class="string">"#,"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SerializeString += to_string(root -&gt; val);</span><br><span class="line">        SerializeString += <span class="string">","</span>;</span><br><span class="line">        serialize(root -&gt; left,SerializeString);</span><br><span class="line">        serialize(root -&gt; right,SerializeString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里一定要pos前带引用，希望一直保存pos的值</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span>&amp; data,<span class="keyword">int</span>&amp; pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[pos] == <span class="string">'#'</span>)&#123;</span><br><span class="line">            pos+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原来的字符还原成整数</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> isPositive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[pos] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            isPositive = <span class="literal">false</span>;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(data[pos] != <span class="string">','</span>)&#123;</span><br><span class="line">            num = num *<span class="number">10</span> + (data[pos] - <span class="string">'0'</span>);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">        <span class="keyword">if</span>(!isPositive) num = -num;</span><br><span class="line">        TreeNode* pNode = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        pNode -&gt; left = deserialize(data,pos);</span><br><span class="line">        pNode -&gt; right = deserialize(data, pos);</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> SerializeString;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> SerializeString;</span><br><span class="line">        serialize(root,SerializeString);</span><br><span class="line">        <span class="keyword">return</span> SerializeString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = data.size();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> pos =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(data,pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer68-二叉搜索数的最近公共祖先"><a href="#剑指Offer68-二叉搜索数的最近公共祖先" class="headerlink" title="剑指Offer68 二叉搜索数的最近公共祖先"></a>剑指Offer68 二叉搜索数的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>思路：利用二差树的性质，大了往左找，小了往右找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> curVal = root -&gt; val;</span><br><span class="line">    <span class="keyword">if</span>(curVal &gt; p-&gt;val &amp;&amp; curVal &gt; q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root -&gt; left,p,q);</span><br><span class="line">    <span class="keyword">if</span>(curVal &lt; p-&gt;val &amp;&amp; curVal &lt; q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低效率方法，查找该子树是否有该节点，找到了两个，找下一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">FindNodeExit</span><span class="params">(TreeNode* root,TreeNode* find)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            TreeNode* cur = nodes.top();</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; val == find -&gt; val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 在这里就要弹出</span></span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || p == <span class="literal">nullptr</span> || q==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 这里考虑忘了</span></span><br><span class="line">        <span class="keyword">if</span>(p == root || q == root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">bool</span> leftExitP = FindNodeExit(root -&gt; left,p);</span><br><span class="line">        <span class="keyword">bool</span> leftExitQ = FindNodeExit(root -&gt; left,q);</span><br><span class="line">        <span class="keyword">if</span>(leftExitP &amp;&amp; leftExitQ)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!leftExitP &amp;&amp; !leftExitQ)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt; right,p,q);</span><br><span class="line">        <span class="keyword">else</span>        </span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法2思路，递归思想</p>
<p>题目前提说明：</p>
<ul>
<li><p>所有节点的值都是唯一的</p>
</li>
<li><p>p,q为不同节点且均在给定的二叉树中</p>
<p>解题思路：</p>
</li>
</ul>
<p>二叉树公共节点的三种情况：</p>
<p>1 p 和 q都在左子树（right == null）</p>
<p>2 p 和 q 都在右子树 （left == null）</p>
<p>3 p 和 q 一个在左子树，一个在右子树，那么当前节点为最近公共祖先</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没找到返回nullptr,找到任意一个节点返回当前节点</span></span><br><span class="line">    <span class="keyword">if</span>(!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">//当前节点没找到继续向左子树右子树中寻找</span></span><br><span class="line">    TreeNode* leftNode = lowestCommonAncestor(root -&gt; left,p,q);</span><br><span class="line">    TreeNode* rightNode = lowestCommonAncestor(root -&gt; right, p,q);</span><br><span class="line">    <span class="comment">//节点在右子树边找到了两个</span></span><br><span class="line">    <span class="keyword">if</span>(leftNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    <span class="comment">// 节点在左子树找到了两个</span></span><br><span class="line">    <span class="keyword">if</span>(rightNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    <span class="comment">// 左右子树各找到一个直接返回当前节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路3：</p>
<p>利用后续遍历，找到达到当前节点的路径</p>
<p>找到两个路径的公共点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode* root,TreeNode* pNode,<span class="built_in">stack</span>&lt;TreeNode*&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 后续遍历</span></span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty() || cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                path.push(cur);</span><br><span class="line">                <span class="keyword">if</span>(cur == pNode)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 这里不要写错了，直接压入cur</span></span><br><span class="line">                nodes.push(cur);</span><br><span class="line">                cur = cur -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = nodes.top();</span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;right || pre == cur -&gt; right)&#123;</span><br><span class="line">                nodes.pop();</span><br><span class="line">                path.pop();</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; pathP;</span><br><span class="line">        findPath(root,p,pathP);</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; pathQ;</span><br><span class="line">        findPath(root,q,pathQ);</span><br><span class="line">        <span class="keyword">while</span>(pathP.size() != pathQ.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pathP.size() &gt; pathQ.size())</span><br><span class="line">                pathP.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pathQ.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pathP.top() != pathQ.top())&#123;</span><br><span class="line">            pathQ.pop();</span><br><span class="line">            pathP.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pathQ.top();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将上述循环找路径改为递归</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findPath</span><span class="params">(TreeNode* root,TreeNode* pNode,<span class="built_in">stack</span>&lt;TreeNode*&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        path.push(root);</span><br><span class="line">        <span class="keyword">if</span>(root == pNode)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(findPath(root -&gt; left,pNode,path))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(findPath(root -&gt; right,pNode,path))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        path.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指26Offer-树的子结构"><a href="#剑指26Offer-树的子结构" class="headerlink" title="剑指26Offer. 树的子结构"></a>剑指26Offer. 树的子结构</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(A == <span class="literal">nullptr</span> || B == <span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 这里要注意，只有第一个调用hasSub ,后边两个左递归使用</span></span><br><span class="line">      <span class="keyword">return</span> hasSubStructure(A,B) || isSubStructure(A -&gt; left,B) </span><br><span class="line">              || isSubStructure(A -&gt; right,B);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 一定要先判断B是否为空</span></span><br><span class="line">      <span class="keyword">if</span>(B == <span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(A == <span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(A -&gt; val!= B-&gt;val)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> hasSubStructure(A -&gt; left,B -&gt; left) &amp;&amp; </span><br><span class="line">                  hasSubStructure(A -&gt; right,B -&gt; right);</span><br><span class="line">          </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer55-1-二叉树的深度"><a href="#剑指Offer55-1-二叉树的深度" class="headerlink" title="剑指Offer55-1 二叉树的深度"></a>剑指Offer55-1 二叉树的深度</h2><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>递归思想，比较左子树和右子树哪个深度大就返回哪个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> depthleft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> depthright = <span class="number">0</span>;</span><br><span class="line">    depthleft = maxDepth(root -&gt; left) +<span class="number">1</span>;</span><br><span class="line">    depthright = maxDepth(root -&gt; right) +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (depthleft &gt; depthright? depthleft:depthright);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以用层序遍历求出深度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> nodesSize = nodes.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; nodesSize; ++i)&#123;</span><br><span class="line">            TreeNode* cur = nodes.front();</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur -&gt; left);</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur -&gt; right);</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        layer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer55-2-平衡二叉树"><a href="#剑指Offer55-2-平衡二叉树" class="headerlink" title="剑指Offer55-2 平衡二叉树"></a>剑指Offer55-2 平衡二叉树</h2><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p>思路：</p>
<p> 判断本身以及各自的子节点是否为平衡二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> depthLeft = depthTree(root -&gt; left);</span><br><span class="line">    <span class="keyword">int</span> depthRight = depthTree(root -&gt; right);</span><br><span class="line">    <span class="keyword">if</span>(depthLeft &gt; depthRight +<span class="number">1</span> || depthRight &gt; depthLeft +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root -&gt; left) &amp;&amp; isBalanced(root -&gt; right);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depthTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> depthLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> depthRight = <span class="number">0</span>;</span><br><span class="line">    depthLeft = depthTree(root -&gt; left) +<span class="number">1</span>;</span><br><span class="line">    depthRight = depthTree(root -&gt; right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> max(depthLeft,depthRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer27-二叉树的镜像"><a href="#剑指Offer27-二叉树的镜像" class="headerlink" title="剑指Offer27 二叉树的镜像"></a>剑指Offer27 二叉树的镜像</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<blockquote>
<p>例如输入：</p>
<pre><code>4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>镜像输出：</p>
<pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1</p>
</blockquote>
<p>递归思想：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建立了一个树</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* pNode = <span class="keyword">new</span> TreeNode(root -&gt; val);</span><br><span class="line">        pNode -&gt; right = mirrorTree(root -&gt; left);</span><br><span class="line">        pNode -&gt; left = mirrorTree(root -&gt; right);</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 在原有的树上修改</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* pNode = root -&gt; left;</span><br><span class="line">        root -&gt; left = mirrorTree(root -&gt; right);</span><br><span class="line">        root -&gt; right = mirrorTree(pNode);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>考虑用循环怎么做，前序遍历根左右，改为根右左</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        TreeNode* cur = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        <span class="comment">// 这里判断为只要不是两个都为null就交换</span></span><br><span class="line">        <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span> || cur -&gt; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeNode* tmp = cur -&gt; left;</span><br><span class="line">            cur -&gt; left = cur -&gt; right;</span><br><span class="line">            cur -&gt; right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(cur -&gt; right);</span><br><span class="line">        <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(cur -&gt; left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer28-对称的二差树"><a href="#剑指Offer28-对称的二差树" class="headerlink" title="剑指Offer28 对称的二差树"></a>剑指Offer28 对称的二差树</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>递归： 左根右 等于  右根左</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root,root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* pRoot1,TreeNode* pNode2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode2 == <span class="literal">nullptr</span> &amp;&amp; pRoot1 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode2 == <span class="literal">nullptr</span> || pRoot1 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode2 -&gt;val != pRoot1 -&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isSymmetric(pRoot1-&gt;left,pNode2 -&gt; right)</span><br><span class="line">    &amp;&amp; isSymmetric(pRoot1 -&gt; right ,pNode2 -&gt; left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环试一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes2;</span><br><span class="line">    TreeNode* cur1 = root; </span><br><span class="line">    TreeNode* cur2 = root;</span><br><span class="line">    <span class="comment">// cur判断条件别忘了</span></span><br><span class="line">    <span class="keyword">while</span>(!nodes1.empty() || cur1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// 右节点空了直接因该返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!cur2 || cur1-&gt;val != cur2 -&gt; val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            nodes1.push(cur1);</span><br><span class="line">            cur1 = cur1 -&gt; left;</span><br><span class="line">            nodes2.push(cur2);</span><br><span class="line">            cur2 = cur2 -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = nodes1.top();</span><br><span class="line">        nodes1.pop();</span><br><span class="line">        cur2 = nodes2.top();</span><br><span class="line">        nodes2.pop();</span><br><span class="line">        cur1 = cur1 -&gt; right;</span><br><span class="line">        cur2 = cur2 -&gt; left;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="剑指Offer-10-斐波那契数列"><a href="#剑指Offer-10-斐波那契数列" class="headerlink" title="剑指Offer 10 斐波那契数列"></a>剑指Offer 10 斐波那契数列</h2><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lastTwoNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lastNum =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">        sum = (lastTwoNum + lastNum) % <span class="number">1000000007</span>;</span><br><span class="line">        lastTwoNum = lastNum;</span><br><span class="line">        lastNum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer10-2-青蛙跳台阶"><a href="#剑指Offer10-2-青蛙跳台阶" class="headerlink" title="剑指Offer10 -2 青蛙跳台阶"></a>剑指Offer10 -2 青蛙跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n ==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lastNum = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lastTwoNum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        sum = (lastNum + lastTwoNum) % <span class="number">1000000007</span>;</span><br><span class="line">        lastTwoNum = lastNum;</span><br><span class="line">        lastNum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer16-数值的整数次方"><a href="#剑指Offer16-数值的整数次方" class="headerlink" title="剑指Offer16 数值的整数次方"></a>剑指Offer16 数值的整数次方</h2><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。循环和递归写法如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(equal(x,<span class="number">0.0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 这里要改为long否则n为最小值的时候会超出int表示范围</span></span><br><span class="line">    <span class="keyword">long</span> circleTimes = n;        </span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        circleTimes = -circleTimes;</span><br><span class="line">        flag =<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> xSum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(circleTimes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(circleTimes %<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            xSum *= x;            </span><br><span class="line">        x = x* x;</span><br><span class="line">        circleTimes = circleTimes &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / xSum;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> xSum;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a - b &gt; <span class="number">-0.0000001</span>) &amp;&amp; (a - b &lt; <span class="number">0.0000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(equal(x,<span class="number">0.0</span>) &amp;&amp; n &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        g_InvalidInput = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        N = -N;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">double</span> res = myPowCore(x,N);   </span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        res = <span class="number">1.0</span> /res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPowCore</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">double</span> half = myPowCore(x,N /<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> res = half * half;</span><br><span class="line">    <span class="keyword">if</span>((N &amp; <span class="number">0x01</span>) == <span class="number">1</span>)</span><br><span class="line">        res = res * x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a - b &gt; <span class="number">-0.0000001</span>) &amp;&amp; (a - b &lt; <span class="number">0.0000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>DP没有递归，因为用数组存储前置结果，用这些结果可以进行递推。所以不用递归，但是也在递推。</p>
<h2 id="例子-给一个字符串，不带“-”可能有多少个IP"><a href="#例子-给一个字符串，不带“-”可能有多少个IP" class="headerlink" title="例子 给一个字符串，不带“.”可能有多少个IP"></a>例子 给一个字符串，不带“.”可能有多少个IP</h2><p>使用dfs思路可行，不过要进行大量重复计算</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/ip%E6%8B%86%E5%88%86.png" alt></p>
<p>给一个字符串长度为x，拆分成4个255以内的数，有多少种拆法，观察问题有两个维度</p>
<p>最难的点dp[ i ] [ j ]到底表达什么？</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/Ip%E7%94%BB%E8%A1%A8.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validate</span><span class="params">(<span class="built_in">string</span> tmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lengthS = s.size();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">5</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lengthS+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="comment">// 遍历赋值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; lengthS+<span class="number">1</span>; j++)&#123;</span><br><span class="line">			<span class="comment">//初始化一个数，为后续递推准备</span></span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j ==<span class="number">0</span>)&#123;</span><br><span class="line">				dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 最大位数</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;=<span class="number">3</span>; ++x)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j -x &gt;=<span class="number">0</span> &amp;&amp; validate(s.substr(j-x+<span class="number">1</span>,x)))&#123;</span><br><span class="line">					<span class="comment">//剩余字符串能组合多少有效值在之前记录</span></span><br><span class="line">					dp[i][j] += dp[i<span class="number">-1</span>][j-x];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">4</span>][lengthS];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validate</span><span class="params">(<span class="built_in">string</span> tmp)</span></span>&#123;</span><br><span class="line">	<span class="comment">//这里把空字符排除，否则stoi出现错误</span></span><br><span class="line">	<span class="keyword">if</span>(tmp == <span class="string">"0"</span> || tmp == <span class="string">""</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(tmp[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> stoi(tmp) &lt;=<span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer-19-正则表达式"><a href="#剑指Offer-19-正则表达式" class="headerlink" title="剑指Offer 19 正则表达式"></a>剑指Offer 19 正则表达式</h2><p>请实现一个函数用来匹配包含’. ‘和’ * ‘的正则表达式。模式中的字符’.’表示任意一个字符，而’ * ‘  表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab * a * a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<h3 id="思路1：-递归写法"><a href="#思路1：-递归写法" class="headerlink" title="思路1： 递归写法"></a>思路1： 递归写法</h3><ul>
<li>当 pattern中的字符不是‘ * ’ 的时候<ul>
<li>当str中第一个字符与pattern中第一个字符相匹配，str和pattern后移一位</li>
<li>否则直接返回false</li>
</ul>
</li>
<li>当pattern中出现的第二个字符是‘ * ’的时候<ul>
<li>如果str中的第一个字符与pattern中的第一个字符不匹配的时候，相当于*前的字符出现了0次，pattern+=2然后继续匹配。</li>
<li>如果str中第一个字符与pattern中第一个字符相匹配之后，有以下三种情况。<ul>
<li>pattern后移两位，str后移一位，相当于之前的字符不再出现。</li>
<li>pattern不动，str后移一位，相当于之前的字符重复出现</li>
<li>pattern后移两位，str不变，相当于匹配到了也不要，因为已有的字符就足够。例子 ‘aa’     ‘ a * aa’ 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size() == <span class="number">0</span> &amp;&amp; p.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isMatch(s,p,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="built_in">string</span>&amp; p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == s.size() &amp;&amp; j == p.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i != s.size() &amp;&amp; j == p.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 下一个字符是*</span></span><br><span class="line">    <span class="keyword">if</span>(j+<span class="number">1</span> &lt; p.size() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != s.size() &amp;&amp; (p[j] == s[i] || p[j] == <span class="string">'.'</span>))</span><br><span class="line">                <span class="comment">//之前的字符重复出现</span></span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p,i+<span class="number">1</span>,j) </span><br><span class="line">                <span class="comment">// 不需要匹配当前字符</span></span><br><span class="line">                || isMatch(s,p,i,j+<span class="number">2</span>)</span><br><span class="line">                <span class="comment">// 之前的字符不再出现</span></span><br><span class="line">                || isMatch(s,p,i+<span class="number">1</span>,j+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 不匹配，跳过</span></span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p,i,j+<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(i != s.size() &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'.'</span>))</span><br><span class="line">        <span class="keyword">return</span> isMatch(s,p,i+<span class="number">1</span>,j+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;            </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer42-连续子数组的最大和"><a href="#剑指Offer42-连续子数组的最大和" class="headerlink" title="剑指Offer42 连续子数组的最大和"></a>剑指Offer42 连续子数组的最大和</h2><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。空间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Len = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(Len);</span><br><span class="line">    sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; Len; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum[i<span class="number">-1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + nums[i];   </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxSum = sum[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Len; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum[i] &gt; maxSum)</span><br><span class="line">            maxSum = sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度降为O(1)</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> lastSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lastSum &gt; <span class="number">0</span>)</span><br><span class="line">                lastSum = lastSum + nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lastSum = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(lastSum &gt; maxSum)</span><br><span class="line">                maxSum = lastSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer63-股票的最大利润"><a href="#剑指Offer63-股票的最大利润" class="headerlink" title="剑指Offer63 股票的最大利润"></a>剑指Offer63 股票的最大利润</h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到最低买入点，和最高卖出点就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Len = prices.size();</span><br><span class="line">    <span class="keyword">int</span> buyPoint = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sellPoint = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> profits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(sellPoint =<span class="number">1</span>; sellPoint &lt; Len; ++sellPoint)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[sellPoint] &gt;= prices[buyPoint])&#123;</span><br><span class="line">            profits = prices[sellPoint] - prices[buyPoint];</span><br><span class="line">            <span class="keyword">if</span>(profits &gt; maxProfit)</span><br><span class="line">                maxProfit = profits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            buyPoint = sellPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer12-矩阵中的路径"><a href="#剑指Offer12-矩阵中的路径" class="headerlink" title="剑指Offer12 矩阵中的路径 **"></a>剑指Offer12 矩阵中的路径 **</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f”</strong>,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = board.size();</span><br><span class="line">    <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(cols == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; flag(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; ++row)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col =<span class="number">0</span>; col &lt; cols; ++col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word[<span class="number">0</span>] == board[row][col])&#123;</span><br><span class="line">                <span class="keyword">if</span>(findPath(board,flag,word,row,col,<span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;                              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; flag,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">string</span>&amp; word,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> wordPos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = board.size();</span><br><span class="line">    <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> wordLen = word.size();</span><br><span class="line">    <span class="keyword">if</span>(wordPos == wordLen)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line">    <span class="keyword">if</span>(col &lt; <span class="number">0</span> || col &gt;= cols || row &lt; <span class="number">0</span> || row &gt;= rows || board[row][col] != word[wordPos])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag[row][col])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    flag[row][col] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> res = findPath(board,flag,word,row <span class="number">-1</span>,col,wordPos+<span class="number">1</span>) ||</span><br><span class="line">        findPath(board,flag,word,row+<span class="number">1</span>,col,wordPos+<span class="number">1</span>) ||</span><br><span class="line">        findPath(board,flag,word,row,col <span class="number">-1</span>,wordPos+<span class="number">1</span>) ||</span><br><span class="line">        findPath(board,flag,word,row,col+<span class="number">1</span>,wordPos+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 查找失败，将标志位置为false</span></span><br><span class="line">    flag[row][col] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题14-I-剪绳子"><a href="#面试题14-I-剪绳子" class="headerlink" title="面试题14- I. 剪绳子"></a>面试题14- I. 剪绳子</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>动态规划</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里要预留出来一位</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">4</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    res[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    res[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            tmp = res[j] * res[i-j];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; max)</span><br><span class="line">                max =tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = max;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贪心算法,如果可以分出来3就分出来3,否则分出来2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> thereTimes = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> twoTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> remain = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(remain == <span class="number">1</span>)&#123;</span><br><span class="line">        thereTimes--;</span><br><span class="line">        twoTimes+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">2</span>)</span><br><span class="line">        twoTimes++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>,thereTimes) * <span class="built_in">pow</span>(<span class="number">2</span>,twoTimes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题47-礼物的最大价值"><a href="#面试题47-礼物的最大价值" class="headerlink" title="面试题47. 礼物的最大价值"></a>面试题47. 礼物的最大价值</h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = grid.size();</span><br><span class="line">    <span class="keyword">if</span>(rows ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(cols ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; maxSum(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols,<span class="number">0</span>));</span><br><span class="line">    maxSum[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col =<span class="number">1</span>; col &lt; cols; col++)&#123;</span><br><span class="line">        maxSum[<span class="number">0</span>][col] = maxSum[<span class="number">0</span>][col<span class="number">-1</span>] + grid[<span class="number">0</span>][col];        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row =<span class="number">1</span>; row &lt; rows; row++)&#123;</span><br><span class="line">        maxSum[row][<span class="number">0</span>] = maxSum[row<span class="number">-1</span>][<span class="number">0</span>] + grid[row][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row =<span class="number">1</span>; row &lt; rows; row++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col =<span class="number">1</span>; col &lt; cols; col++)&#123;</span><br><span class="line">            maxSum[row][col] = max(maxSum[row<span class="number">-1</span>][col],</span><br><span class="line">                                  maxSum[row][col<span class="number">-1</span>]) + grid[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="dfs和bfs"><a href="#dfs和bfs" class="headerlink" title="dfs和bfs"></a>dfs和bfs</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><h2 id="抽象树"><a href="#抽象树" class="headerlink" title="抽象树"></a>抽象树</h2><p>使用栈保存未被检测的结点，结点按照深度优先的次序被访问并依次被压入栈中，并以相反的次序出栈进行新的检测。</p>
<ul>
<li>类似与树的先序遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span><span class="comment">//参数用来表示状态  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(到达终点状态)  </span><br><span class="line">    &#123;  </span><br><span class="line">        ...<span class="comment">//根据题意添加  </span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(越界或者是不合法状态)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    <span class="keyword">if</span>(特殊状态)<span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(扩展方式)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(扩展方式所达到状态合法)  </span><br><span class="line">        &#123;  </span><br><span class="line">            修改操作;<span class="comment">//根据题意来添加  </span></span><br><span class="line">            标记；  </span><br><span class="line">            dfs（）；  </span><br><span class="line">            (还原标记)；  </span><br><span class="line">            <span class="comment">//是否还原标记根据题意  </span></span><br><span class="line">            <span class="comment">//如果加上（还原标记）就是 回溯法  </span></span><br><span class="line">        &#125;  </span><br><span class="line"> </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是从例子入手</p>
<h3 id="例题1-ABC的全排列"><a href="#例题1-ABC的全排列" class="headerlink" title="例题1 ABC的全排列"></a>例题1 ABC的全排列</h3><p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/ABC.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; inputArr,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; usedArr,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1确定截至条件</span></span><br><span class="line">	<span class="keyword">if</span>(level == inputArr.size())&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span>&amp; i : res)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2 遍历候选节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputArr.size();++i)&#123;</span><br><span class="line">		<span class="comment">//2.1筛选</span></span><br><span class="line">		<span class="keyword">if</span>(!usedArr[i])&#123;</span><br><span class="line">			usedArr[i] = <span class="literal">true</span>;</span><br><span class="line">			res.push_back(inputArr[i]);</span><br><span class="line">			dfs(inputArr,res,usedArr,level +<span class="number">1</span>);</span><br><span class="line">			<span class="comment">//2.2状态复原，不要影响到同一层次其他的元素</span></span><br><span class="line">			res.pop_back();</span><br><span class="line">			usedArr[i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; inputArr;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">while</span>((c = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line">		inputArr.push_back(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; usedArr(inputArr.size(),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	dfs(inputArr,res,usedArr,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化，不需要level，输出数组长度等于输入数组了就可以输出了，不需要used，一旦将元素插入res，就把原来的数组相应位置置为null，在回溯的时候将相应的值复制回原数组就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; inputArr,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(res.size() == inputArr.size())&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span>&amp; i:res)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; inputArr.size(); ++i)&#123;</span><br><span class="line">		<span class="keyword">char</span> c = inputArr[i];</span><br><span class="line">		<span class="keyword">if</span>(c)&#123;</span><br><span class="line">			res.push_back(c);</span><br><span class="line">			inputArr[i] = <span class="number">0</span>;</span><br><span class="line">			dfs(inputArr,res);</span><br><span class="line">			inputArr[i] = c;</span><br><span class="line">			res.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode-93复原IP地址"><a href="#Leetcode-93复原IP地址" class="headerlink" title="Leetcode:93复原IP地址"></a>Leetcode:93复原IP地址</h3><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E5%A4%8D%E5%8E%9FIP.png" alt></p>
<p>截至 条件？数字全部选完，四个坑位填满</p>
<p>筛选条件？每个数是0~255</p>
<p>候选？记录当前到哪位，只能往后选3位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreIPAdrees</span><span class="params">(<span class="built_in">string</span>&amp; oldIP,<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; legalIP,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 截至条件</span></span><br><span class="line">	<span class="keyword">if</span>(level == <span class="number">4</span> || index == oldIP.size())&#123;</span><br><span class="line">        <span class="comment">//筛选，除了以下情况其余排除</span></span><br><span class="line">		<span class="keyword">if</span>(level == <span class="number">4</span> &amp;&amp; index &gt;= oldIP.size())&#123;</span><br><span class="line">			<span class="built_in">string</span> tmp;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;legalIP.size()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">				tmp += legalIP[i];</span><br><span class="line">				tmp += <span class="string">'.'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			tmp+=legalIP[legalIP.size() <span class="number">-1</span>];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			res.push_back(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//候选人</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">		<span class="comment">// 将可能的字符截取出来</span></span><br><span class="line">		<span class="built_in">string</span> c = oldIP.substr(index,i);</span><br><span class="line">		<span class="keyword">int</span> num = stoi(c);</span><br><span class="line">		<span class="comment">// 筛选大于255不行,"01,011"特殊情况不行</span></span><br><span class="line">		<span class="keyword">if</span>(num &lt;= <span class="number">255</span> &amp;&amp; (c == <span class="string">"0"</span> || c[<span class="number">0</span>]!=<span class="string">'0'</span>))&#123;</span><br><span class="line">			legalIP.push_back(c);</span><br><span class="line">			restoreIPAdrees(oldIP,index+i,legalIP,level+<span class="number">1</span>);</span><br><span class="line">			legalIP.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// char c;</span></span><br><span class="line">	<span class="comment">// while((c = getchar()) != '\n')&#123;</span></span><br><span class="line">	<span class="comment">// 	inputArr.push_back(c);</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="built_in">string</span> input;</span><br><span class="line">	getline(<span class="built_in">cin</span>,input);</span><br><span class="line">	restoreIPAdrees(input,<span class="number">0</span>,res,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; restoreIpAddresses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(s.size() ==<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> res;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr;</span><br><span class="line">        restoreIPAdrees(s,<span class="number">0</span>,arr,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restoreIPAdrees</span><span class="params">(<span class="built_in">string</span>&amp; input,<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; arr,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 截至条件</span></span><br><span class="line">    	<span class="keyword">if</span>(level == <span class="number">4</span> || index &gt;= input.size())&#123;</span><br><span class="line">            <span class="comment">// 剪枝</span></span><br><span class="line">    		<span class="keyword">if</span>(level == <span class="number">4</span> &amp;&amp; index == input.size())&#123;</span><br><span class="line">    			<span class="built_in">string</span> tmp;</span><br><span class="line">    			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">    				tmp += arr[i];</span><br><span class="line">    				tmp += <span class="string">'.'</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    			tmp += arr[arr.size()<span class="number">-1</span>];</span><br><span class="line">    			res.push_back(tmp);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 遍历候选人</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; <span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index + i &gt; input.size())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    		<span class="built_in">string</span> s = input.substr(index,i);</span><br><span class="line">    		<span class="comment">//筛选</span></span><br><span class="line">            <span class="keyword">if</span>(stoi(s) &lt; <span class="number">256</span> &amp;&amp; (s == <span class="string">"0"</span> || s[<span class="number">0</span>] != <span class="string">'0'</span>))&#123;</span><br><span class="line">    			arr.push_back(s);</span><br><span class="line">    			restoreIPAdrees(input,index+i,arr,level+<span class="number">1</span>);</span><br><span class="line">    			arr.pop_back();</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode17-电话号码的字母组合"><a href="#LeetCode17-电话号码的字母组合" class="headerlink" title="LeetCode17:电话号码的字母组合"></a>LeetCode17:电话号码的字母组合</h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E7%94%B5%E8%AF%9D%E5%8F%B7.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//踩坑，不要用c语言的方式写了</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; m = &#123;</span><br><span class="line">        &#123;&#125;, &#123;&#125;,&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;,&#123;<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>&#125;,&#123;<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>&#125;,&#123;<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>&#125;,&#123;<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>&#125;,&#123;<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        dfs(digits,<span class="number">0</span>,tmp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; digits,<span class="keyword">int</span> index,<span class="built_in">string</span>&amp; tmp,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 截至条件</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.size() == digits.size())&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= digits.size())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//选出候选元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> &amp;a : m[digits[index] - <span class="string">'0'</span>])&#123;</span><br><span class="line">            tmp.push_back(a);</span><br><span class="line">            dfs(digits,index+<span class="number">1</span>,tmp,res);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-39-组合总和"><a href="#LeetCode-39-组合总和" class="headerlink" title="LeetCode 39 组合总和"></a>LeetCode 39 组合总和</h3><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.size() == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(candidates,tmp,target);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp,<span class="keyword">int</span> remain)</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 截止条件</span></span><br><span class="line">    	<span class="keyword">if</span>(remain &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(remain == <span class="number">0</span>)&#123;</span><br><span class="line">    			sort(tmp.begin(),tmp.end());</span><br><span class="line">    			<span class="comment">//重复的除去</span></span><br><span class="line">    			<span class="keyword">if</span>(find(res.begin(),res.end(),tmp) == res.end())</span><br><span class="line">    				res.push_back(tmp);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//候选元素遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> &amp; num: candidates)&#123;</span><br><span class="line">    		<span class="keyword">int</span> insertNum = num;</span><br><span class="line">    		tmp.push_back(insertNum);</span><br><span class="line">    		dfs(candidates,tmp,remain-num);</span><br><span class="line">    		tmp.pop_back();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//去重用了太久的时间</span></span><br><span class="line"><span class="comment">//观察树，找过的元素就不要向回找了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.size() == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(candidates,tmp,target,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp,<span class="keyword">int</span> remain,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 截止条件</span></span><br><span class="line">    	<span class="keyword">if</span>(remain &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(remain == <span class="number">0</span>)&#123;</span><br><span class="line">    			res.push_back(tmp);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//候选元素遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.size();++i)&#123;</span><br><span class="line">    		tmp.push_back(candidates[i]);</span><br><span class="line">            <span class="comment">//找过的不要向回找了，向本身和本省之后的元素找</span></span><br><span class="line">    		dfs(candidates,tmp,remain-candidates[i],i);</span><br><span class="line">    		tmp.pop_back();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode46-全排列"><a href="#LeetCode46-全排列" class="headerlink" title="LeetCode46:全排列"></a>LeetCode46:全排列</h3><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used(nums.size(),<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(nums,used,tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; used,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp)</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 截至条件</span></span><br><span class="line">    	<span class="keyword">if</span>(tmp.size() == nums.size())&#123;</span><br><span class="line">    		res.push_back(tmp);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 遍历候选节点</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size();++i)&#123;</span><br><span class="line">    		<span class="keyword">int</span> num = nums[i];</span><br><span class="line">    		<span class="comment">// 筛选</span></span><br><span class="line">    		<span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">    			tmp.push_back(num);</span><br><span class="line">    			used[i] = <span class="literal">true</span>;</span><br><span class="line">    			dfs(nums,used,tmp);</span><br><span class="line">    			tmp.pop_back();</span><br><span class="line">    			used[i] = <span class="literal">false</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode47-全排列2"><a href="#LeetCode47-全排列2" class="headerlink" title="LeetCode47 全排列2"></a>LeetCode47 全排列2</h3><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span> , <span class="keyword">int</span>&gt; mElenmentNums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        	mElenmentNums[num]++;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 将元素存入数组，p 元素，pb对应元素个数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pb;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = mElenmentNums.begin(); i != mElenmentNums.end();++i)&#123;</span><br><span class="line">        	p.push_back(i -&gt; first);</span><br><span class="line">        	pb.push_back(i -&gt; second);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nums.size(),tmp,p,pb,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> size,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pb,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(size == tmp.size())&#123;</span><br><span class="line">    		res.push_back(tmp);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 遍历候选节点</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p.size();++i)&#123;</span><br><span class="line">    		<span class="keyword">int</span> insertNum = p[i];</span><br><span class="line">            <span class="comment">//数量为0筛选不用</span></span><br><span class="line">    		<span class="keyword">if</span>(pb[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    			pb[i]--;</span><br><span class="line">    			tmp.push_back(p[i]);</span><br><span class="line">    			dfs(size,tmp,p,pb,res);</span><br><span class="line">    			pb[i]++;</span><br><span class="line">    			tmp.pop_back();</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode22-括号生成"><a href="#LeetCode22-括号生成" class="headerlink" title="LeetCode22 括号生成"></a>LeetCode22 括号生成</h3><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; element = &#123;<span class="string">'('</span>,<span class="string">')'</span>&#125;;</span><br><span class="line">        dfs(n,element,tmp,n,n,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; element,<span class="built_in">string</span> &amp; tmp,<span class="keyword">int</span> count1,<span class="keyword">int</span> count2,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 截止条件</span></span><br><span class="line">    	<span class="keyword">if</span>(tmp.size() == <span class="number">2</span>*n)&#123;</span><br><span class="line">    		res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 遍历候选节点，筛选</span></span><br><span class="line">        <span class="keyword">if</span>(count1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            tmp.push_back(<span class="string">'('</span>);</span><br><span class="line">            count1--;</span><br><span class="line">            dfs(n,element,tmp,count1,count2,res);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            count1++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 反向括号剩下的数量和正括号相等的时候不能选</span></span><br><span class="line">        <span class="keyword">if</span>(count2 &gt; <span class="number">0</span> &amp;&amp; count1 != count2)&#123;</span><br><span class="line">            tmp.push_back(<span class="string">')'</span>);</span><br><span class="line">            count2--;</span><br><span class="line">            dfs(n,element,tmp,count1,count2,res);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>题目直接告诉我用dfs的</p>
<h2 id="标准树相关"><a href="#标准树相关" class="headerlink" title="标准树相关"></a>标准树相关</h2><h3 id="LeetCode100-相同的树"><a href="#LeetCode100-相同的树" class="headerlink" title="LeetCode100:相同的树"></a>LeetCode100:相同的树</h3><p>检查两个二差树是否相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 截止条件</span></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//候选节点，筛选</span></span><br><span class="line">        <span class="keyword">return</span> p -&gt; val == q -&gt; val &amp;&amp;</span><br><span class="line">        isSameTree(p -&gt; left,q -&gt; left) &amp;&amp;</span><br><span class="line">        isSameTree(p -&gt; right,q -&gt; right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode113-路径的总和"><a href="#Leetcode113-路径的总和" class="headerlink" title="Leetcode113 路径的总和"></a>Leetcode113 路径的总和</h3><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    sum -= root -&gt;val;</span><br><span class="line">    tmp.push_back(root -&gt;val);</span><br><span class="line">    dfs(root,sum,res,tmp);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> remain, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; tmp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>)</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 候选节点就是左右子节点</span></span><br><span class="line">    <span class="comment">// 筛选</span></span><br><span class="line">    <span class="keyword">if</span>(root -&gt; left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        tmp.push_back(root-&gt; left -&gt; val);</span><br><span class="line">        dfs(root -&gt; left,remain - root -&gt;left -&gt; val,res,tmp);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        tmp.push_back(root -&gt;right -&gt;val);</span><br><span class="line">        dfs(root -&gt; right,remain - root -&gt; right-&gt; val,res,tmp);</span><br><span class="line">        tmp.pop_back();            </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode129-叶子节点数字之和"><a href="#LeetCode129-叶子节点数字之和" class="headerlink" title="LeetCode129 叶子节点数字之和"></a>LeetCode129 叶子节点数字之和</h3><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        dfs(root,res,root -&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp; res, <span class="keyword">int</span> tmp)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 截止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res += tmp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 候选节点左右，筛选</span></span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            dfs(root-&gt;left,res,tmp*<span class="number">10</span> + root -&gt; left -&gt; val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            dfs(root-&gt;right,res,tmp*<span class="number">10</span> + root -&gt;right-&gt;val);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数组相关dfs"><a href="#数组相关dfs" class="headerlink" title="数组相关dfs"></a>数组相关dfs</h2><h3 id="LeetCode200-岛屿的数量"><a href="#LeetCode200-岛屿的数量" class="headerlink" title="LeetCode200 岛屿的数量"></a>LeetCode200 岛屿的数量</h3><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<p>输入:<br>11110<br>11010<br>11000<br>00000</p>
<p>输出: 1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.size();</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(cols == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; passed(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;cols; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span> &amp;&amp; passed[i][j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    dfs(grid,passed,rows,cols,i,j);</span><br><span class="line">                    res++;                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; passed,<span class="keyword">int</span>&amp; rows,<span class="keyword">int</span>&amp; cols,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 截至条件</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= rows || j &gt;=cols || i &lt;<span class="number">0</span> || j &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;       </span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">'0'</span> || passed[i][j] == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span> &amp;&amp; passed[i][j] == <span class="literal">false</span>)&#123;</span><br><span class="line">            passed[i][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上下左右遍历</span></span><br><span class="line">        dfs(grid,passed,rows,cols,i<span class="number">-1</span>,j);</span><br><span class="line">        dfs(grid,passed,rows,cols,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,passed,rows,cols,i,j<span class="number">-1</span>);</span><br><span class="line">        dfs(grid,passed,rows,cols,i,j+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="剑指Offer矩阵中的路径（未解决）"><a href="#剑指Offer矩阵中的路径（未解决）" class="headerlink" title="剑指Offer矩阵中的路径（未解决）"></a>剑指Offer矩阵中的路径（未解决）</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题超时，未解决，可能原因，遍历完成所有的路径？</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> rows = board.size();</span><br><span class="line">    	<span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">    	<span class="keyword">if</span>(cols == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; used(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="literal">false</span>));</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)&#123;</span><br><span class="line">    			<span class="keyword">if</span>(board[i][j] == word[<span class="number">0</span>])&#123;</span><br><span class="line">    				<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    				dfs(board,word,<span class="number">0</span>,used,rows,cols,i,j,flag);</span><br><span class="line">    				<span class="keyword">if</span>(flag == <span class="literal">true</span>)</span><br><span class="line">    					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word,<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; used,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">bool</span>&amp; flag)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 截至条件</span></span><br><span class="line">    <span class="keyword">if</span>(index == word.size()<span class="number">-1</span>)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt;<span class="number">0</span> || j &gt;=cols)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(board[i][j] != word[index])</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(used[i][j] == <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	used[i][j] = <span class="literal">true</span>;</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i+<span class="number">1</span>,j,flag);</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i<span class="number">-1</span>,j,flag);</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i,j+<span class="number">1</span>,flag);</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i,j<span class="number">-1</span>,flag);</span><br><span class="line">    used[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这样写就可以，思路相似啊？？？没想懂</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> rows = board.size();</span><br><span class="line">    	<span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">    	<span class="keyword">if</span>(cols == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; used(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="literal">false</span>));</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)&#123;</span><br><span class="line">    			<span class="keyword">if</span>(board[i][j] == word[<span class="number">0</span>])&#123;</span><br><span class="line">    				<span class="keyword">if</span>(dfs(board,word,<span class="number">0</span>,used,rows,cols,i,j))</span><br><span class="line">    					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x =&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y = &#123;<span class="number">0.</span><span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word,<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; used,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 截至条件</span></span><br><span class="line">    <span class="keyword">if</span>(index == word.size())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt;<span class="number">0</span> || j &gt;=cols)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(board[i][j] != word[index])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(used[i][j] == <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	used[i][j] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">bool</span> res = dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i+<span class="number">1</span>,j) ||</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i<span class="number">-1</span>,j) ||</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i,j+<span class="number">1</span>) ||</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i,j<span class="number">-1</span>);</span><br><span class="line">    used[i][j] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/yangmiemie99.github.io/tags/剑指Offer/" rel="tag"># 剑指Offer</a>
          
            <a href="/yangmiemie99.github.io/tags/算法/" rel="tag"># 算法</a>
          
            <a href="/yangmiemie99.github.io/tags/数据结构/" rel="tag"># 数据结构</a>
          
            <a href="/yangmiemie99.github.io/tags/LeetCode/" rel="tag"># LeetCode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/yangmiemie99.github.io/2020/02/25/计算机网络/" rel="next" title="计算机网络总结">
                <i class="fa fa-chevron-left"></i> 计算机网络总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/yangmiemie99.github.io/2020/03/08/GIT使用总结/" rel="prev" title="GIT使用总结">
                GIT使用总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/yangmiemie99.github.io/images/touxiang.jpeg" alt="Yang MieMie">
            
              <p class="site-author-name" itemprop="name">Yang MieMie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/yangmiemie99.github.io/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/yangmiemie99.github.io/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/yangmiemie99.github.io/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yangmiemie99" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer题目3：找出数组中重复的数字。"><span class="nav-number">1.1.</span> <span class="nav-text">剑指Offer题目3：找出数组中重复的数字。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer题目4：二维数组中的查找"><span class="nav-number">1.2.</span> <span class="nav-text">剑指Offer题目4：二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路"><span class="nav-number">1.2.1.</span> <span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer29-顺时针打印数组"><span class="nav-number">1.3.</span> <span class="nav-text">剑指Offer29:顺时针打印数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer53-在排序数组中查找数字"><span class="nav-number">1.4.</span> <span class="nav-text">剑指Offer53:在排序数组中查找数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路："><span class="nav-number">1.4.1.</span> <span class="nav-text">思路：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer53-0-n-1中缺失的数字"><span class="nav-number">1.5.</span> <span class="nav-text">剑指Offer53:0-n-1中缺失的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路：-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">思路：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查找表"><span class="nav-number">2.</span> <span class="nav-text">查找表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#两类查找问题"><span class="nav-number">2.1.</span> <span class="nav-text">两类查找问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer50-第一个只出现一次的字符"><span class="nav-number">2.2.</span> <span class="nav-text">剑指Offer50:第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer48-最长不含重复的子字符串××××"><span class="nav-number">2.3.</span> <span class="nav-text">剑指Offer48:最长不含重复的子字符串××××</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode349-两个数组的交集"><span class="nav-number">2.4.</span> <span class="nav-text">LeetCode349:两个数组的交集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode350-两个数组的交集"><span class="nav-number">2.5.</span> <span class="nav-text">LeetCode350 两个数组的交集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map默认值"><span class="nav-number">2.6.</span> <span class="nav-text">Map默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#底层实现"><span class="nav-number">2.7.</span> <span class="nav-text">底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据顺序型的作用"><span class="nav-number">2.8.</span> <span class="nav-text">数据顺序型的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode有效的字母异位词"><span class="nav-number">2.9.</span> <span class="nav-text">LeetCode有效的字母异位词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-290单词规律（花费时间长）"><span class="nav-number">2.10.</span> <span class="nav-text">LeetCode 290单词规律（花费时间长）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路：-2"><span class="nav-number">2.10.1.</span> <span class="nav-text">思路：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表"><span class="nav-number">3.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建链表，打印链表"><span class="nav-number">3.1.</span> <span class="nav-text">创建链表，打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer18，删除链表的节点"><span class="nav-number">3.2.</span> <span class="nav-text">剑指Offer18，删除链表的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer面试题22：链表中倒数第k个节点"><span class="nav-number">3.3.</span> <span class="nav-text">剑指Offer面试题22：链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer24-反转链表"><span class="nav-number">3.4.</span> <span class="nav-text">剑指Offer24:反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路：定义三个指针解决问题"><span class="nav-number">3.4.1.</span> <span class="nav-text">思路：定义三个指针解决问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode92-反转链表2"><span class="nav-number">3.5.</span> <span class="nav-text">LeetCode92:反转链表2 ****</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer35-复杂链表的复制"><span class="nav-number">3.6.</span> <span class="nav-text">剑指Offer35:复杂链表的复制**</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路：-3"><span class="nav-number">3.6.1.</span> <span class="nav-text">思路：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer52-两个链表的第一个公共节点"><span class="nav-number">3.7.</span> <span class="nav-text">剑指Offer52:两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode83删除排序链表中的重复元素"><span class="nav-number">3.8.</span> <span class="nav-text">LeetCode83删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode86-分离链表××××××××××"><span class="nav-number">3.9.</span> <span class="nav-text">LeetCode86:分离链表××××××××××</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#栈和队列"><span class="nav-number">4.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈"><span class="nav-number">4.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列"><span class="nav-number">4.2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer09-用两个栈实现队列"><span class="nav-number">4.3.</span> <span class="nav-text">剑指Offer09 用两个栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer30-包含min函数的栈"><span class="nav-number">4.4.</span> <span class="nav-text">剑指Offer30:包含min函数的栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer59-滑动串口的最大值"><span class="nav-number">4.5.</span> <span class="nav-text">剑指Offer59 滑动串口的最大值* ** ** * *** *</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer59队列的最大值"><span class="nav-number">4.6.</span> <span class="nav-text">剑指Offer59队列的最大值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#优先队列（堆）"><span class="nav-number">5.</span> <span class="nav-text">优先队列（堆）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer40-最小的k个数"><span class="nav-number">5.1.</span> <span class="nav-text">剑指Offer40:最小的k个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer41-数据流中的中位数"><span class="nav-number">5.2.</span> <span class="nav-text">剑指Offer41:数据流中的中位数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树"><span class="nav-number">6.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer34-二差树中和为某一值的路径×××××"><span class="nav-number">6.1.</span> <span class="nav-text">剑指Offer34 二差树中和为某一值的路径×××××</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#后序遍历，非递归实现。"><span class="nav-number">6.1.1.</span> <span class="nav-text">后序遍历，非递归实现。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深度优先搜素，递归实现"><span class="nav-number">6.1.2.</span> <span class="nav-text">深度优先搜素，递归实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer54-二叉搜索树的第k大节点"><span class="nav-number">6.2.</span> <span class="nav-text">剑指Offer54:二叉搜索树的第k大节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中序遍历"><span class="nav-number">6.2.1.</span> <span class="nav-text">中序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer32-从上到下打印二叉树"><span class="nav-number">6.3.</span> <span class="nav-text">剑指Offer32: 从上到下打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#层序遍历"><span class="nav-number">6.3.1.</span> <span class="nav-text">层序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer07-重建二叉树-××"><span class="nav-number">6.4.</span> <span class="nav-text">剑指Offer07 重建二叉树 ××</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer37-序列化二差树"><span class="nav-number">6.5.</span> <span class="nav-text">剑指Offer37 序列化二差树  **  ** **</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer68-二叉搜索数的最近公共祖先"><span class="nav-number">6.6.</span> <span class="nav-text">剑指Offer68 二叉搜索数的最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指26Offer-树的子结构"><span class="nav-number">6.7.</span> <span class="nav-text">剑指26Offer. 树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer55-1-二叉树的深度"><span class="nav-number">6.8.</span> <span class="nav-text">剑指Offer55-1 二叉树的深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer55-2-平衡二叉树"><span class="nav-number">6.9.</span> <span class="nav-text">剑指Offer55-2 平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer27-二叉树的镜像"><span class="nav-number">6.10.</span> <span class="nav-text">剑指Offer27 二叉树的镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer28-对称的二差树"><span class="nav-number">6.11.</span> <span class="nav-text">剑指Offer28 对称的二差树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#递归"><span class="nav-number">7.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer-10-斐波那契数列"><span class="nav-number">7.1.</span> <span class="nav-text">剑指Offer 10 斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer10-2-青蛙跳台阶"><span class="nav-number">7.2.</span> <span class="nav-text">剑指Offer10 -2 青蛙跳台阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer16-数值的整数次方"><span class="nav-number">7.3.</span> <span class="nav-text">剑指Offer16 数值的整数次方</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态规划"><span class="nav-number">8.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#例子-给一个字符串，不带“-”可能有多少个IP"><span class="nav-number">8.1.</span> <span class="nav-text">例子 给一个字符串，不带“.”可能有多少个IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer-19-正则表达式"><span class="nav-number">8.2.</span> <span class="nav-text">剑指Offer 19 正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路1：-递归写法"><span class="nav-number">8.2.1.</span> <span class="nav-text">思路1： 递归写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer42-连续子数组的最大和"><span class="nav-number">8.3.</span> <span class="nav-text">剑指Offer42 连续子数组的最大和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer63-股票的最大利润"><span class="nav-number">8.4.</span> <span class="nav-text">剑指Offer63 股票的最大利润</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer12-矩阵中的路径"><span class="nav-number">8.5.</span> <span class="nav-text">剑指Offer12 矩阵中的路径 **</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题14-I-剪绳子"><span class="nav-number">8.6.</span> <span class="nav-text">面试题14- I. 剪绳子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题47-礼物的最大价值"><span class="nav-number">8.7.</span> <span class="nav-text">面试题47. 礼物的最大价值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dfs和bfs"><span class="nav-number">9.</span> <span class="nav-text">dfs和bfs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dfs"><span class="nav-number">9.1.</span> <span class="nav-text">dfs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象树"><span class="nav-number">9.2.</span> <span class="nav-text">抽象树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例题1-ABC的全排列"><span class="nav-number">9.2.1.</span> <span class="nav-text">例题1 ABC的全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-93复原IP地址"><span class="nav-number">9.2.2.</span> <span class="nav-text">Leetcode:93复原IP地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode17-电话号码的字母组合"><span class="nav-number">9.2.3.</span> <span class="nav-text">LeetCode17:电话号码的字母组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode-39-组合总和"><span class="nav-number">9.2.4.</span> <span class="nav-text">LeetCode 39 组合总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode46-全排列"><span class="nav-number">9.2.5.</span> <span class="nav-text">LeetCode46:全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode47-全排列2"><span class="nav-number">9.2.6.</span> <span class="nav-text">LeetCode47 全排列2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode22-括号生成"><span class="nav-number">9.2.7.</span> <span class="nav-text">LeetCode22 括号生成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准树相关"><span class="nav-number">9.3.</span> <span class="nav-text">标准树相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode100-相同的树"><span class="nav-number">9.3.1.</span> <span class="nav-text">LeetCode100:相同的树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode113-路径的总和"><span class="nav-number">9.3.2.</span> <span class="nav-text">Leetcode113 路径的总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode129-叶子节点数字之和"><span class="nav-number">9.3.3.</span> <span class="nav-text">LeetCode129 叶子节点数字之和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组相关dfs"><span class="nav-number">9.4.</span> <span class="nav-text">数组相关dfs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode200-岛屿的数量"><span class="nav-number">9.4.1.</span> <span class="nav-text">LeetCode200 岛屿的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指Offer矩阵中的路径（未解决）"><span class="nav-number">9.4.2.</span> <span class="nav-text">剑指Offer矩阵中的路径（未解决）</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yang MieMie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/yangmiemie99.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
