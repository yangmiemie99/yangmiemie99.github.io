<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/yangmiemie99.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/yangmiemie99.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/yangmiemie99.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/yangmiemie99.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/yangmiemie99.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/yangmiemie99.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/yangmiemie99.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="剑指Offer,算法,数据结构,LeetCode,">










<meta name="description" content="数组剑指Offer题目3：找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 1234567891011121314// 利用哈希表思想，作出    int findRepeatNumber(vector&amp;lt;int&amp;gt;&amp;amp; nu">
<meta name="keywords" content="剑指Offer,算法,数据结构,LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode分类解题记录">
<meta property="og:url" content="https://yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/index.html">
<meta property="og:site_name" content="MieMieBlog">
<meta property="og:description" content="数组剑指Offer题目3：找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 1234567891011121314// 利用哈希表思想，作出    int findRepeatNumber(vector&amp;lt;int&amp;gt;&amp;amp; nu">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/ip%E6%8B%86%E5%88%86.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/Ip%E7%94%BB%E8%A1%A8.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E6%88%B3%E6%B0%94%E7%90%83.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E5%8A%A0%E6%9D%83%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%97%B4%E8%AE%A1%E5%88%92.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E4%B8%8D%E7%9B%B8%E9%82%BB%E6%9C%80%E5%A4%A7%E5%92%8C.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E7%9B%B8%E5%8A%A0%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0%E5%92%8C%E5%8A%A8%E6%80%81.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/ABC.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E5%A4%8D%E5%8E%9FIP.png">
<meta property="og:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E7%94%B5%E8%AF%9D%E5%8F%B7.png">
<meta property="og:updated_time" content="2020-06-19T10:21:13.034Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode分类解题记录">
<meta name="twitter:description" content="数组剑指Offer题目3：找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 1234567891011121314// 利用哈希表思想，作出    int findRepeatNumber(vector&amp;lt;int&amp;gt;&amp;amp; nu">
<meta name="twitter:image" content="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/yangmiemie99.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/">





  <title>LeetCode分类解题记录 | MieMieBlog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/yangmiemie99.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MieMieBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/yangmiemie99.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/yangmiemie99.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/yangmiemie99.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/yangmiemie99.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/yangmiemie99.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangmiemie99.github.io/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yang MieMie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/yangmiemie99.github.io/images/touxiang.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MieMieBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode分类解题记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T16:50:23+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yangmiemie99.github.io/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="剑指Offer题目3：找出数组中重复的数字。"><a href="#剑指Offer题目3：找出数组中重复的数字。" class="headerlink" title="剑指Offer题目3：找出数组中重复的数字。"></a>剑指Offer题目3：找出数组中重复的数字。</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用哈希表思想，作出</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hashVec(length,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; length;++i)&#123;</span><br><span class="line">            hashVec[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashVec[i] &gt;=<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer题目4：二维数组中的查找"><a href="#剑指Offer题目4：二维数组中的查找" class="headerlink" title="剑指Offer题目4：二维数组中的查找"></a>剑指Offer题目4：二维数组中的查找</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<blockquote>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题考虑了一会儿，发现从左上角开始查询判断会出现列来回走的情况，判断只要从右上角开始查询，大了左，小了向下查询就可以。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">    <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(cols == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> col = cols<span class="number">-1</span>,row = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从右上角开始，大了向左，小了向下</span></span><br><span class="line">    <span class="keyword">while</span>(col &gt;=<span class="number">0</span> &amp;&amp; row &lt; rows)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer29-顺时针打印数组"><a href="#剑指Offer29-顺时针打印数组" class="headerlink" title="剑指Offer29:顺时针打印数组"></a>剑指Offer29:顺时针打印数组</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>思路：确定好循环次数，考虑好特殊情况就可以了，犯的错误为确定循环次数的时候。注意细节</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">    <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(cols == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 这里应该是小的数确定循环次数</span></span><br><span class="line">    <span class="keyword">int</span> maxLengthOrWide = rows &lt; cols ? rows: cols;</span><br><span class="line">    <span class="keyword">if</span>(maxLengthOrWide &amp; <span class="number">0x01</span> == <span class="number">1</span>)</span><br><span class="line">        maxLengthOrWide+=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环的次数</span></span><br><span class="line">    <span class="keyword">int</span> circleTimes = (maxLengthOrWide &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; circleTimes;++i)&#123;</span><br><span class="line">        <span class="comment">// 打印第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; cols-i; ++j)&#123;</span><br><span class="line">            res.push_back(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印右边的一列，考虑只有一行的情况</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; rows - <span class="number">1</span>- i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; rows -i;++j)&#123;</span><br><span class="line">                res.push_back(matrix[j][cols-i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印最下边的一行，考虑只有一列,或者只有一行的情况</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; cols-i<span class="number">-1</span> &amp;&amp; i &lt; rows-i<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = cols-i<span class="number">-2</span>; j&gt;=i;--j)&#123;</span><br><span class="line">                res.push_back(matrix[rows-i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印最左边的一行，只有一列 或者两行之内都不打印</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; cols<span class="number">-1</span>-i &amp;&amp; i &lt; rows-i<span class="number">-2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = rows-i<span class="number">-2</span>; j &gt; i; --j)&#123;</span><br><span class="line">                res.push_back(matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer53-在排序数组中查找数字"><a href="#剑指Offer53-在排序数组中查找数字" class="headerlink" title="剑指Offer53:在排序数组中查找数字"></a>剑指Offer53:在排序数组中查找数字</h2><p>统计一个数字在排序数组中出现的次数。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>利用二分查找的思想，找到最左边的数字和最右边的数字。犯的错误总结：要<strong>先判断相等</strong>在判断其他的，<strong>否则当数字出现在边界的时候会出现无限循环的情况。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//二分查找思想</span></span><br><span class="line">       <span class="comment">//先找到左边相等的元素</span></span><br><span class="line">       <span class="keyword">int</span> length = nums.size();</span><br><span class="line">       <span class="keyword">if</span>(length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> right = length <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">int</span> leftTarget = <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">int</span> rightTarget = <span class="number">-1</span>;</span><br><span class="line">       <span class="comment">//等于号一定要有</span></span><br><span class="line">       <span class="keyword">while</span>(right &gt;= left)&#123;</span><br><span class="line">           <span class="keyword">int</span> middle = (left + right) &gt;&gt;<span class="number">1</span>;                </span><br><span class="line">           <span class="keyword">if</span>(nums[middle] == target)&#123;</span><br><span class="line">               <span class="keyword">if</span>(middle == <span class="number">0</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   leftTarget = <span class="number">0</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle <span class="number">-1</span>] &lt; target)</span><br><span class="line">               &#123;</span><br><span class="line">                   leftTarget = middle;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;            </span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(nums[middle] &gt;= target)</span><br><span class="line">               <span class="comment">//记得要加减1否则会跳不出循环</span></span><br><span class="line">               right = middle <span class="number">-1</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)</span><br><span class="line">               left = middle + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       left = <span class="number">0</span>;</span><br><span class="line">       right = length <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">while</span>(right &gt;= left)&#123;</span><br><span class="line">       <span class="keyword">int</span> middle = (left + right) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>(nums[middle] == target)&#123;</span><br><span class="line">           <span class="keyword">if</span>(middle == length <span class="number">-1</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               rightTarget = length<span class="number">-1</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle +<span class="number">1</span>] &gt; target)</span><br><span class="line">           &#123;</span><br><span class="line">               rightTarget = middle;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(nums[middle] &gt; target)</span><br><span class="line">           right = middle <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt;= target)</span><br><span class="line">           left = middle +<span class="number">1</span>;</span><br><span class="line">       &#125;   </span><br><span class="line">       <span class="comment">// 这里是大于等于零，写错了</span></span><br><span class="line">       <span class="keyword">if</span>(leftTarget &gt;=<span class="number">0</span> &amp;&amp; rightTarget&gt;=<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> (rightTarget - leftTarget +<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer53-0-n-1中缺失的数字"><a href="#剑指Offer53-0-n-1中缺失的数字" class="headerlink" title="剑指Offer53:0-n-1中缺失的数字"></a>剑指Offer53:0-n-1中缺失的数字</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>要考虑好特殊情况，缺失的数字出现在边界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> length = nums.size();</span><br><span class="line">     <span class="keyword">if</span>(length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     <span class="comment">// 依然利用二分查找思想</span></span><br><span class="line">     <span class="keyword">int</span> left =<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> right  = length <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">int</span> mid;</span><br><span class="line">     <span class="keyword">while</span>(right &gt;= left)&#123;</span><br><span class="line">         mid = (left+right) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(nums[mid] == mid)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(mid == length <span class="number">-1</span>)</span><br><span class="line">                 <span class="keyword">return</span> mid +<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid +<span class="number">1</span>] &gt; mid +<span class="number">1</span>)</span><br><span class="line">                 <span class="keyword">return</span> mid +<span class="number">1</span>;</span><br><span class="line">             left = mid +<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(nums[mid] &gt; mid)&#123;</span><br><span class="line">             <span class="keyword">if</span>(mid == <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">             right = mid <span class="number">-1</span>;</span><br><span class="line">         &#125;    </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer11-旋转数组的最小数字"><a href="#剑指Offer11-旋转数组的最小数字" class="headerlink" title="剑指Offer11. 旋转数组的最小数字"></a>剑指Offer11. 旋转数组的最小数字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接暴力搜索    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = numbers.size();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; numbers.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i<span class="number">-1</span>] &gt; numbers[i])</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用二分查找</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = numbers.size();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = length<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//特殊情况，没有旋转</span></span><br><span class="line">        <span class="keyword">if</span>(numbers[left] &lt; numbers[right])</span><br><span class="line">            <span class="keyword">return</span> numbers[left];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 这种情况右侧就为最小值</span></span><br><span class="line">            <span class="keyword">if</span>(left + <span class="number">1</span> == right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        	<span class="keyword">int</span> middle = (left + right) /<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//三个数字都想等，并不不能判断哪个最小，改为顺序查询</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[left] == numbers[middle] &amp;&amp; numbers[middle] == numbers[right])</span><br><span class="line">                <span class="keyword">return</span> minInorder(numbers,left,right);</span><br><span class="line">            <span class="comment">// 中间大于左边证明在左边排序好的连续数字内</span></span><br><span class="line">        	<span class="keyword">if</span>(numbers[middle] &gt;= numbers[left])</span><br><span class="line">        		left = middle;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        		right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[right];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minInorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minNum = a[left];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;=right ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; minNum)</span><br><span class="line">                minNum = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer21-调整数组顺序使奇数位于偶数前"><a href="#剑指Offer21-调整数组顺序使奇数位于偶数前" class="headerlink" title="剑指Offer21. 调整数组顺序使奇数位于偶数前"></a>剑指Offer21. 调整数组顺序使奇数位于偶数前</h2><p>难度简单15</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; exchange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> nums;</span><br><span class="line">    	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> j = nums.size()<span class="number">-1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    		<span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[i] % <span class="number">2</span> == <span class="number">1</span>))&#123;</span><br><span class="line">    			i++;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[j] % <span class="number">2</span> == <span class="number">0</span>))&#123;</span><br><span class="line">    			j--;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">    		    <span class="built_in">std</span>::swap(nums[i],nums[j]);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer-39-数组中出现次数超过一半的数字"><a href="#剑指Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指Offer 39. 数组中出现次数超过一半的数字"></a>剑指Offer 39. 数组中出现次数超过一半的数字</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接排序返回中间元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> middle = nums.size() /<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">return</span> nums[middle];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 打擂台</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打擂台</span></span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">int</span> winnerNum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> winnerSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(winnerSize == <span class="number">0</span>)&#123;</span><br><span class="line">                winnerNum = nums[i];</span><br><span class="line">                winnerSize++;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] != winnerNum)&#123;</span><br><span class="line">                winnerSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                winnerSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> winnerNum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题51-数组中逆序对"><a href="#面试题51-数组中逆序对" class="headerlink" title="面试题51 数组中逆序对"></a>面试题51 数组中逆序对</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nLen = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(nLen == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nLen<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> reverNum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpVec(nums.size(),<span class="number">0</span>);</span><br><span class="line">        mergeSort(nums,tmpVec,left,right,reverNum);    	</span><br><span class="line">        <span class="keyword">return</span> reverNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> &amp; reverNum)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">int</span> middle = (left + right) /<span class="number">2</span>;</span><br><span class="line">    	mergeSort(a,tmp,left,middle,reverNum);</span><br><span class="line">    	mergeSort(a,tmp,middle+<span class="number">1</span>,right,reverNum);</span><br><span class="line">    	<span class="keyword">int</span> leftPos = left;</span><br><span class="line">    	<span class="keyword">int</span> tmpPos = left;</span><br><span class="line">    	<span class="keyword">int</span> leftEnd = middle;</span><br><span class="line">    	<span class="keyword">int</span> rightPos = middle+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> rightEnd = right;</span><br><span class="line">    	<span class="keyword">int</span> tmpLen = right - left +<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(a[leftPos] &lt;= a[rightPos])&#123;</span><br><span class="line">    			tmp[tmpPos++] = a[leftPos++];</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">else</span>&#123;</span><br><span class="line">    			tmp[tmpPos++] = a[rightPos++];</span><br><span class="line">    			reverNum += (leftEnd - leftPos +<span class="number">1</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">while</span>(leftPos &lt;= leftEnd)</span><br><span class="line">    		tmp[tmpPos++] = a[leftPos++];</span><br><span class="line">    	<span class="keyword">while</span>(rightPos &lt;= rightEnd)</span><br><span class="line">    		tmp[tmpPos++] = a[rightPos++];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmpLen; ++i,rightEnd--)&#123;</span><br><span class="line">    		a[rightEnd] = tmp[rightEnd];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h1><h2 id="两类查找问题"><a href="#两类查找问题" class="headerlink" title="两类查找问题"></a>两类查找问题</h2><p>查找有无</p>
<ul>
<li>元素a是否存在？ set;集合</li>
</ul>
<p>查找对应关系</p>
<ul>
<li>元素a 出现了几次？ map;字典</li>
</ul>
<p>通常语言的标准库中都内置set,map </p>
<ul>
<li>容器类</li>
<li>屏蔽实现细节</li>
</ul>
<p>常见操作：</p>
<ul>
<li>insert</li>
<li>find</li>
<li>erase</li>
<li>change(map)</li>
</ul>
<p>来看几道题熟悉一下</p>
<h2 id="剑指Offer50-第一个只出现一次的字符"><a href="#剑指Offer50-第一个只出现一次的字符" class="headerlink" title="剑指Offer50:第一个只出现一次的字符"></a>剑指Offer50:第一个只出现一次的字符</h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; charMap;</span><br><span class="line">    <span class="keyword">int</span> length = s.size();</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; length;++i)&#123;</span><br><span class="line">        charMap[s[i]] +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(charMap[s[i]] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer48-最长不含重复的子字符串××××"><a href="#剑指Offer48-最长不含重复的子字符串××××" class="headerlink" title="剑指Offer48:最长不含重复的子字符串××××"></a>剑指Offer48:最长不含重复的子字符串××××</h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>利用一个map,存入相应字符和出现的位置，max始终记录出现最长的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Slength = s.size();</span><br><span class="line">    <span class="keyword">if</span>(Slength == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; maxStrLen;</span><br><span class="line">    <span class="keyword">int</span> tmpLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 不重复子串起始位置</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; Slength; ++i)&#123;</span><br><span class="line">        <span class="comment">// 找到和之前一样的元素了</span></span><br><span class="line">        <span class="keyword">if</span>(maxStrLen.find(s[i]) != maxStrLen.end() &amp;&amp; maxStrLen[s[i]] &gt;= start)&#123;</span><br><span class="line">            <span class="comment">// 更新起始位置------------一定要考虑清楚</span></span><br><span class="line">            start = maxStrLen[s[i]] +<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新长度</span></span><br><span class="line">            tmpLen = i - maxStrLen[s[i]];</span><br><span class="line">            maxStrLen[s[i]] = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 新元素</span></span><br><span class="line">            maxStrLen[s[i]] = i;</span><br><span class="line">            tmpLen += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmpLen &gt; max)</span><br><span class="line">            max = tmpLen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode349-两个数组的交集"><a href="#LeetCode349-两个数组的交集" class="headerlink" title="LeetCode349:两个数组的交集"></a>LeetCode349:两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我直接写的，两个map解决问题,整体时间复杂度O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度O(n)</span></span><br><span class="line"><span class="comment">// 使用unordered_map解决问题时间空间复杂度都为O(n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line"> <span class="comment">//       unordered_set&lt;int&gt; nums1Set;</span></span><br><span class="line"> <span class="comment">//       unordered_set&lt;int&gt; nums2Set;        </span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums1Set;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums2Set;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(length1 ==<span class="number">0</span> || length2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; length1;++i)&#123;</span><br><span class="line">            <span class="comment">// O(nlogn)  unor</span></span><br><span class="line">            nums1Set.insert(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; length2;++i)&#123;</span><br><span class="line">            <span class="comment">// O(nlogn)</span></span><br><span class="line">            nums2Set.insert(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(nlogn)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = nums1Set.begin(); i != nums2Set.end(); ++i)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums2Set.find(*i) != nums2Set.end())&#123;</span><br><span class="line">                res.push_back(*i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums1Set(nums1.begin(),nums1.end());</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums2Set(nums2.begin(),nums2.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(length1 ==<span class="number">0</span> || length2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = nums1Set.begin(); i != nums2Set.end(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2Set.find(*i) != nums2Set.end())&#123;</span><br><span class="line">                res.push_back(*i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 再简化一下，换个思路，效率变低，还是第一个最快</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums1Set(nums1.begin(),nums1.end());</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; resSet;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; nums2.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1Set.find(nums2[i]) != nums1Set.end())&#123;</span><br><span class="line">                resSet.insert(nums2[i]);  <span class="comment">// set中没有重复元素。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(resSet.begin(),resSet.end());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode350-两个数组的交集"><a href="#LeetCode350-两个数组的交集" class="headerlink" title="LeetCode350 两个数组的交集"></a>LeetCode350 两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; nums1Map;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(length1 == <span class="number">0</span> || length2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// O(nlogn)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; length1;++i)&#123;</span><br><span class="line">            nums1Map[nums1[i]] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(nlogn)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; length2;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1Map[nums2[i]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                res.push_back(nums2[i]);</span><br><span class="line">                nums1Map[nums2[i]] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map默认值"><a href="#Map默认值" class="headerlink" title="Map默认值"></a>Map默认值</h2><p>在Map中如果打印不存在的元素，默认值为0，一旦访问查找了一个元素，那么这个元素会插入map默认值为0。所以映射值为0并不代表这个元素不再这个map中。想要真正删除元素 map.erase(). </p>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><table>
<thead>
<tr>
<th></th>
<th>普通数组实现</th>
<th>顺序数组实现</th>
<th>二分搜索树（平衡）</th>
<th>哈希表</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(logn)</td>
<td>O(1)</td>
</tr>
<tr>
<td>查找</td>
<td>O(n)</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td>O(1)</td>
</tr>
<tr>
<td>删除</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(logn)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>哈希表失去了顺序性质</p>
<p>set 和map的底层实现就是一个平衡的二分搜索树</p>
<h2 id="数据顺序型的作用"><a href="#数据顺序型的作用" class="headerlink" title="数据顺序型的作用"></a>数据顺序型的作用</h2><p>数据集中的最大值和最小值</p>
<p>某个元素的前驱和后继</p>
<p>莫个与那素的floor和ceil</p>
<p>莫个元素的排位rank</p>
<p>选择莫个排位的元素select</p>
<p>unordered_map 和unordered_set底层为哈希表的实现</p>
<h2 id="LeetCode有效的字母异位词"><a href="#LeetCode有效的字母异位词" class="headerlink" title="LeetCode有效的字母异位词"></a>LeetCode有效的字母异位词</h2><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Slength = s.size();</span><br><span class="line">        <span class="keyword">int</span> Tlength = t.size();</span><br><span class="line">        <span class="keyword">if</span>(Slength == <span class="number">0</span> || Tlength == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(Slength != Tlength)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; hashTmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; Slength; ++i)&#123;</span><br><span class="line">            hashTmp[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Tlength;++i)&#123;</span><br><span class="line">            hashTmp[t[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里写错了一下，应该是两个参数《char,int》</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator itr = hashTmp.begin(); itr != hashTmp.end(); ++itr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(itr -&gt; second != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看了一下别人的，可以用数组模拟哈希，因为只有26个字母，好很多</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthS = s.size();</span><br><span class="line">        <span class="keyword">int</span> lengthT = t.size();</span><br><span class="line">        <span class="keyword">if</span>(lengthS!=lengthT)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(lengthS == <span class="number">0</span> || lengthT ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iElement:s)&#123;</span><br><span class="line">            hash[iElement - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iElement :t)&#123;</span><br><span class="line">            hash[iElement -<span class="string">'a'</span>] --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-290单词规律（花费时间长）"><a href="#LeetCode-290单词规律（花费时间长）" class="headerlink" title="LeetCode 290单词规律（花费时间长）"></a>LeetCode 290单词规律（花费时间长）</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>利用一个map, 构建字母到单词的映射，先找字母是否在map中出现，出现过判断再次出现的单词是否与之前的映射相等。如果没出现过，还要判断映射到的单词是否与之前映射的单词相等，如果相等还是不行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthP = pattern.size();</span><br><span class="line">    <span class="keyword">int</span> lengthS = str.size();</span><br><span class="line">    <span class="keyword">if</span>(lengthS == <span class="number">0</span> &amp;&amp; lengthP == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; tempMap;</span><br><span class="line">    <span class="built_in">string</span> tmpWord;        </span><br><span class="line">    <span class="keyword">int</span> pStr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthP;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(pStr &lt; lengthS &amp;&amp; str[pStr] != <span class="string">' '</span>)&#123;</span><br><span class="line">            tmpWord += str[pStr++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把空格去掉别忘了</span></span><br><span class="line">        pStr++;</span><br><span class="line">        <span class="keyword">if</span>(tempMap.find(pattern[i]) != tempMap.end())&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempMap[pattern[i]] != tmpWord)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 这里原来没想到，不同的字母映射到相同的单词是不行的。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> itr = tempMap.begin(); itr != tempMap.end();++itr)&#123;</span><br><span class="line">                <span class="keyword">if</span>(itr -&gt; second == tmpWord)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入映射</span></span><br><span class="line">            tempMap[pattern[i]] = tmpWord;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        tmpWord.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//别忘了加1，</span></span><br><span class="line">    <span class="keyword">if</span>(pStr == lengthS+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthP = pattern.size();</span><br><span class="line">    <span class="keyword">int</span> lengthS = str.size();</span><br><span class="line">    <span class="keyword">if</span>(lengthS == <span class="number">0</span> &amp;&amp; lengthP == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; tempMap;</span><br><span class="line">    <span class="comment">// 定义出现过的字符</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; used;</span><br><span class="line">    <span class="built_in">string</span> tmpWord;        </span><br><span class="line">    <span class="keyword">int</span> pStr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthP;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(pStr &lt; lengthS &amp;&amp; str[pStr] != <span class="string">' '</span>)&#123;</span><br><span class="line">            tmpWord += str[pStr++];</span><br><span class="line">        &#125;</span><br><span class="line">        pStr++;</span><br><span class="line">        <span class="keyword">if</span>(tempMap.find(pattern[i]) != tempMap.end())&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempMap[pattern[i]] != tmpWord)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//改进思路：之前的时间复杂度为O(n^2) 判断之前出现过单词可以用另一个哈希表来实现。</span></span><br><span class="line">            <span class="keyword">if</span>(used[tmpWord] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            used[tmpWord]++;</span><br><span class="line">            tempMap[pattern[i]] = tmpWord;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        tmpWord.clear();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(pStr == lengthS+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进思路：之前的时间复杂度为O(n^2) 判断之前出现过单词可以用另一个哈希表来实现。看一下别人的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; m;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; used;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pos!=<span class="number">-1</span>)<span class="comment">//读取str中的单词</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos=str.find_first_of(<span class="string">' '</span>,i);<span class="comment">//相当于返回每个空格的索引值,如果找不到空格则-1</span></span><br><span class="line">            <span class="built_in">string</span> temp=str.substr(i,pos-i);<span class="comment">//截取单词</span></span><br><span class="line">            vs.push_back(temp);<span class="comment">//插入单词元素</span></span><br><span class="line">            i=pos+<span class="number">1</span>;<span class="comment">//相当于每个单词的首位索引值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vs.size()!=pattern.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pattern.size();i++)&#123;<span class="comment">//遍历左边数组</span></span><br><span class="line">            s = vs[i];<span class="comment">//依次赋值单词字符串</span></span><br><span class="line">            <span class="keyword">if</span>(m.count(pattern[i])==<span class="number">0</span>) <span class="comment">//如果左边(pattern)数组出现新字母时,执行</span></span><br><span class="line">                <span class="keyword">if</span>(used[s]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//因为每个新字母对应一个新单词,不能新字母对应旧字符串</span></span><br><span class="line">                                        <span class="comment">//所以出现新字母时,要保证单词也是新的,如果是已经出现过的字符串则返回false</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    m[pattern[i]] = s;  <span class="comment">//匹配键值对</span></span><br><span class="line">                    used[s]++;         <span class="comment">//相当于标记某个单词已经出现过了</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s!=m[pattern[i]]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//判断str中第i个的字符串是否与映射表中第i位所对应的字符串相等</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="创建链表，打印链表"><a href="#创建链表，打印链表" class="headerlink" title="创建链表，打印链表"></a>创建链表，打印链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ListNode* <span class="title">creatLinkedList</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(arr[<span class="number">0</span>]);</span><br><span class="line">    ListNode* curNode = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        curNode -&gt; next = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">        curNode = curNode -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    ListNode* curNode = head;</span><br><span class="line">    <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; curNode -&gt; val &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">        curNode = curNode -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteLinkedList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    ListNode* curNode = head;</span><br><span class="line">    <span class="keyword">while</span>(curNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ListNode* delNode = curNode;</span><br><span class="line">        curNode = curNode -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> curNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下之前自己做的剑指Offer上的题目，从来一遍。</p>
<h2 id="剑指Offer18，删除链表的节点"><a href="#剑指Offer18，删除链表的节点" class="headerlink" title="剑指Offer18，删除链表的节点"></a>剑指Offer18，删除链表的节点</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。<strong>注意：</strong>此题对比原题有改动</p>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p>
<p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<p>说明：</p>
<p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 简单，别定义错了这里定义的是节点指针</span></span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur -&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> cur -&gt; next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre -&gt; next = cur -&gt; next;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer面试题22：链表中倒数第k个节点"><a href="#剑指Offer面试题22：链表中倒数第k个节点" class="headerlink" title="剑指Offer面试题22：链表中倒数第k个节点"></a>剑指Offer面试题22：链表中倒数第k个节点</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* lastK = head;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//考虑不足k个</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cur = cur -&gt; next;</span><br><span class="line">        lastK = lastK -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer24-反转链表"><a href="#剑指Offer24-反转链表" class="headerlink" title="剑指Offer24:反转链表"></a>剑指Offer24:反转链表</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<h3 id="思路：定义三个指针解决问题"><a href="#思路：定义三个指针解决问题" class="headerlink" title="思路：定义三个指针解决问题"></a>思路：定义三个指针解决问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* prePointer = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curPointer = head;</span><br><span class="line">        ListNode* nxtPointer = head -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(curPointer != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            curPointer -&gt; next = prePointer;</span><br><span class="line">            prePointer = curPointer;</span><br><span class="line">            curPointer = nxtPointer;</span><br><span class="line">            <span class="comment">// 空的指针没有next!!!</span></span><br><span class="line">            <span class="keyword">if</span>(nxtPointer != <span class="literal">nullptr</span>)</span><br><span class="line">                nxtPointer = nxtPointer -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回的是pre******</span></span><br><span class="line">        <span class="keyword">return</span> prePointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样少判断一下</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* prePointer = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curPointer = head;</span><br><span class="line">        ListNode* nxtPointer = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(curPointer != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nxtPointer = curPointer -&gt; next;</span><br><span class="line">            curPointer -&gt; next = prePointer;</span><br><span class="line">            prePointer = curPointer;</span><br><span class="line">            curPointer = nxtPointer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode92-反转链表2"><a href="#LeetCode92-反转链表2" class="headerlink" title="LeetCode92:反转链表2 ****"></a>LeetCode92:反转链表2 <strong>****</strong></h2><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思考要严谨，特殊的情况要想到，只有一个node,反转从1开始等等特殊情况在做题之前就要考虑好    </span></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       ListNode* cur = head;</span><br><span class="line"><span class="comment">//        while(cur != nullptr)&#123;</span></span><br><span class="line">  <span class="comment">//          cur = cur -&gt; next;</span></span><br><span class="line">  <span class="comment">//          length++;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"> <span class="comment">//       if(m &lt; 0 || n &lt; m || n &gt; length)</span></span><br><span class="line"><span class="comment">//            return nullptr;</span></span><br><span class="line">        ListNode * pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 经过分析还需要保存反转段之前的一个node,和反转开始的node</span></span><br><span class="line">        ListNode* revePreNode = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* reveBeginNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nxt = cur -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(i == m)&#123;</span><br><span class="line">                <span class="comment">// 记录反转的前一个node</span></span><br><span class="line">                revePreNode = pre;</span><br><span class="line">                <span class="comment">//记录开始反转的node</span></span><br><span class="line">                reveBeginNode = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m &amp;&amp; i &lt;=n)&#123;</span><br><span class="line">                cur -&gt; next = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">                <span class="comment">// 反转开始的下一个node，这里要判断一下 next不能为nullptr</span></span><br><span class="line">                <span class="keyword">if</span>(revePreNode != <span class="literal">nullptr</span>)</span><br><span class="line">                    revePreNode -&gt; next = cur;</span><br><span class="line">                    <span class="comment">// 反转开始的node</span></span><br><span class="line">                <span class="keyword">if</span>(reveBeginNode != <span class="literal">nullptr</span>)</span><br><span class="line">                    reveBeginNode -&gt; next = nxt;    </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            pre =cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(revePreNode != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果反转之前没有数字，反转过来的cur就是起始</span></span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer35-复杂链表的复制"><a href="#剑指Offer35-复杂链表的复制" class="headerlink" title="剑指Offer35:复杂链表的复制**"></a>剑指Offer35:复杂链表的复制**</h2><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>利用一个map，把两个链表之间的位置对应起来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node* pNode = head;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; DoubleList;</span><br><span class="line">    <span class="comment">// 将两个链表的位置对应起来，后面好整了。</span></span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(pNode -&gt; val);</span><br><span class="line">        DoubleList[pNode] = newNode;</span><br><span class="line">        pNode = pNode -&gt; next;   </span><br><span class="line">    &#125;</span><br><span class="line">    pNode = head;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        DoubleList[pNode] -&gt; next = DoubleList[pNode -&gt;next];</span><br><span class="line">        DoubleList[pNode] -&gt; random = DoubleList[pNode -&gt; random];</span><br><span class="line">        pNode = pNode -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DoubleList[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer25-合并两个排序的链表"><a href="#剑指Offer25-合并两个排序的链表" class="headerlink" title="剑指Offer25. 合并两个排序的链表"></a>剑指Offer25. 合并两个排序的链表</h2><p>难度简单17</p>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *pNode = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 -&gt; val &lt;= l2 -&gt; val)&#123;</span><br><span class="line">                pNode -&gt; next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pNode -&gt; next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是if不要写错了</span></span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>)</span><br><span class="line">            pNode -&gt; next  = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">nullptr</span>)</span><br><span class="line">            pNode -&gt; next = l2;</span><br><span class="line">        ListNode * newHead = head -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer52-两个链表的第一个公共节点"><a href="#剑指Offer52-两个链表的第一个公共节点" class="headerlink" title="剑指Offer52:两个链表的第一个公共节点"></a>剑指Offer52:两个链表的第一个公共节点</h2><p>输入两个链表，找出它们的第一个公共节点。</p>
<p>注意：</p>
<p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 先对其在挨个找就行</span></span><br><span class="line">    <span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line">    ListNode* pNodeA = headA;</span><br><span class="line">    ListNode* pNodeB = headB;</span><br><span class="line">    <span class="keyword">while</span>(pNodeA != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        lengthA++;</span><br><span class="line">        pNodeA = pNodeA -&gt; next;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pNodeB != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        lengthB++;</span><br><span class="line">        pNodeB = pNodeB -&gt; next;            </span><br><span class="line">    &#125;</span><br><span class="line">    pNodeA = headA;</span><br><span class="line">    pNodeB =  headB;</span><br><span class="line">    <span class="keyword">while</span>(lengthA != lengthB)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lengthA &gt; lengthB)&#123;</span><br><span class="line">            pNodeA = pNodeA -&gt; next;</span><br><span class="line">            lengthA--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pNodeB = pNodeB -&gt; next;</span><br><span class="line">            lengthB--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pNodeA != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 两个等号，写成一个了，重大失误</span></span><br><span class="line">        <span class="keyword">if</span>(pNodeA == pNodeB)</span><br><span class="line">            <span class="keyword">return</span> pNodeA;</span><br><span class="line">        pNodeA = pNodeA -&gt; next;</span><br><span class="line">        pNodeB = pNodeB -&gt; next;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode83删除排序链表中的重复元素"><a href="#LeetCode83删除排序链表中的重复元素" class="headerlink" title="LeetCode83删除排序链表中的重复元素"></a>LeetCode83删除排序链表中的重复元素</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pNode = head;</span><br><span class="line">    ListNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        pNext = pNode -&gt; next;</span><br><span class="line">        <span class="comment">// 删除重复元素，pNode指向不重复元素</span></span><br><span class="line">        <span class="keyword">while</span>(pNext != <span class="literal">nullptr</span> &amp;&amp; pNode-&gt;val == pNext -&gt; val)&#123;</span><br><span class="line">            ListNode* tmp = pNext;</span><br><span class="line">            pNext = pNext -&gt; next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">            pNode -&gt; next = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode = pNode -&gt; next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode86-分离链表××××××××××"><a href="#LeetCode86-分离链表××××××××××" class="headerlink" title="LeetCode86:分离链表××××××××××"></a>LeetCode86:分离链表××××××××××</h2><p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建2个左右的虚拟节点来放大于 小于等于的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* lDummyNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* rDummyNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* lTmpNode = lDummyNode;</span><br><span class="line">        ListNode* rTmpNode = rDummyNode;</span><br><span class="line">        ListNode* pNode = head;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode -&gt; val &lt; x)&#123;</span><br><span class="line">                lTmpNode -&gt; next = pNode;</span><br><span class="line">                lTmpNode = pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                rTmpNode -&gt; next = pNode;</span><br><span class="line">                rTmpNode = pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        lTmpNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        rTmpNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* resNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 至少一个里面有数据</span></span><br><span class="line">        <span class="keyword">if</span>(lDummyNode -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            resNode = lDummyNode -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resNode = rDummyNode -&gt; next;</span><br><span class="line">        <span class="keyword">if</span>(rDummyNode -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            lTmpNode -&gt; next = rDummyNode -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 别着急删除，最后在删除</span></span><br><span class="line">        <span class="keyword">delete</span> lDummyNode;</span><br><span class="line">        <span class="keyword">delete</span> rDummyNode;</span><br><span class="line">         <span class="keyword">return</span> resNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer6从头到尾打印链表"><a href="#剑指Offer6从头到尾打印链表" class="headerlink" title="剑指Offer6从头到尾打印链表"></a>剑指Offer6从头到尾打印链表</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先反转在输出</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pNode = head;</span><br><span class="line">        <span class="keyword">while</span>(pNode  != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pNext = pNode -&gt; next;</span><br><span class="line">            pNode -&gt; next = pre;</span><br><span class="line">            pre = pNode;</span><br><span class="line">            pNode = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        pNode = pre;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res.push_back(pNode -&gt; val);</span><br><span class="line">            pNode = pNode -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//先计算个数在输出</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode* pNode =head;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            pNode = pNode -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(length,<span class="number">0</span>);</span><br><span class="line">        pNode = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length <span class="number">-1</span>; i &gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            res[i] = pNode -&gt; val;</span><br><span class="line">            pNode = pNode -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer36-二叉搜索树与双向链表"><a href="#剑指Offer36-二叉搜索树与双向链表" class="headerlink" title="剑指Offer36. 二叉搜索树与双向链表**"></a>剑指Offer36. 二叉搜索树与双向链表**</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>思路：利用中序遍历的思想，设置一个指针指向前一个节点，pre -&gt; right = now; now -&gt; left = pre;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* head = <span class="literal">nullptr</span>;</span><br><span class="line">    Node* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head -&gt; left = pre;</span><br><span class="line">        pre -&gt; right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root -&gt; left);</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head = root;</span><br><span class="line">            pre = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root -&gt; left = pre;</span><br><span class="line">            pre -&gt; right = root;</span><br><span class="line">            pre = root;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root -&gt; right);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; nodes;</span><br><span class="line">        Node* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        Node* head = <span class="literal">nullptr</span>;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty() || cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                nodes.push(cur);</span><br><span class="line">                cur = cur -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = nodes.top();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                head = cur;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur -&gt; left = pre;</span><br><span class="line">                pre -&gt; right = cur;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        pre -&gt; right = head;</span><br><span class="line">        head -&gt; left = pre;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode141-环形链表-给定一个链表，判断链表中是否有环。"><a href="#LeetCode141-环形链表-给定一个链表，判断链表中是否有环。" class="headerlink" title="LeetCode141. 环形链表]给定一个链表，判断链表中是否有环。"></a>LeetCode141. 环形链表]给定一个链表，判断链表中是否有环。</h2><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p>思路1 利用unordred_map</p>
<p>检测到之前遍历到的节点直接失败。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ListNode* pNode = head;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;ListNode*&gt; nodes;</span><br><span class="line">    <span class="keyword">while</span>(pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nodes.find(pNode) == nodes.end())&#123;</span><br><span class="line">            nodes.insert(pNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        pNode = pNode -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2利用快慢指针</p>
<p>快指针追上慢指针就说明有环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ListNode* pFast = head -&gt; next;</span><br><span class="line">    ListNode* pSlow = head;</span><br><span class="line">    <span class="keyword">while</span>(pFast &amp;&amp; pFast -&gt; next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pFast == pSlow)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        pSlow = pSlow -&gt; next;</span><br><span class="line">        pFast = pFast -&gt; next -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode142-环形链表2"><a href="#LeetCode142-环形链表2" class="headerlink" title="LeetCode142 环形链表2"></a>LeetCode142 环形链表2</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<blockquote>
<p>解题思路：</p>
<p>这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第K个节点、寻找环入口、寻找公共尾部入口等。<br>算法流程：<br>双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；</p>
<p>第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；</p>
<p>TIPS: 若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；<br>第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：</p>
<p>设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数，；设两指针分别走了 f，s 步，则有：<br>fast 走的步数是slow步数的 2 倍，即 f = 2s；（解析： fast 每轮走 2 步）<br>fast 比 slow多走了 n 个环的长度，即 f=s+nb；（ 解析： 双指针都走过 aa 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；<br>以上两式相减得：f=2nb，s=nb，即fast和slow 指针分别走了 2n，n 个 环的周长 （注意： n 是未知数，不同链表的情况不同）。<br>目前情况分析：</p>
<p>如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。<br>而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。<br>但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。<br>双指针第二次相遇：</p>
<p>slow指针 位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 1 步；<br>TIPS：此时 f = 0，s=nb ；<br>当 fast 指针走到f = a步时，slow 指针走到步s=a+nb，此时 两指针重合，并同时指向链表环入口 。<br>返回slow指针指向的节点。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//快慢指针的起始位置相同</span></span><br><span class="line">        ListNode* pFast = head;</span><br><span class="line">        ListNode* pSlow = head;</span><br><span class="line">        <span class="keyword">while</span>(pFast &amp;&amp; pFast-&gt; next)&#123;</span><br><span class="line">            pFast = pFast -&gt; next -&gt; next;</span><br><span class="line">            pSlow = pSlow -&gt; next;            </span><br><span class="line">            <span class="keyword">if</span>(pFast == pSlow)&#123;</span><br><span class="line">                <span class="comment">//重合之后，在利用双指针，等后来指针与慢指针相遇就是入口</span></span><br><span class="line">                pFast = head;</span><br><span class="line">                <span class="keyword">while</span>(pFast != pSlow)&#123;</span><br><span class="line">                    pFast = pFast -&gt; next;</span><br><span class="line">                    pSlow = pSlow -&gt; next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pFast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer62-圆圈中最后剩下的数字"><a href="#剑指Offer62-圆圈中最后剩下的数字" class="headerlink" title="剑指Offer62. 圆圈中最后剩下的数字"></a>剑指Offer62. 圆圈中最后剩下的数字</h2><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt;<span class="number">1</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n;++i)&#123;</span><br><span class="line">        	numbers.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator current = numbers.begin();</span><br><span class="line">        <span class="keyword">while</span>(numbers.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;++i)&#123;</span><br><span class="line">        		current++;</span><br><span class="line">        		<span class="keyword">if</span>(current == numbers.end())</span><br><span class="line">        			current = numbers.begin();</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="comment">// 删除了迭代器会失效所以要提前存着下一个迭代器</span></span><br><span class="line">        	<span class="keyword">auto</span> next = ++current;</span><br><span class="line">            --current;</span><br><span class="line">        	numbers.erase(current);</span><br><span class="line">        	<span class="keyword">if</span>(next == numbers.end())</span><br><span class="line">        		next = numbers.begin();</span><br><span class="line">        	current = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">接下来我们试着从数学上分析出一些规律。首先定义最初的n个数字（<span class="number">0</span>,<span class="number">1</span>,…,n<span class="number">-1</span>）中最后剩下的数字是关于n和m的方程为f(n,m)。</span><br><span class="line"></span><br><span class="line">在这n个数字中，第一个被删除的数字是(m<span class="number">-1</span>)%n，为简单起见记为k。那么删除k之后的剩下n<span class="number">-1</span>的数字为<span class="number">0</span>,<span class="number">1</span>,…,k<span class="number">-1</span>,k+<span class="number">1</span>,…,n<span class="number">-1</span>，并且下一个开始计数的数字是k+<span class="number">1</span>。相当于在剩下的序列中，k+<span class="number">1</span>排到最前面，从而形成序列k+<span class="number">1</span>,…,n<span class="number">-1</span>,<span class="number">0</span>,…k<span class="number">-1</span>。该序列最后剩下的数字也应该是关于n和m的函数。由于这个序列的规律和前面最初的序列不一样（最初的序列是从<span class="number">0</span>开始的连续序列），因此该函数不同于前面函数，记为f’(n<span class="number">-1</span>,m)。最初序列最后剩下的数字f(n,m)一定是剩下序列的最后剩下数字f’(n<span class="number">-1</span>,m)，所以f(n,m)=f’(n<span class="number">-1</span>,m)。</span><br><span class="line"></span><br><span class="line">接下来我们把剩下的的这n<span class="number">-1</span>个数字的序列k+<span class="number">1</span>,…,n<span class="number">-1</span>,<span class="number">0</span>,…k<span class="number">-1</span>作一个映射，映射的结果是形成一个从<span class="number">0</span>到n<span class="number">-2</span>的序列：</span><br><span class="line"></span><br><span class="line">k+<span class="number">1</span>    -&gt;    <span class="number">0</span></span><br><span class="line">k+<span class="number">2</span>    -&gt;    <span class="number">1</span></span><br><span class="line">…</span><br><span class="line">n<span class="number">-1</span>    -&gt;    n-k<span class="number">-2</span></span><br><span class="line"><span class="number">0</span>   -&gt;    n-k<span class="number">-1</span></span><br><span class="line">…</span><br><span class="line">k<span class="number">-1</span>   -&gt;   n<span class="number">-2</span></span><br><span class="line"></span><br><span class="line">把映射定义为p，则p(x)= (x-k<span class="number">-1</span>)%n，即如果映射前的数字是x，则映射后的数字是(x-k<span class="number">-1</span>)%n。对应的逆映射是p<span class="number">-1</span>(x)=(x+k+<span class="number">1</span>)%n。</span><br><span class="line"></span><br><span class="line">由于映射之后的序列和最初的序列有同样的形式，都是从<span class="number">0</span>开始的连续序列，因此仍然可以用函数f来表示，记为f(n<span class="number">-1</span>,m)。根据我们的映射规则，映射之前的序列最后剩下的数字f’(n<span class="number">-1</span>,m)= p<span class="number">-1</span> [f(n<span class="number">-1</span>,m)]=[f(n<span class="number">-1</span>,m)+k+<span class="number">1</span>]%n。把k=(m<span class="number">-1</span>)%n代入得到f(n,m)=f’(n<span class="number">-1</span>,m)=[f(n<span class="number">-1</span>,m)+m]%n。</span><br><span class="line"></span><br><span class="line">经过上面复杂的分析，我们终于找到一个递归的公式。要得到n个数字的序列的最后剩下的数字，只需要得到n<span class="number">-1</span>个数字的序列的最后剩下的数字，并可以依此类推。当n=<span class="number">1</span>时，也就是序列中开始只有一个数字<span class="number">0</span>，那么很显然最后剩下的数字就是<span class="number">0</span>。我们把这种关系表示为：</span><br><span class="line"></span><br><span class="line">         <span class="number">0</span>                  n=<span class="number">1</span></span><br><span class="line">f(n,m)=&#123;</span><br><span class="line">         [f(n<span class="number">-1</span>,m)+m]%n     n&gt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">尽管得到这个公式的分析过程非常复杂，但它用递归或者循环都很容易实现。最重要的是，这是一种时间复杂度为O(n)，空间复杂度为O(<span class="number">1</span>)的方法，因此无论在时间上还是空间上都优于前面的思路。 */</span><br><span class="line">    <span class="keyword">int</span> LastRemaining_Solution(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;=<span class="number">0</span> || m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt;= n;++i)&#123;</span><br><span class="line">            last = (last +m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种后进先出的数据结构即LIFO。<br>通常，插入操作在栈中被称作入栈，在栈的末尾添加一个新元素。删除操作被称作出栈，删除操作也发生在栈的末尾。即对于栈来说插入和删除操作均发生在栈的同一端。<br>如下图，在LIFO数据结构中，将首先处理添加到队列中的最新元素。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出的数据结构。<br>通常，插入操作被称为入队，新元素始终被添加在队列的末尾。删除操作也被称作出队，通常出队发生在对头，即只能移除目前的第一个元素。<br>如下图，在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。</p>
<p>  包含栈头文件：</p>
<p>#include&lt; stack&gt;</p>
<p>包含队列头文件：</p>
<p>#include&lt; queue&gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用函数</span></span><br><span class="line"></span><br><span class="line">s.push(item);<span class="comment">//将item压入栈顶</span></span><br><span class="line">s.pop();<span class="comment">//删除栈顶的元素，但是不会返回</span></span><br><span class="line">s.top();<span class="comment">//返回栈顶的元素，但是不会删除</span></span><br><span class="line">s.size();<span class="comment">//返回栈中元素的个数</span></span><br><span class="line">s.empty();<span class="comment">//检查栈是否为空，如果为空返回ture，否则返回false；</span></span><br><span class="line"></span><br><span class="line">q.push(item)<span class="comment">//将item压入队列尾部</span></span><br><span class="line">q.pop();<span class="comment">//删除队尾首元素，但不返回</span></span><br><span class="line">q.front();<span class="comment">//返回队尾元素，但不删除</span></span><br><span class="line">q.back();<span class="comment">//返回队尾元素，但不删除</span></span><br><span class="line">q.size();<span class="comment">//返回队列中元素的个数</span></span><br><span class="line">q.empty();<span class="comment">//检查队列是否为空，如果为空返回ture，否则返回false</span></span><br></pre></td></tr></table></figure>

<p> 双端队列  deque</p>
<h2 id="剑指Offer09-用两个栈实现队列"><a href="#剑指Offer09-用两个栈实现队列" class="headerlink" title="剑指Offer09 用两个栈实现队列"></a>剑指Offer09 用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        p.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> popNum;</span><br><span class="line">        <span class="keyword">if</span>(!q.empty())&#123;</span><br><span class="line">            popNum = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.empty())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!p.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = p.top();</span><br><span class="line">                    q.push(tmp);</span><br><span class="line">                    p.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                    popNum = q.top();</span><br><span class="line">                    q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> popNum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        p.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> popNum;</span><br><span class="line">        <span class="keyword">if</span>(q.empty() &amp;&amp; p.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!p.empty() &amp;&amp; q.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!p.empty)&#123;</span><br><span class="line">                q.push(p.top());</span><br><span class="line">                p.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        popNum = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">return</span> popNum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer30-包含min函数的栈"><a href="#剑指Offer30-包含min函数的栈" class="headerlink" title="剑指Offer30:包含min函数的栈"></a>剑指Offer30:包含min函数的栈</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ordinaryStack.empty())&#123;</span><br><span class="line">            ordinaryStack.push(x);</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt;= minStack.top())&#123;</span><br><span class="line">            ordinaryStack.push(x);</span><br><span class="line">            minStack.push(minStack.top());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; minStack.top())&#123;</span><br><span class="line">            ordinaryStack.push(x);</span><br><span class="line">            minStack.push(x);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ordinaryStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ordinaryStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ordinaryStack;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer59-滑动串口的最大值"><a href="#剑指Offer59-滑动串口的最大值" class="headerlink" title="剑指Offer59 滑动串口的最大值* ** ** * *** *"></a>剑指Offer59 滑动串口的最大值* ** ** * *** *</h2><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<blockquote>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<p>思路：</p>
<p>将有可能成为最大值的元素存入deque，最大值存在开头</p>
<p>应当存在队列里是数组的下标，而不是数值。当一个数字的下标移除了当前的窗口，那么将这个数字弹出就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 保存最大元素的位置</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxQue;</span><br><span class="line">    <span class="keyword">int</span> length = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; k || k &lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt;k;++i)&#123;</span><br><span class="line">        <span class="comment">// 队列顶保存最大值的位置,这里是while写错了，这样判断是从后弹出</span></span><br><span class="line">        <span class="keyword">while</span>(!maxQue.empty() &amp;&amp; nums[i] &gt;= nums[maxQue.back()])</span><br><span class="line">            maxQue.pop_back();</span><br><span class="line">        <span class="comment">// 这里是pop_back</span></span><br><span class="line">        maxQue.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =k; i &lt; length; ++i)&#123;</span><br><span class="line">        res.push_back(nums[maxQue.front()]);        </span><br><span class="line">        <span class="comment">// 还是令最大值的位置在队首</span></span><br><span class="line">        <span class="keyword">while</span>(!maxQue.empty() &amp;&amp; nums[i] &gt;= nums[maxQue.back()])</span><br><span class="line">            maxQue.pop_back();</span><br><span class="line">        <span class="comment">// 如果最大值开始的位置出了滑动窗口的位置</span></span><br><span class="line">        <span class="keyword">while</span>(!maxQue.empty() &amp;&amp; (i - k + <span class="number">1</span>) &gt; maxQue.front())</span><br><span class="line">            maxQue.pop_front();</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">         maxQue.push_back(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(nums[maxQue.front()]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer59队列的最大值"><a href="#剑指Offer59队列的最大值" class="headerlink" title="剑指Offer59队列的最大值"></a>剑指Offer59队列的最大值</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    MaxQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!maxQue.empty())</span><br><span class="line">            <span class="keyword">return</span> maxQue.front();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!maxQue.empty() &amp;&amp; value &gt; maxQue.back())</span><br><span class="line">            maxQue.pop_back();</span><br><span class="line">        maxQue.push_back(value);</span><br><span class="line">        normalQue.push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">if</span>(normalQue.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        tmp = normalQue.front();        </span><br><span class="line">        <span class="keyword">if</span>(maxQue.front() == tmp)</span><br><span class="line">            maxQue.pop_front();</span><br><span class="line">        normalQue.pop_front();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; normalQue;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxQue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer-31-栈的压入、弹出序列"><a href="#剑指Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指Offer 31. 栈的压入、弹出序列"></a>剑指Offer 31. 栈的压入、弹出序列</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">    	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(pushed.size() != popped.size())</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> pushPos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> popPos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pushPos &lt; pushed.size() &amp;&amp; popPos &lt; popped.size())&#123;</span><br><span class="line">            <span class="comment">// 压入指向的元素，栈顶元素不等于弹出序列的元素就继续持续压入            </span></span><br><span class="line">        	s.push(pushed[pushPos++]);</span><br><span class="line">            <span class="comment">// s不能等于empty,才能有top,栈顶元素等于出栈序列的元素，判断是否能持续弹出</span></span><br><span class="line">        	<span class="keyword">while</span>(popPos &lt; popped.size() &amp;&amp; !s.empty() &amp;&amp; s.top() == popped[popPos])&#123;</span><br><span class="line">        		popPos++;</span><br><span class="line">                s.pop();</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h1><p><strong>首先要包含头文件#include&lt; queue&gt;</strong>, 他和<code>queue</code>不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。</p>
<p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">和队列基本操作相同:</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>top 访问队头元素</span><br><span class="line"><span class="number">2.</span>empty 队列是否为空</span><br><span class="line"><span class="number">3.</span>size 返回队列内元素个数</span><br><span class="line"><span class="number">4.</span>push 插入元素到队尾 (并排序)</span><br><span class="line"><span class="number">5.</span>emplace 原地构造一个元素并插入队列</span><br><span class="line"><span class="number">6.</span>pop 弹出队头元素</span><br><span class="line"><span class="number">7.</span>swap 交换内容</span><br></pre></td></tr></table></figure>

<p>定义：priority_queue&lt;Type, Container, Functional&gt;<br>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。</p>
<p>当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列 小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列 大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer40-最小的k个数"><a href="#剑指Offer40-最小的k个数" class="headerlink" title="剑指Offer40:最小的k个数"></a>剑指Offer40:最小的k个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">     <span class="comment">//维护一个大顶堆，这个堆里最多有k个元素</span></span><br><span class="line">     <span class="comment">//接下来的数比大顶小，弹出堆顶元素插入小的元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(k);</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; minK;</span><br><span class="line">    <span class="keyword">int</span> length = arr.size();</span><br><span class="line">    <span class="comment">// 等于0也是特殊情况，别忘了</span></span><br><span class="line">    <span class="keyword">if</span>(length &lt; k || k ==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        minK.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =k; i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; minK.top())&#123;</span><br><span class="line">            minK.pop();</span><br><span class="line">            minK.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-1</span>; i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        res[i] = minK.top();</span><br><span class="line">        minK.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer41-数据流中的中位数"><a href="#剑指Offer41-数据流中的中位数" class="headerlink" title="剑指Offer41:数据流中的中位数"></a>剑指Offer41:数据流中的中位数</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接往大顶堆里插</span></span><br><span class="line">        <span class="keyword">if</span>(BigTopQue.empty() || num &lt;= BigTopQue.top())&#123;</span><br><span class="line">            BigTopQue.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            smallTopQue.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一旦不平衡调节两个堆的大小</span></span><br><span class="line">        <span class="keyword">if</span>(BigTopQue.size() == smallTopQue.size() + <span class="number">2</span>)&#123;</span><br><span class="line">            smallTopQue.push(BigTopQue.top());</span><br><span class="line">            BigTopQue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(smallTopQue.size() == BigTopQue.size() +<span class="number">1</span>)&#123;</span><br><span class="line">            BigTopQue.push(smallTopQue.top());</span><br><span class="line">            smallTopQue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = BigTopQue.size() + smallTopQue.size();</span><br><span class="line">        <span class="comment">// 这里一定要加括号，等于等于优先级高</span></span><br><span class="line">        <span class="keyword">if</span>((length &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (BigTopQue.top() + smallTopQue.top()) /<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> BigTopQue.top();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; BigTopQue;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; smallTopQue;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>先做一下以前的题</p>
<h2 id="剑指Offer34-二差树中和为某一值的路径×××××"><a href="#剑指Offer34-二差树中和为某一值的路径×××××" class="headerlink" title="剑指Offer34 二差树中和为某一值的路径×××××"></a>剑指Offer34 二差树中和为某一值的路径×××××</h2><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<h3 id="后序遍历，非递归实现。"><a href="#后序遍历，非递归实现。" class="headerlink" title="后序遍历，非递归实现。"></a>后序遍历，非递归实现。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty() || cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 根节点左边节点全部压栈</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            path.push_back(cur -&gt; val);</span><br><span class="line">            sum -= cur -&gt;val;</span><br><span class="line">            nodes.push(cur);</span><br><span class="line">            cur = cur -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = nodes.top();</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; !sum)</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        <span class="comment">//左边处理结束，看看如果没有右节点或者右节点被访问过，弹出该节点</span></span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;right || pre == cur -&gt; right)&#123;</span><br><span class="line">            sum += cur -&gt;val;</span><br><span class="line">            path.pop_back();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = <span class="literal">nullptr</span>;  <span class="comment">// 回溯，不继续访问左边的节点，看栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur -&gt; right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深度优先搜素，递归实现"><a href="#深度优先搜素，递归实现" class="headerlink" title="深度优先搜素，递归实现"></a>深度优先搜素，递归实现</h3><p>递归实现的时候栈里自动保存出现过的值，不用操作了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    pathSum(root,res,path,sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.push_back(root -&gt; val);</span><br><span class="line">    <span class="keyword">if</span>( !root-&gt;left &amp;&amp; !root -&gt; right)&#123;</span><br><span class="line">        <span class="comment">// 这里不是等于零，最后判断是不是等于剩下的值</span></span><br><span class="line">        <span class="keyword">if</span>(sum == root -&gt; val)</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="comment">// 这里一定要return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pathSum(root -&gt; left,res,path,sum - root-&gt;val);</span><br><span class="line">    pathSum(root -&gt; right,res,path,sum -root -&gt; val);</span><br><span class="line">    <span class="comment">// 该节点本身和左右都访问过了，没有找到答案直接弹出就行</span></span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer54-二叉搜索树的第k大节点"><a href="#剑指Offer54-二叉搜索树的第k大节点" class="headerlink" title="剑指Offer54:二叉搜索树的第k大节点"></a>剑指Offer54:二叉搜索树的第k大节点</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>对于二叉搜索树，中序遍历可以顺序输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 思路 按照右根左遍历，找到第k个数即可</span></span><br><span class="line">	<span class="comment">// 循环</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty() || cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                nodes.push(cur);</span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* tmp = nodes.top();</span><br><span class="line">            num+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num == k)</span><br><span class="line">                <span class="keyword">return</span> tmp -&gt; val;</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="keyword">if</span>(tmp -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                cur = tmp -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 递归实现，不太好，慢了很多，必须都遍历完</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        kthLargest(root,k,count,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root ,<span class="keyword">int</span> k,<span class="keyword">int</span>&amp; i,<span class="keyword">int</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        kthLargest(root -&gt; right,k,i,res);</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">if</span>(i == k)</span><br><span class="line">            res = root -&gt; val;</span><br><span class="line">        kthLargest(root-&gt;left,k,i,res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer32-从上到下打印二叉树"><a href="#剑指Offer32-从上到下打印二叉树" class="headerlink" title="剑指Offer32: 从上到下打印二叉树"></a>剑指Offer32: 从上到下打印二叉树</h2><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(nodes.front() -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(nodes.front() -&gt; left);</span><br><span class="line">        <span class="keyword">if</span>(nodes.front() -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(nodes.front() -&gt; right);</span><br><span class="line">        res.push_back(nodes.front() -&gt; val);</span><br><span class="line">        nodes.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。记录每一个节点的层数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelTmp;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt; nodes;</span><br><span class="line">        <span class="keyword">int</span> lastLevel = <span class="number">1</span>;</span><br><span class="line">        nodes.push(make_pair(root,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = nodes.front().first;</span><br><span class="line">            <span class="keyword">int</span> level = nodes.front().second;</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; left !=<span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(make_pair(cur-&gt;left,level+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(make_pair(cur -&gt; right, level+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(level == lastLevel)</span><br><span class="line">                levelTmp.push_back(cur -&gt; val);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(level != lastLevel)&#123;</span><br><span class="line">                res.push_back(levelTmp);</span><br><span class="line">                levelTmp.clear();</span><br><span class="line">                levelTmp.push_back(cur -&gt; val);</span><br><span class="line">            &#125;</span><br><span class="line">            lastLevel = level;</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后这句别忘了</span></span><br><span class="line">        res.push_back(levelTmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">// 看别人代码的思路，知道每层需要打印的个数就行</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sizeN = nodes.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; sizeN; ++i)&#123;</span><br><span class="line">                TreeNode* cur = nodes.front();</span><br><span class="line">                tmp.push_back(cur -&gt; val);</span><br><span class="line">                <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    nodes.push(cur -&gt; left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur  -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                    nodes.push(cur -&gt; right);</span><br><span class="line">                nodes.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="comment">// 打印第几层</span></span><br><span class="line">    <span class="keyword">int</span> level =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthLevel = nodes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(lengthLevel);</span><br><span class="line">        <span class="comment">// 奇数层，从左向右存入 偶数层相反</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; lengthLevel;++i)&#123;</span><br><span class="line">            TreeNode* cur = nodes.front();</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur -&gt; left);</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur -&gt; right);</span><br><span class="line">            <span class="keyword">if</span>((level &amp; <span class="number">0x01</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[i] = cur -&gt; val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[lengthLevel -i <span class="number">-1</span>] = cur -&gt; val;</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer07-重建二叉树-××"><a href="#剑指Offer07-重建二叉树-××" class="headerlink" title="剑指Offer07 重建二叉树 ××"></a>剑指Offer07 重建二叉树 ××</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>思路：递归思想，先创造出根节点，在中序遍历中找到左右子树的大小，再根据左右子树的大小找到前序遍历中根节点的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preLen = preorder.size();</span><br><span class="line">    <span class="keyword">int</span> inLen = inorder.size();</span><br><span class="line">    <span class="keyword">if</span>(preLen != inLen || preLen == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;    </span><br><span class="line">    <span class="keyword">return</span> buildTree(preorder,<span class="number">0</span>,preLen<span class="number">-1</span>,inorder,<span class="number">0</span>,inLen<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回当前子树的根节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="keyword">int</span> preLeft,<span class="keyword">int</span> prerRight,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创造根节点</span></span><br><span class="line">    TreeNode* pNode = <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line">    <span class="keyword">if</span>(preLeft == prerRight)</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    <span class="comment">// 记录中序遍历找到根的位置</span></span><br><span class="line">    <span class="keyword">int</span> findPos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = inLeft; i &lt;= inRight;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == pNode -&gt; val)</span><br><span class="line">            findPos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftSize = findPos - inLeft;</span><br><span class="line">    <span class="comment">// 一定要先判断是否还存在左右节点，否则将会出现越界情况</span></span><br><span class="line">    <span class="keyword">if</span>(findPos <span class="number">-1</span> &gt;= inLeft)</span><br><span class="line">        pNode -&gt; left = buildTree(preorder,preLeft+<span class="number">1</span>,preLeft+leftSize,inorder,inLeft,findPos<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(inRight &gt;= findPos +<span class="number">1</span>)</span><br><span class="line">        pNode -&gt; right = buildTree(preorder,preLeft+leftSize+<span class="number">1</span>,prerRight,inorder,findPos+<span class="number">1</span>,inRight);</span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer37-序列化二差树"><a href="#剑指Offer37-序列化二差树" class="headerlink" title="剑指Offer37 序列化二差树  **  ** **"></a>剑指Offer37 序列化二差树  **  ** **</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<blockquote>
<p>你可以将以下二叉树：</p>
<pre><code>1</code></pre><p>   / <br>  2   3<br>     / <br>    4   5</p>
<p>序列化为 “[1,2,3,null,null,4,5]”</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root,<span class="built_in">string</span> &amp; SerializeString)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            SerializeString += <span class="string">"#,"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SerializeString += to_string(root -&gt; val);</span><br><span class="line">        SerializeString += <span class="string">","</span>;</span><br><span class="line">        serialize(root -&gt; left,SerializeString);</span><br><span class="line">        serialize(root -&gt; right,SerializeString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里一定要pos前带引用，希望一直保存pos的值</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span>&amp; data,<span class="keyword">int</span>&amp; pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[pos] == <span class="string">'#'</span>)&#123;</span><br><span class="line">            pos+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原来的字符还原成整数</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> isPositive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[pos] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            isPositive = <span class="literal">false</span>;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(data[pos] != <span class="string">','</span>)&#123;</span><br><span class="line">            num = num *<span class="number">10</span> + (data[pos] - <span class="string">'0'</span>);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">        <span class="keyword">if</span>(!isPositive) num = -num;</span><br><span class="line">        TreeNode* pNode = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        pNode -&gt; left = deserialize(data,pos);</span><br><span class="line">        pNode -&gt; right = deserialize(data, pos);</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> SerializeString;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> SerializeString;</span><br><span class="line">        serialize(root,SerializeString);</span><br><span class="line">        <span class="keyword">return</span> SerializeString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = data.size();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> pos =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(data,pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer68-二叉搜索数的最近公共祖先"><a href="#剑指Offer68-二叉搜索数的最近公共祖先" class="headerlink" title="剑指Offer68 二叉搜索数的最近公共祖先"></a>剑指Offer68 二叉搜索数的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>思路：利用二差树的性质，大了往左找，小了往右找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> curVal = root -&gt; val;</span><br><span class="line">    <span class="keyword">if</span>(curVal &gt; p-&gt;val &amp;&amp; curVal &gt; q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root -&gt; left,p,q);</span><br><span class="line">    <span class="keyword">if</span>(curVal &lt; p-&gt;val &amp;&amp; curVal &lt; q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低效率方法，查找该子树是否有该节点，找到了两个，找下一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">FindNodeExit</span><span class="params">(TreeNode* root,TreeNode* find)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            TreeNode* cur = nodes.top();</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; val == find -&gt; val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 在这里就要弹出</span></span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || p == <span class="literal">nullptr</span> || q==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 这里考虑忘了</span></span><br><span class="line">        <span class="keyword">if</span>(p == root || q == root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">bool</span> leftExitP = FindNodeExit(root -&gt; left,p);</span><br><span class="line">        <span class="keyword">bool</span> leftExitQ = FindNodeExit(root -&gt; left,q);</span><br><span class="line">        <span class="keyword">if</span>(leftExitP &amp;&amp; leftExitQ)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!leftExitP &amp;&amp; !leftExitQ)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt; right,p,q);</span><br><span class="line">        <span class="keyword">else</span>        </span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法2思路，递归思想</p>
<p>题目前提说明：</p>
<ul>
<li><p>所有节点的值都是唯一的</p>
</li>
<li><p>p,q为不同节点且均在给定的二叉树中</p>
<p>解题思路：</p>
</li>
</ul>
<p>二叉树公共节点的三种情况：</p>
<p>1 p 和 q都在左子树（right == null）</p>
<p>2 p 和 q 都在右子树 （left == null）</p>
<p>3 p 和 q 一个在左子树，一个在右子树，那么当前节点为最近公共祖先</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没找到返回nullptr,找到任意一个节点返回当前节点</span></span><br><span class="line">    <span class="keyword">if</span>(!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">//当前节点没找到继续向左子树右子树中寻找</span></span><br><span class="line">    TreeNode* leftNode = lowestCommonAncestor(root -&gt; left,p,q);</span><br><span class="line">    TreeNode* rightNode = lowestCommonAncestor(root -&gt; right, p,q);</span><br><span class="line">    <span class="comment">//节点在右子树边找到了两个</span></span><br><span class="line">    <span class="keyword">if</span>(leftNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    <span class="comment">// 节点在左子树找到了两个</span></span><br><span class="line">    <span class="keyword">if</span>(rightNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    <span class="comment">// 左右子树各找到一个直接返回当前节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路3：</p>
<p>利用后续遍历，找到达到当前节点的路径</p>
<p>找到两个路径的公共点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode* root,TreeNode* pNode,<span class="built_in">stack</span>&lt;TreeNode*&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 后续遍历</span></span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty() || cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                path.push(cur);</span><br><span class="line">                <span class="keyword">if</span>(cur == pNode)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 这里不要写错了，直接压入cur</span></span><br><span class="line">                nodes.push(cur);</span><br><span class="line">                cur = cur -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = nodes.top();</span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;right || pre == cur -&gt; right)&#123;</span><br><span class="line">                nodes.pop();</span><br><span class="line">                path.pop();</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; pathP;</span><br><span class="line">        findPath(root,p,pathP);</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; pathQ;</span><br><span class="line">        findPath(root,q,pathQ);</span><br><span class="line">        <span class="keyword">while</span>(pathP.size() != pathQ.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pathP.size() &gt; pathQ.size())</span><br><span class="line">                pathP.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pathQ.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pathP.top() != pathQ.top())&#123;</span><br><span class="line">            pathQ.pop();</span><br><span class="line">            pathP.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pathQ.top();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将上述循环找路径改为递归</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findPath</span><span class="params">(TreeNode* root,TreeNode* pNode,<span class="built_in">stack</span>&lt;TreeNode*&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        path.push(root);</span><br><span class="line">        <span class="keyword">if</span>(root == pNode)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(findPath(root -&gt; left,pNode,path))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(findPath(root -&gt; right,pNode,path))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        path.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指26Offer-树的子结构"><a href="#剑指26Offer-树的子结构" class="headerlink" title="剑指26Offer. 树的子结构"></a>剑指26Offer. 树的子结构</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(A == <span class="literal">nullptr</span> || B == <span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 这里要注意，只有第一个调用hasSub ,后边两个左递归使用</span></span><br><span class="line">      <span class="keyword">return</span> hasSubStructure(A,B) || isSubStructure(A -&gt; left,B) </span><br><span class="line">              || isSubStructure(A -&gt; right,B);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 一定要先判断B是否为空</span></span><br><span class="line">      <span class="keyword">if</span>(B == <span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(A == <span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(A -&gt; val!= B-&gt;val)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> hasSubStructure(A -&gt; left,B -&gt; left) &amp;&amp; </span><br><span class="line">                  hasSubStructure(A -&gt; right,B -&gt; right);</span><br><span class="line">          </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer55-1-二叉树的深度"><a href="#剑指Offer55-1-二叉树的深度" class="headerlink" title="剑指Offer55-1 二叉树的深度"></a>剑指Offer55-1 二叉树的深度</h2><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>递归思想，比较左子树和右子树哪个深度大就返回哪个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> depthleft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> depthright = <span class="number">0</span>;</span><br><span class="line">    depthleft = maxDepth(root -&gt; left) +<span class="number">1</span>;</span><br><span class="line">    depthright = maxDepth(root -&gt; right) +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (depthleft &gt; depthright? depthleft:depthright);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以用层序遍历求出深度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> nodesSize = nodes.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; nodesSize; ++i)&#123;</span><br><span class="line">            TreeNode* cur = nodes.front();</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur -&gt; left);</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(cur -&gt; right);</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        layer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer55-2-平衡二叉树"><a href="#剑指Offer55-2-平衡二叉树" class="headerlink" title="剑指Offer55-2 平衡二叉树"></a>剑指Offer55-2 平衡二叉树</h2><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p>思路：</p>
<p> 判断本身以及各自的子节点是否为平衡二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> depthLeft = depthTree(root -&gt; left);</span><br><span class="line">    <span class="keyword">int</span> depthRight = depthTree(root -&gt; right);</span><br><span class="line">    <span class="keyword">if</span>(depthLeft &gt; depthRight +<span class="number">1</span> || depthRight &gt; depthLeft +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root -&gt; left) &amp;&amp; isBalanced(root -&gt; right);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depthTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> depthLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> depthRight = <span class="number">0</span>;</span><br><span class="line">    depthLeft = depthTree(root -&gt; left) +<span class="number">1</span>;</span><br><span class="line">    depthRight = depthTree(root -&gt; right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> max(depthLeft,depthRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer27-二叉树的镜像"><a href="#剑指Offer27-二叉树的镜像" class="headerlink" title="剑指Offer27 二叉树的镜像"></a>剑指Offer27 二叉树的镜像</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<blockquote>
<p>例如输入：</p>
<pre><code>4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>镜像输出：</p>
<pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1</p>
</blockquote>
<p>递归思想：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建立了一个树</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* pNode = <span class="keyword">new</span> TreeNode(root -&gt; val);</span><br><span class="line">        pNode -&gt; right = mirrorTree(root -&gt; left);</span><br><span class="line">        pNode -&gt; left = mirrorTree(root -&gt; right);</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 在原有的树上修改</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* pNode = root -&gt; left;</span><br><span class="line">        root -&gt; left = mirrorTree(root -&gt; right);</span><br><span class="line">        root -&gt; right = mirrorTree(pNode);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>考虑用循环怎么做，前序遍历根左右，改为根右左</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        TreeNode* cur = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        <span class="comment">// 这里判断为只要不是两个都为null就交换</span></span><br><span class="line">        <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span> || cur -&gt; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeNode* tmp = cur -&gt; left;</span><br><span class="line">            cur -&gt; left = cur -&gt; right;</span><br><span class="line">            cur -&gt; right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur -&gt; right != <span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(cur -&gt; right);</span><br><span class="line">        <span class="keyword">if</span>(cur -&gt; left != <span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(cur -&gt; left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer28-对称的二差树"><a href="#剑指Offer28-对称的二差树" class="headerlink" title="剑指Offer28 对称的二差树"></a>剑指Offer28 对称的二差树</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>递归： 左根右 等于  右根左</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root,root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* pRoot1,TreeNode* pNode2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode2 == <span class="literal">nullptr</span> &amp;&amp; pRoot1 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode2 == <span class="literal">nullptr</span> || pRoot1 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode2 -&gt;val != pRoot1 -&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isSymmetric(pRoot1-&gt;left,pNode2 -&gt; right)</span><br><span class="line">    &amp;&amp; isSymmetric(pRoot1 -&gt; right ,pNode2 -&gt; left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环试一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes2;</span><br><span class="line">    TreeNode* cur1 = root; </span><br><span class="line">    TreeNode* cur2 = root;</span><br><span class="line">    <span class="comment">// cur判断条件别忘了</span></span><br><span class="line">    <span class="keyword">while</span>(!nodes1.empty() || cur1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// 右节点空了直接因该返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!cur2 || cur1-&gt;val != cur2 -&gt; val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            nodes1.push(cur1);</span><br><span class="line">            cur1 = cur1 -&gt; left;</span><br><span class="line">            nodes2.push(cur2);</span><br><span class="line">            cur2 = cur2 -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = nodes1.top();</span><br><span class="line">        nodes1.pop();</span><br><span class="line">        cur2 = nodes2.top();</span><br><span class="line">        nodes2.pop();</span><br><span class="line">        cur1 = cur1 -&gt; right;</span><br><span class="line">        cur2 = cur2 -&gt; left;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer33-二叉搜索树的后序遍历序列"><a href="#剑指Offer33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指Offer33. 二叉搜索树的后序遍历序列"></a>剑指Offer33. 二叉搜索树的后序遍历序列</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> VerifySquenceOfBSTCore(sequence,<span class="number">0</span>,sequence.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBSTCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sequence,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(sequence.size() == <span class="number">0</span> || right &lt; left)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    	<span class="comment">// 先找到左子节点的位置的下一个位置</span></span><br><span class="line">    	<span class="keyword">int</span> i = left;</span><br><span class="line">    	<span class="keyword">for</span>(; i &lt; right;++i)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(sequence[i] &gt; sequence[right])</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 这个位置之后的所有值都应该大于sequence[right]的值</span></span><br><span class="line">    	<span class="keyword">int</span> j =i;</span><br><span class="line">    	<span class="keyword">for</span>(;j &lt; right;++j)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(sequence[j] &lt; sequence[right])</span><br><span class="line">    			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">bool</span> leftSequece = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 没有值直接就是true，有值判断是否符合规矩</span></span><br><span class="line">    	<span class="keyword">if</span>(left &lt; i<span class="number">-1</span>)</span><br><span class="line">    		leftSequece = VerifySquenceOfBSTCore(sequence,left,i<span class="number">-1</span>);</span><br><span class="line">    	<span class="keyword">bool</span> rightSequece = <span class="literal">true</span>;</span><br><span class="line">    	<span class="keyword">if</span>(right &gt; j)</span><br><span class="line">    		rightSequece = VerifySquenceOfBSTCore(sequence,j,right);</span><br><span class="line">    	<span class="keyword">return</span> leftSequece &amp;&amp; rightSequece;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="剑指Offer-10-斐波那契数列"><a href="#剑指Offer-10-斐波那契数列" class="headerlink" title="剑指Offer 10 斐波那契数列"></a>剑指Offer 10 斐波那契数列</h2><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lastTwoNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lastNum =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">        sum = (lastTwoNum + lastNum) % <span class="number">1000000007</span>;</span><br><span class="line">        lastTwoNum = lastNum;</span><br><span class="line">        lastNum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode70-爬楼梯剑指Offer10-2-青蛙跳台阶"><a href="#Leetcode70-爬楼梯剑指Offer10-2-青蛙跳台阶" class="headerlink" title="Leetcode70. 爬楼梯剑指Offer10 -2 青蛙跳台阶"></a>Leetcode70. 爬楼梯剑指Offer10 -2 青蛙跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Leetcode</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n ==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        res[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>] + res[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 剑指</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n ==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lastNum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lastTwoNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            sum = (lastNum + lastTwoNum) % <span class="number">1000000007</span>;</span><br><span class="line">            lastTwoNum = lastNum;</span><br><span class="line">            lastNum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer16-数值的整数次方"><a href="#剑指Offer16-数值的整数次方" class="headerlink" title="剑指Offer16 数值的整数次方"></a>剑指Offer16 数值的整数次方</h2><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。循环和递归写法如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(equal(x,<span class="number">0.0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 这里要改为long否则n为最小值的时候会超出int表示范围</span></span><br><span class="line">    <span class="keyword">long</span> circleTimes = n;        </span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        circleTimes = -circleTimes;</span><br><span class="line">        flag =<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> xSum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(circleTimes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(circleTimes %<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            xSum *= x;            </span><br><span class="line">        x = x* x;</span><br><span class="line">        circleTimes = circleTimes &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / xSum;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> xSum;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a - b &gt; <span class="number">-0.0000001</span>) &amp;&amp; (a - b &lt; <span class="number">0.0000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(equal(x,<span class="number">0.0</span>) &amp;&amp; n &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        g_InvalidInput = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        N = -N;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">double</span> res = myPowCore(x,N);   </span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        res = <span class="number">1.0</span> /res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPowCore</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">double</span> half = myPowCore(x,N /<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> res = half * half;</span><br><span class="line">    <span class="keyword">if</span>((N &amp; <span class="number">0x01</span>) == <span class="number">1</span>)</span><br><span class="line">        res = res * x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a - b &gt; <span class="number">-0.0000001</span>) &amp;&amp; (a - b &lt; <span class="number">0.0000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>DP没有递归，因为用数组存储前置结果，用这些结果可以进行递推。所以不用递归，但是也在递推。</p>
<p>将若干问题拆成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。（自底向上的解决问题）</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt></p>
<p>1 <strong>将原问题分解为子问题</strong>(开头已经介绍了怎么分解) (注意:1,子问题与原问题形式相同或类似,只是问题规模变小了,从而变简单了; 2,子问题一旦求出就要保存下来,保证每个子问题只求解一遍)<br>2 <strong>确定状态</strong>(状态:在动规解题中,我们将和子问题相关的各个变量的一组取值,称之为一个”状态”,一个状态对应一个或多个子问题所谓的在某个状态的值,这个就是状态所对应的子问题的解,所有状态的集合称为”状态空间”.我的理解就是状态就是某个问题某组变量,状态空间就是该问题的所有组变量) 另外:整个问题的时间复杂度就是状态数目乘以每个状态所需要的时间<br>3 <strong>确定一些初始状态(边界条件)的值</strong> (这个视情况而定,千万别以为就是最简单的那个子问题解,上面只是例子,真正实践动规千变万化)<br>4 *<em>确定状态转移方程 *</em>(这一步和第三步是最关键的 记住”人人为我”递推,由已知推未知)</p>
<h2 id="例子-给一个字符串，不带“-”可能有多少个IP"><a href="#例子-给一个字符串，不带“-”可能有多少个IP" class="headerlink" title="例子 给一个字符串，不带“.”可能有多少个IP"></a>例子 给一个字符串，不带“.”可能有多少个IP</h2><p>使用dfs思路可行，不过要进行大量重复计算</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/ip%E6%8B%86%E5%88%86.png" alt></p>
<p>给一个字符串长度为x，拆分成4个255以内的数，有多少种拆法，观察问题有两个维度</p>
<p>最难的点dp[ i ] [ j ]到底表达什么？</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/Ip%E7%94%BB%E8%A1%A8.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validate</span><span class="params">(<span class="built_in">string</span> tmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lengthS = s.size();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">5</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lengthS+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="comment">// 遍历赋值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; lengthS+<span class="number">1</span>; j++)&#123;</span><br><span class="line">			<span class="comment">//初始化一个数，为后续递推准备</span></span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j ==<span class="number">0</span>)&#123;</span><br><span class="line">				dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 最大位数</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;=<span class="number">3</span>; ++x)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j -x &gt;=<span class="number">0</span> &amp;&amp; validate(s.substr(j-x+<span class="number">1</span>,x)))&#123;</span><br><span class="line">					<span class="comment">//剩余字符串能组合多少有效值在之前记录</span></span><br><span class="line">					dp[i][j] += dp[i<span class="number">-1</span>][j-x];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">4</span>][lengthS];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validate</span><span class="params">(<span class="built_in">string</span> tmp)</span></span>&#123;</span><br><span class="line">	<span class="comment">//这里把空字符排除，否则stoi出现错误</span></span><br><span class="line">	<span class="keyword">if</span>(tmp == <span class="string">"0"</span> || tmp == <span class="string">""</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(tmp[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> stoi(tmp) &lt;=<span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode120三角型最小路径和"><a href="#LeetCode120三角型最小路径和" class="headerlink" title="LeetCode120三角型最小路径和"></a>LeetCode120三角型最小路径和</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用深度优先搜索超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLenPath = numeric_limits&lt;<span class="keyword">int</span>&gt;::max();</span><br><span class="line">        <span class="keyword">int</span> tmpLen = <span class="number">0</span>;</span><br><span class="line">        dfs(triangle,rows,minLenPath,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> minLenPath; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle,<span class="keyword">int</span> rows,<span class="keyword">int</span> &amp; minLenPath,<span class="keyword">int</span> tmpLen,<span class="keyword">int</span> level,<span class="keyword">int</span> lastCol)</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 截至条件</span></span><br><span class="line">    	<span class="keyword">if</span>(level == rows)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(tmpLen &lt; minLenPath)</span><br><span class="line">    			minLenPath = tmpLen;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 遍历候选节点</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; triangle[level].size(); ++i)&#123;</span><br><span class="line">    		<span class="comment">// 筛选</span></span><br><span class="line">    		<span class="keyword">if</span>(i == lastCol || (i - <span class="number">1</span>) == lastCol)&#123;</span><br><span class="line">    			dfs(triangle,rows,minLenPath,tmpLen + triangle[level][i],level+<span class="number">1</span>,i);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>动态规划思考</p>
<p>1、状态</p>
<p>定义<code>f[i][j]</code>表示从<code>[1,1]</code>出发走到i,j的路径最小和。</p>
<p>状态要明确两点</p>
<ul>
<li>初始状态 <code>f[1][1] = a[1][1]</code>其余都为inf</li>
<li>答案在哪里<code>min(f[n][1]...f[n][n])</code></li>
</ul>
<p>2、转移</p>
<p>考虑那些状态对<code>f[i][j]</code>这个状态有影响</p>
<blockquote>
<p>(i-1,j) -&gt; (i,j)</p>
<p>(i-1,j-1) -&gt; (i,j)</p>
</blockquote>
<p>如何转移？注意转移顺序</p>
<p><code>f[i][j] = min(f[i-1][j],f[i-1][j-1] + a[i][j])</code></p>
<p>将（1,1）到（i，j）的路径分成两类，</p>
<blockquote>
<p>(1,1) -&gt; (i-1,j) -&gt; (i,j) 和 (1,1) -&gt; (i-1,j-1) -&gt; (i,j)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=i; j++)&#123;</span><br><span class="line">        		<span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">        			dp[i][j] = dp[i<span class="number">-1</span>][j] + triangle[i][j];</span><br><span class="line">        		<span class="keyword">else</span> <span class="keyword">if</span>(j == i)</span><br><span class="line">        			dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + triangle[i][j];</span><br><span class="line">        		<span class="keyword">else</span></span><br><span class="line">        			dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + triangle[i][j];</span><br><span class="line"></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minNum = numeric_limits&lt;<span class="keyword">int</span>&gt;::max();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; tmp : dp[len<span class="number">-1</span>])&#123;</span><br><span class="line">        	<span class="keyword">if</span>(tmp &lt; minNum)</span><br><span class="line">        		minNum = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>自底向下，利用最后数组的长度建立保留上一步的最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> rows = triangle.size();</span><br><span class="line">    	<span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(triangle.back());</span><br><span class="line">        <span class="comment">//层数</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> level = rows<span class="number">-2</span>; level &gt;=<span class="number">0</span>; --level)&#123;</span><br><span class="line">    		<span class="comment">// 列数与层数相等</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt;= level; ++i)&#123;</span><br><span class="line">    			dp[i] = min(dp[i],dp[i+<span class="number">1</span>]) + triangle[level][i];</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer42-连续子数组的最大和"><a href="#剑指Offer42-连续子数组的最大和" class="headerlink" title="剑指Offer42 连续子数组的最大和"></a>剑指Offer42 连续子数组的最大和</h2><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。空间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Len = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(Len);</span><br><span class="line">    sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; Len; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum[i<span class="number">-1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + nums[i];   </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxSum = sum[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Len; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum[i] &gt; maxSum)</span><br><span class="line">            maxSum = sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度降为O(1)</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> lastSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lastSum &gt; <span class="number">0</span>)</span><br><span class="line">                lastSum = lastSum + nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lastSum = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(lastSum &gt; maxSum)</span><br><span class="line">                maxSum = lastSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-300-最长上升子序列"><a href="#LeetCode-300-最长上升子序列" class="headerlink" title="LeetCode 300. 最长上升子序列"></a>LeetCode 300. 最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong></p>
<p>确定状态，dp[i] 包含i的前i个数字中最长上升子序列的长度。</p>
<p>确定边界，全为1，自己就至少有一个数</p>
<p><strong>状态转移方程</strong></p>
<p><code>OPT(i) = OPT(lastMinBefor(i)) + 1  if lastMinBefor &gt;=0</code> 存在比当前小的数字的下标，并且在这些下标中也要挑选出最大的dp值的下标。</p>
<p><code>else OPT(i) = 1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> len = nums.size();</span><br><span class="line">    	<span class="keyword">if</span>(len ==<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(len,<span class="number">1</span>);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len;i++)&#123;</span><br><span class="line">    		<span class="keyword">int</span> lastMin = hasMinNumBefor(nums,dp,i);</span><br><span class="line">    		<span class="keyword">if</span>(lastMin &gt;=<span class="number">0</span>)</span><br><span class="line">    			dp[i] = dp[lastMin] + <span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    			dp[i] = <span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">int</span> maxLen = dp[<span class="number">0</span>];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len;++i)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(dp[i] &gt; maxLen)</span><br><span class="line">    			maxLen = dp[i];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hasMinNumBefor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dp,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> tmp = nums[n];</span><br><span class="line">    	<span class="keyword">int</span> minNumBer = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 找到比当前值小数字的下标，并且选出这些下标dp长度的最大值</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(nums[i] &lt; tmp)&#123;</span><br><span class="line">    			<span class="keyword">if</span>(minNumBer == <span class="number">-1</span>)</span><br><span class="line">    				minNumBer = i;</span><br><span class="line">    			<span class="keyword">else</span> <span class="keyword">if</span>(dp[minNumBer] &lt; dp[i])</span><br><span class="line">    				minNumBer = i;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> minNumBer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>学习一下别人的简洁写法</p>
<p>状态转移方程</p>
<p><code>dp[i] = max(dp[i],dp[j]+1)（j = 0,...i-1, nums[i] &gt; nums[j]）</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> len = nums.size();</span><br><span class="line">    	<span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(len,<span class="number">1</span>);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len;i++)&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">    			<span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">    				dp[i] = max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">int</span> maxLen = dp[<span class="number">0</span>];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(dp[i] &gt; maxLen)</span><br><span class="line">    			maxLen=dp[i];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> maxLen;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的方法都是O（n^2）的复杂度，现在要nlog(n)的复杂度，用二分查找的思想，dp[i]表示最长子串的最后一个字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="comment">//找到当前数字应该插入的位置，在原数组中大于等于num的下标</span></span><br><span class="line">            <span class="keyword">auto</span> idx = lower_bound(dp.begin(), dp.end(), num) - dp.begin();</span><br><span class="line">            <span class="comment">//没找到比num更大的数字，向后插入</span></span><br><span class="line">            <span class="keyword">if</span> (idx &gt;= dp.size()) &#123;</span><br><span class="line">                dp.emplace_back(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[idx] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//不用algorithm</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        	<span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">        	<span class="keyword">int</span> right = dp.size();</span><br><span class="line">        	<span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        		<span class="keyword">int</span> mid = (left + right) /<span class="number">2</span>;</span><br><span class="line">        		<span class="keyword">if</span>(dp[mid] &lt; num)</span><br><span class="line">        			left = mid+<span class="number">1</span>;</span><br><span class="line">        		<span class="keyword">else</span></span><br><span class="line">        			right = mid;</span><br><span class="line">        	&#125;</span><br><span class="line">            <span class="keyword">int</span> idx = left;</span><br><span class="line">            <span class="keyword">if</span> (idx &gt;= dp.size()) &#123;</span><br><span class="line">                dp.emplace_back(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[idx] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer63-股票的最大利润"><a href="#剑指Offer63-股票的最大利润" class="headerlink" title="剑指Offer63 股票的最大利润"></a>剑指Offer63 股票的最大利润</h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到最低买入点，和最高卖出点就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Len = prices.size();</span><br><span class="line">    <span class="keyword">int</span> buyPoint = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sellPoint = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> profits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(sellPoint =<span class="number">1</span>; sellPoint &lt; Len; ++sellPoint)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[sellPoint] &gt;= prices[buyPoint])&#123;</span><br><span class="line">            profits = prices[sellPoint] - prices[buyPoint];</span><br><span class="line">            <span class="keyword">if</span>(profits &gt; maxProfit)</span><br><span class="line">                maxProfit = profits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            buyPoint = sellPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer12-矩阵中的路径"><a href="#剑指Offer12-矩阵中的路径" class="headerlink" title="剑指Offer12 矩阵中的路径 **"></a>剑指Offer12 矩阵中的路径 **</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f”</strong>,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = board.size();</span><br><span class="line">    <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(cols == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; flag(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; ++row)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col =<span class="number">0</span>; col &lt; cols; ++col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word[<span class="number">0</span>] == board[row][col])&#123;</span><br><span class="line">                <span class="keyword">if</span>(findPath(board,flag,word,row,col,<span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;                              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; flag,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">string</span>&amp; word,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> wordPos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = board.size();</span><br><span class="line">    <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> wordLen = word.size();</span><br><span class="line">    <span class="keyword">if</span>(wordPos == wordLen)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line">    <span class="keyword">if</span>(col &lt; <span class="number">0</span> || col &gt;= cols || row &lt; <span class="number">0</span> || row &gt;= rows || board[row][col] != word[wordPos])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag[row][col])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    flag[row][col] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> res = findPath(board,flag,word,row <span class="number">-1</span>,col,wordPos+<span class="number">1</span>) ||</span><br><span class="line">        findPath(board,flag,word,row+<span class="number">1</span>,col,wordPos+<span class="number">1</span>) ||</span><br><span class="line">        findPath(board,flag,word,row,col <span class="number">-1</span>,wordPos+<span class="number">1</span>) ||</span><br><span class="line">        findPath(board,flag,word,row,col+<span class="number">1</span>,wordPos+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 查找失败，将标志位置为false</span></span><br><span class="line">    flag[row][col] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode343面试题14-I-剪绳子"><a href="#LeetCode343面试题14-I-剪绳子" class="headerlink" title="LeetCode343面试题14- I. 剪绳子"></a>LeetCode343面试题14- I. 剪绳子</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>动态规划</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里要预留出来一位</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">4</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    res[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    res[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            tmp = res[j] * res[i-j];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; max)</span><br><span class="line">                max =tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = max;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贪心算法,如果可以分出来3就分出来3,否则分出来2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> thereTimes = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> twoTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> remain = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(remain == <span class="number">1</span>)&#123;</span><br><span class="line">        thereTimes--;</span><br><span class="line">        twoTimes+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">2</span>)</span><br><span class="line">        twoTimes++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>,thereTimes) * <span class="built_in">pow</span>(<span class="number">2</span>,twoTimes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode64面试题47-礼物的最大价值"><a href="#Leetcode64面试题47-礼物的最大价值" class="headerlink" title="Leetcode64面试题47. 礼物的最大价值"></a>Leetcode64面试题47. 礼物的最大价值</h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = grid.size();</span><br><span class="line">    <span class="keyword">if</span>(rows ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(cols ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; maxSum(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols,<span class="number">0</span>));</span><br><span class="line">    maxSum[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col =<span class="number">1</span>; col &lt; cols; col++)&#123;</span><br><span class="line">        maxSum[<span class="number">0</span>][col] = maxSum[<span class="number">0</span>][col<span class="number">-1</span>] + grid[<span class="number">0</span>][col];        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row =<span class="number">1</span>; row &lt; rows; row++)&#123;</span><br><span class="line">        maxSum[row][<span class="number">0</span>] = maxSum[row<span class="number">-1</span>][<span class="number">0</span>] + grid[row][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row =<span class="number">1</span>; row &lt; rows; row++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col =<span class="number">1</span>; col &lt; cols; col++)&#123;</span><br><span class="line">            maxSum[row][col] = max(maxSum[row<span class="number">-1</span>][col],</span><br><span class="line">                                  maxSum[row][col<span class="number">-1</span>]) + grid[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-312-戳气球"><a href="#LeetCode-312-戳气球" class="headerlink" title="LeetCode 312. 戳气球**"></a>LeetCode 312. 戳气球**</h2><p>难度困难274</p>
<p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p>
<p>现在要求你戳破所有的气球。每当你戳破一个气球 <code>i</code> 时，你可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p><strong>说明:</strong></p>
<ul>
<li>你可以假设 <code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li>
<li>0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>]</span><br><span class="line">输出: <span class="number">167</span> </span><br><span class="line">解释: nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>] --&gt; [<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>] --&gt;   [<span class="number">3</span>,<span class="number">8</span>]   --&gt;  [<span class="number">8</span>]  --&gt; []</span><br><span class="line">     coins =  <span class="number">3</span>*<span class="number">1</span>*<span class="number">5</span>      +  <span class="number">3</span>*<span class="number">5</span>*<span class="number">8</span>    +  <span class="number">1</span>*<span class="number">3</span>*<span class="number">8</span>      + <span class="number">1</span>*<span class="number">8</span>*<span class="number">1</span>   = <span class="number">167</span></span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>给定四个球分别为[3,1,5,8],其实可以看做数组[1,3,1,5,8,1];</p>
<p>我们令<code>dp[start][end]</code>表示从start到end之间的气球戳破之后能得到的最大值，则本题就是求解<code>dp[0][5]</code>,即戳破3,1,5,8四个气球能得到的最大值。</p>
<p>为了求解<code>dp[0][5]</code>,我们要先得到递推公式，我们假设最后戳破的是第i个气球，则得到的值为：</p>
<p><code>dp[0][5]=dp[0][i]+dp[i][5]+nums[0]*nums[i]*nums[5];</code></p>
<p>*<em>即求得递推公式 *</em><br><code>dp[start][end]=max(dp[start][i]+dp[i][end]+nums[start]*nums[i]*nums[end])</code></p>
<ol>
<li>值得注意的是我们是假设最后戳破的是第i个气球，而不是第一个戳破的是第i个气球，因为根据题目我们可以知道相连的气球之间是有关联性的。<strong>假设最后戳破第i个气球</strong>才能满足之前戳破的气球中，i左边的跟i右边的不会相邻，也就是<code>dp[start][i]</code>和dp[i][end]才有效。</li>
<li>2.其中0开始0结尾的气球序列的值一定为0,0开始1结尾的气球序列的值也为0.这是因为我们只能戳破边界值以外的数。想象一下，我们有（0，…i…, n-1)这样的序列，假设最后戳破的是下标为i的气球，所以之前戳破的气球一定都在（0，i), (i,n-1)中，注意这里没有使用[0,i]这样的符号，是因为之前戳破的气球一定不是i（i是最后戳破的），也一定不是0和n-1，因为0和n-1是人为加上去的，戳破了没有意义，所以只能是开区间内的值，而（0，0），（0，1）没有区间内的气球可以戳破，所以它的硬币值为0。<br><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E6%88%B3%E6%B0%94%E7%90%83.png" alt><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    	nums.push_back(<span class="number">1</span>);</span><br><span class="line">    	nums.insert(nums.begin(),<span class="number">1</span>);</span><br><span class="line">    	<span class="keyword">int</span> dp[nums.size()][nums.size()];</span><br><span class="line">    	<span class="comment">// 初始化</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    		dp[i][i] = <span class="number">0</span>;</span><br><span class="line">    		<span class="keyword">if</span>((i+<span class="number">1</span>) &lt; nums.size())</span><br><span class="line">    			dp[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">//从倒数第二个元素开始</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> start = nums.size()<span class="number">-3</span>; start &gt;= <span class="number">0</span>; --start)&#123;</span><br><span class="line">            <span class="comment">// 首尾至少相隔两个数字</span></span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> end = start +<span class="number">2</span>; end &lt; nums.size(); ++end)&#123;</span><br><span class="line">    			<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    			<span class="keyword">for</span>(<span class="keyword">int</span> k = start +<span class="number">1</span>; k &lt; end; ++k)&#123;</span><br><span class="line">    				<span class="keyword">int</span> tmp = nums[k]*nums[start]*nums[end] + dp[start][k] +dp[k][end];</span><br><span class="line">    				<span class="keyword">if</span>(tmp &gt; max)</span><br><span class="line">    					max = tmp;</span><br><span class="line">    			&#125;</span><br><span class="line">    			dp[start][end] = max;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> dp[<span class="number">0</span>][nums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="加权项目时间计划"><a href="#加权项目时间计划" class="headerlink" title="加权项目时间计划"></a>加权项目时间计划</h2><p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E5%8A%A0%E6%9D%83%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%97%B4%E8%AE%A1%E5%88%92.png" alt></p>
<p>项目花费的时间和获得的金钱如图，同一时间不能做两个项目，求能获得的最多钱是多少？</p>
<p>设一个量OPT，先考虑状态前8个任务的最优解是什么？那么OPT(8)这个任务就有两种情况，选和不选。选第八个那么6,7任务就不能选了，只能选前面5个的最好结果。<br>$$<br>OPT(8) = \left{<br>\begin{aligned}<br>OPT(7) \<br>4 + OPT(5)<br>\end{aligned}<br>\right.<br>$$</p>
<p>$$<br>OPT(i) = max\left{<br>\begin{aligned}<br>OPT(i-1) \<br>v(i) + OPT(pre(i))<br>\end{aligned}<br>\right.<br>$$</p>
<p>看看pre怎么取</p>
<table>
<thead>
<tr>
<th>i</th>
<th>pre(i)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>5</td>
</tr>
</tbody></table>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入几个项目，依次输入项目的开始时间，结束时间和价值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">project</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> begin;</span><br><span class="line">	<span class="keyword">int</span> end;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; out)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		out &lt;&lt; begin &lt;&lt; <span class="string">' '</span> &lt;&lt; end &lt;&lt; <span class="string">' '</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out ,<span class="keyword">const</span> project&amp; p)&#123;</span><br><span class="line">		p.print(out);</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxValueProjects</span><span class="params">(<span class="built_in">vector</span>&lt;project&gt;&amp; a)</span></span>&#123;</span><br><span class="line">		<span class="comment">// pre[0]为0</span></span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre(a.size(),<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; a.size();i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line">				<span class="comment">// 任务i开始之前能完成什么任务</span></span><br><span class="line">				<span class="keyword">if</span>(a[i].begin &gt;= a[j].end)&#123;</span><br><span class="line">					pre[i] = j;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span>&amp; tmp:pre)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//选做前几个任务的最优解</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; OPT(a.size(),<span class="number">0</span>);</span><br><span class="line">		OPT[<span class="number">0</span>] = a[<span class="number">0</span>].value;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.size(); i++)&#123;</span><br><span class="line">			OPT[i] = max(OPT[i<span class="number">-1</span>],a[i].value + OPT[pre[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> OPT[a.size()<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Solution s;</span><br><span class="line">	<span class="comment">//输入几组数据</span></span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="comment">//添加一个默认任务0为全0，方便推导pre</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;project&gt; a&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		project tmpPro;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmpPro.begin &gt;&gt; tmpPro.end &gt;&gt; tmpPro.value;</span><br><span class="line">		a.push_back(tmpPro);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.maxValueProjects(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连续数字不相邻最大和"><a href="#连续数字不相邻最大和" class="headerlink" title="连续数字不相邻最大和"></a>连续数字不相邻最大和</h2><p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E4%B8%8D%E7%9B%B8%E9%82%BB%E6%9C%80%E5%A4%A7%E5%92%8C.png" alt></p>
<p>OPT(6)代表考虑下标6之前的数字最优解为，那么就可以选择下标6这个数字或者不选择。<br>$$<br>OPT(i) = max\left{<br>\begin{aligned}<br>选：OPT(i-2) + arr[i] \<br>不选：OPT(i-1)<br>\end{aligned}<br>\right.<br>$$<br>​                                    $OPT[0] = arr[0]$<br>$$<br>OPT(1) = \left{<br>\begin{aligned}<br>arr[0] \<br>arr[1]<br>\end{aligned}<br>\right.<br>$$<br>首先用递归来写一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">recurMaxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(i ==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> a[i];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> max(a[<span class="number">0</span>],a[i]);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> A = recurMaxSum(a,i<span class="number">-2</span>) + a[i];</span><br><span class="line">			<span class="keyword">int</span> B = recurMaxSum(a,i<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">return</span> max(A,B);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stringstream</span> sS;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	getline(<span class="built_in">cin</span>,s);</span><br><span class="line">	sS &lt;&lt; s;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">	<span class="keyword">while</span>(sS &gt;&gt;tmp)&#123;</span><br><span class="line">		a.push_back(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	Solution solu;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; solu.recurMaxSum(a,a.size()<span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划思想写一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">recurMaxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = a.size();</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> max(a[<span class="number">0</span>],a[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(a.size(),<span class="number">0</span>);</span><br><span class="line">		result[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">		result[<span class="number">1</span>] = max(a[<span class="number">0</span>],a[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; ++i)&#123;</span><br><span class="line">			result[i] = max(result[i<span class="number">-1</span>],result[i<span class="number">-2</span>]+a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result[len<span class="number">-1</span>];</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数组中是否有几个数字加和等于指定数字"><a href="#数组中是否有几个数字加和等于指定数字" class="headerlink" title="数组中是否有几个数字加和等于指定数字"></a>数组中是否有几个数字加和等于指定数字</h2><p>约束，数字都为正整数</p>
<p>e.g </p>
<p>arr = {3,34,4,12,5,2},S = 9</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E7%9B%B8%E5%8A%A0%E6%8C%87%E5%AE%9A%E6%95%B0%E5%AD%97.png" alt></p>
<p>Subset前i个数字能否凑出S</p>
<p>截至条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if s ==0:</span><br><span class="line">	return ture</span><br><span class="line">if i == 0:</span><br><span class="line">	return arr[0] == s</span><br><span class="line">if arr[i] &gt; s:</span><br><span class="line">	return Subset(arr[i-1],s)</span><br></pre></td></tr></table></figure>

<p>递归规则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Subset(arr,i,s)</span><br><span class="line">选 Subset(arr[i<span class="number">-1</span>],s-arr[i])</span><br><span class="line">不选 subset(arr[i<span class="number">-1</span>],s)</span><br></pre></td></tr></table></figure>

<p>递归代码写出来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">recurSubset</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr,<span class="keyword">int</span> i,<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(S == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> arr[<span class="number">0</span>] == S;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; S)</span><br><span class="line">			<span class="keyword">return</span> recurSubset(arr,i<span class="number">-1</span>,S);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> recurSubset(arr,i<span class="number">-1</span>,S-arr[i]) || recurSubset(arr,i<span class="number">-1</span>,S); </span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stringstream</span> sS;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	getline(<span class="built_in">cin</span>,s);</span><br><span class="line">	sS &lt;&lt; s;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">	<span class="keyword">while</span>(sS &gt;&gt;tmp)&#123;</span><br><span class="line">		a.push_back(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> sumN =<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; sumN;</span><br><span class="line">	Solution solu;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; solu.recurSubset(a,a.size()<span class="number">-1</span>,sumN) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用动态规划</p>
<p>使用二维数组保存中间过程</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0%E5%92%8C%E5%8A%A8%E6%80%81.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dpSubset</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr,<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; subset(arr.size(),<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(S+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">	<span class="keyword">if</span>(arr[<span class="number">0</span>] &lt;= S)</span><br><span class="line">		subset[<span class="number">0</span>][arr[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size();i++)</span><br><span class="line">		subset[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size();++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>; j &lt; S+<span class="number">1</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i] &gt; j)</span><br><span class="line">				subset[i][j] = subset[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				subset[i][j] = subset[i<span class="number">-1</span>][j] || subset[i<span class="number">-1</span>][j-arr[i]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> subset[arr.size()<span class="number">-1</span>][S];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>给n个物品，每个物品有体积vi以及价值wi，取n个物品的一个子集，使得体积和不超过m，并且价值和尽量大。</p>
<p><strong>状态</strong></p>
<p><code>f[i][j]</code>表示考虑前i个物品，占用体积为j，能得到的最大值。</p>
<p><strong>转移</strong></p>
<p><code>f[i][j] = max(f[i-1][j],f[i-1][j-v[i]] + w[i])</code></p>
<p>考虑第i个物品到底是取还是不取</p>
<p>取则从<code>f[i-1][j-v[i]]+w[i]</code>转移过来</p>
<p>不取则从<code>f[i-1][j]</code>转移过来</p>
<p><strong>空间优化</strong></p>
<ul>
<li>滚动数组</li>
</ul>
<p>数组<code>f[i][j]</code>的取值只与上一行有关，开数组<code>f[2][maxn]</code></p>
<p>用<code>f[i%2][j]</code>代表当前行</p>
<p>用<code>f[(i-1)%2][j]</code>带表上一行</p>
<ul>
<li>进一步优化</li>
</ul>
<p>开一个数组就够了</p>
<p><strong>状态只与前一行j左侧的数字有关系，所以从后前更新</strong>，j以后的是当前行，j以前的是上一行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>（<span class="keyword">int</span> i =<span class="number">1</span>; i &lt;=n;i++)&#123;</span><br><span class="line">    <span class="comment">//m为背包的最大容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= v[i];j--)</span><br><span class="line">        f[i] = max(f[j],f[j-v[i]] + w[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>与01背包不同，每个物品可以不限制次数取</p>
<p><code>f[i][j] = max(f[i-1][j],f[i][j-v[i]] + w[i])</code></p>
<p>转移方程略作修改，你会发现,这个伪代码与 01背包 的伪代码只有 j 的循环次序不同而已。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = v[i]; j &lt;=m;j++)&#123;</span><br><span class="line">        f[i] = max(f[i],f[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 n[i]件可用,每件费用是 c[i],价值是 w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量,且价值总和最大。<strong>将多重背包问题 转化为0,1背包。</strong></p>
<h1 id="dfs和bfs"><a href="#dfs和bfs" class="headerlink" title="dfs和bfs"></a>dfs和bfs</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><h2 id="抽象树"><a href="#抽象树" class="headerlink" title="抽象树"></a>抽象树</h2><p>使用栈保存未被检测的结点，结点按照深度优先的次序被访问并依次被压入栈中，并以相反的次序出栈进行新的检测。</p>
<ul>
<li>类似与树的先序遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span><span class="comment">//参数用来表示状态  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(到达终点状态)  </span><br><span class="line">    &#123;  </span><br><span class="line">        ...<span class="comment">//根据题意添加  </span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(越界或者是不合法状态)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    <span class="keyword">if</span>(特殊状态)<span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(扩展方式)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(扩展方式所达到状态合法)  </span><br><span class="line">        &#123;  </span><br><span class="line">            修改操作;<span class="comment">//根据题意来添加  </span></span><br><span class="line">            标记；  </span><br><span class="line">            dfs（）；  </span><br><span class="line">            (还原标记)；  </span><br><span class="line">            <span class="comment">//是否还原标记根据题意  </span></span><br><span class="line">            <span class="comment">//如果加上（还原标记）就是 回溯法  </span></span><br><span class="line">        &#125;  </span><br><span class="line"> </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是从例子入手</p>
<h3 id="例题1-ABC的全排列"><a href="#例题1-ABC的全排列" class="headerlink" title="例题1 ABC的全排列"></a>例题1 ABC的全排列</h3><p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/ABC.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; inputArr,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; usedArr,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1确定截至条件</span></span><br><span class="line">	<span class="keyword">if</span>(level == inputArr.size())&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span>&amp; i : res)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2 遍历候选节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputArr.size();++i)&#123;</span><br><span class="line">		<span class="comment">//2.1筛选</span></span><br><span class="line">		<span class="keyword">if</span>(!usedArr[i])&#123;</span><br><span class="line">			usedArr[i] = <span class="literal">true</span>;</span><br><span class="line">			res.push_back(inputArr[i]);</span><br><span class="line">			dfs(inputArr,res,usedArr,level +<span class="number">1</span>);</span><br><span class="line">			<span class="comment">//2.2状态复原，不要影响到同一层次其他的元素</span></span><br><span class="line">			res.pop_back();</span><br><span class="line">			usedArr[i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; inputArr;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">while</span>((c = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line">		inputArr.push_back(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; usedArr(inputArr.size(),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	dfs(inputArr,res,usedArr,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化，不需要level，输出数组长度等于输入数组了就可以输出了，不需要used，一旦将元素插入res，就把原来的数组相应位置置为null，在回溯的时候将相应的值复制回原数组就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; inputArr,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(res.size() == inputArr.size())&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span>&amp; i:res)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; inputArr.size(); ++i)&#123;</span><br><span class="line">		<span class="keyword">char</span> c = inputArr[i];</span><br><span class="line">		<span class="keyword">if</span>(c)&#123;</span><br><span class="line">			res.push_back(c);</span><br><span class="line">			inputArr[i] = <span class="number">0</span>;</span><br><span class="line">			dfs(inputArr,res);</span><br><span class="line">			inputArr[i] = c;</span><br><span class="line">			res.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode-93复原IP地址"><a href="#Leetcode-93复原IP地址" class="headerlink" title="Leetcode:93复原IP地址"></a>Leetcode:93复原IP地址</h3><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E5%A4%8D%E5%8E%9FIP.png" alt></p>
<p>截至 条件？数字全部选完，四个坑位填满</p>
<p>筛选条件？每个数是0~255</p>
<p>候选？记录当前到哪位，只能往后选3位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreIPAdrees</span><span class="params">(<span class="built_in">string</span>&amp; oldIP,<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; legalIP,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 截至条件</span></span><br><span class="line">	<span class="keyword">if</span>(level == <span class="number">4</span> || index == oldIP.size())&#123;</span><br><span class="line">        <span class="comment">//筛选，除了以下情况其余排除</span></span><br><span class="line">		<span class="keyword">if</span>(level == <span class="number">4</span> &amp;&amp; index &gt;= oldIP.size())&#123;</span><br><span class="line">			<span class="built_in">string</span> tmp;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;legalIP.size()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">				tmp += legalIP[i];</span><br><span class="line">				tmp += <span class="string">'.'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			tmp+=legalIP[legalIP.size() <span class="number">-1</span>];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			res.push_back(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//候选人</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">		<span class="comment">// 将可能的字符截取出来</span></span><br><span class="line">		<span class="built_in">string</span> c = oldIP.substr(index,i);</span><br><span class="line">		<span class="keyword">int</span> num = stoi(c);</span><br><span class="line">		<span class="comment">// 筛选大于255不行,"01,011"特殊情况不行</span></span><br><span class="line">		<span class="keyword">if</span>(num &lt;= <span class="number">255</span> &amp;&amp; (c == <span class="string">"0"</span> || c[<span class="number">0</span>]!=<span class="string">'0'</span>))&#123;</span><br><span class="line">			legalIP.push_back(c);</span><br><span class="line">			restoreIPAdrees(oldIP,index+i,legalIP,level+<span class="number">1</span>);</span><br><span class="line">			legalIP.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// char c;</span></span><br><span class="line">	<span class="comment">// while((c = getchar()) != '\n')&#123;</span></span><br><span class="line">	<span class="comment">// 	inputArr.push_back(c);</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="built_in">string</span> input;</span><br><span class="line">	getline(<span class="built_in">cin</span>,input);</span><br><span class="line">	restoreIPAdrees(input,<span class="number">0</span>,res,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; restoreIpAddresses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(s.size() ==<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> res;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr;</span><br><span class="line">        restoreIPAdrees(s,<span class="number">0</span>,arr,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restoreIPAdrees</span><span class="params">(<span class="built_in">string</span>&amp; input,<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; arr,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 截至条件</span></span><br><span class="line">    	<span class="keyword">if</span>(level == <span class="number">4</span> || index &gt;= input.size())&#123;</span><br><span class="line">            <span class="comment">// 剪枝</span></span><br><span class="line">    		<span class="keyword">if</span>(level == <span class="number">4</span> &amp;&amp; index == input.size())&#123;</span><br><span class="line">    			<span class="built_in">string</span> tmp;</span><br><span class="line">    			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">    				tmp += arr[i];</span><br><span class="line">    				tmp += <span class="string">'.'</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    			tmp += arr[arr.size()<span class="number">-1</span>];</span><br><span class="line">    			res.push_back(tmp);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 遍历候选人</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; <span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index + i &gt; input.size())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    		<span class="built_in">string</span> s = input.substr(index,i);</span><br><span class="line">    		<span class="comment">//筛选</span></span><br><span class="line">            <span class="keyword">if</span>(stoi(s) &lt; <span class="number">256</span> &amp;&amp; (s == <span class="string">"0"</span> || s[<span class="number">0</span>] != <span class="string">'0'</span>))&#123;</span><br><span class="line">    			arr.push_back(s);</span><br><span class="line">    			restoreIPAdrees(input,index+i,arr,level+<span class="number">1</span>);</span><br><span class="line">    			arr.pop_back();</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode17-电话号码的字母组合"><a href="#LeetCode17-电话号码的字母组合" class="headerlink" title="LeetCode17:电话号码的字母组合"></a>LeetCode17:电话号码的字母组合</h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="/yangmiemie99.github.io/2020/02/25/LeetCode分类解题记录/%E7%94%B5%E8%AF%9D%E5%8F%B7.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//踩坑，不要用c语言的方式写了</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; m = &#123;</span><br><span class="line">        &#123;&#125;, &#123;&#125;,&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;,&#123;<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>&#125;,&#123;<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>&#125;,&#123;<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>&#125;,&#123;<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>&#125;,&#123;<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        dfs(digits,<span class="number">0</span>,tmp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; digits,<span class="keyword">int</span> index,<span class="built_in">string</span>&amp; tmp,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 截至条件</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.size() == digits.size())&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= digits.size())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//选出候选元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> &amp;a : m[digits[index] - <span class="string">'0'</span>])&#123;</span><br><span class="line">            tmp.push_back(a);</span><br><span class="line">            dfs(digits,index+<span class="number">1</span>,tmp,res);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-39-组合总和"><a href="#LeetCode-39-组合总和" class="headerlink" title="LeetCode 39 组合总和"></a>LeetCode 39 组合总和</h3><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.size() == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(candidates,tmp,target);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp,<span class="keyword">int</span> remain)</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 截止条件</span></span><br><span class="line">    	<span class="keyword">if</span>(remain &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(remain == <span class="number">0</span>)&#123;</span><br><span class="line">    			sort(tmp.begin(),tmp.end());</span><br><span class="line">    			<span class="comment">//重复的除去</span></span><br><span class="line">    			<span class="keyword">if</span>(find(res.begin(),res.end(),tmp) == res.end())</span><br><span class="line">    				res.push_back(tmp);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//候选元素遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> &amp; num: candidates)&#123;</span><br><span class="line">    		<span class="keyword">int</span> insertNum = num;</span><br><span class="line">    		tmp.push_back(insertNum);</span><br><span class="line">    		dfs(candidates,tmp,remain-num);</span><br><span class="line">    		tmp.pop_back();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//去重用了太久的时间</span></span><br><span class="line"><span class="comment">//观察树，找过的元素就不要向回找了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.size() == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(candidates,tmp,target,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp,<span class="keyword">int</span> remain,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 截止条件</span></span><br><span class="line">    	<span class="keyword">if</span>(remain &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(remain == <span class="number">0</span>)&#123;</span><br><span class="line">    			res.push_back(tmp);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//候选元素遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.size();++i)&#123;</span><br><span class="line">    		tmp.push_back(candidates[i]);</span><br><span class="line">            <span class="comment">//找过的不要向回找了，向本身和本省之后的元素找</span></span><br><span class="line">    		dfs(candidates,tmp,remain-candidates[i],i);</span><br><span class="line">    		tmp.pop_back();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode46-全排列"><a href="#LeetCode46-全排列" class="headerlink" title="LeetCode46:全排列"></a>LeetCode46:全排列</h3><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used(nums.size(),<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(nums,used,tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; used,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp)</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 截至条件</span></span><br><span class="line">    	<span class="keyword">if</span>(tmp.size() == nums.size())&#123;</span><br><span class="line">    		res.push_back(tmp);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 遍历候选节点</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size();++i)&#123;</span><br><span class="line">    		<span class="keyword">int</span> num = nums[i];</span><br><span class="line">    		<span class="comment">// 筛选</span></span><br><span class="line">    		<span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">    			tmp.push_back(num);</span><br><span class="line">    			used[i] = <span class="literal">true</span>;</span><br><span class="line">    			dfs(nums,used,tmp);</span><br><span class="line">    			tmp.pop_back();</span><br><span class="line">    			used[i] = <span class="literal">false</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="剑指Offer38字符串的排列"><a href="#剑指Offer38字符串的排列" class="headerlink" title="剑指Offer38字符串的排列"></a>剑指Offer38字符串的排列</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; permutation(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> length = s.size();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used(length,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        dfs(s,used,res,tmp,length,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; used,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res,<span class="built_in">string</span> tmp,<span class="keyword">int</span> length,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == length)&#123;</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;++i)&#123;</span><br><span class="line">            <span class="comment">// 这里要减枝，排序好的字符串，现字符与前字符相等，并且运行到当前现在字符</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; s[i<span class="number">-1</span>] == s[i] &amp;&amp; !used[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!used[i] )&#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                tmp += s[i];</span><br><span class="line">                dfs(s,used,res,tmp,length,index+<span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode47-全排列2"><a href="#LeetCode47-全排列2" class="headerlink" title="LeetCode47 全排列2"></a>LeetCode47 全排列2</h3><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span> , <span class="keyword">int</span>&gt; mElenmentNums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        	mElenmentNums[num]++;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 将元素存入数组，p 元素，pb对应元素个数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pb;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = mElenmentNums.begin(); i != mElenmentNums.end();++i)&#123;</span><br><span class="line">        	p.push_back(i -&gt; first);</span><br><span class="line">        	pb.push_back(i -&gt; second);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nums.size(),tmp,p,pb,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> size,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pb,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(size == tmp.size())&#123;</span><br><span class="line">    		res.push_back(tmp);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 遍历候选节点</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p.size();++i)&#123;</span><br><span class="line">    		<span class="keyword">int</span> insertNum = p[i];</span><br><span class="line">            <span class="comment">//数量为0筛选不用</span></span><br><span class="line">    		<span class="keyword">if</span>(pb[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    			pb[i]--;</span><br><span class="line">    			tmp.push_back(p[i]);</span><br><span class="line">    			dfs(size,tmp,p,pb,res);</span><br><span class="line">    			pb[i]++;</span><br><span class="line">    			tmp.pop_back();</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode22-括号生成"><a href="#LeetCode22-括号生成" class="headerlink" title="LeetCode22 括号生成"></a>LeetCode22 括号生成</h3><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; element = &#123;<span class="string">'('</span>,<span class="string">')'</span>&#125;;</span><br><span class="line">        dfs(n,element,tmp,n,n,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; element,<span class="built_in">string</span> &amp; tmp,<span class="keyword">int</span> count1,<span class="keyword">int</span> count2,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 截止条件</span></span><br><span class="line">    	<span class="keyword">if</span>(tmp.size() == <span class="number">2</span>*n)&#123;</span><br><span class="line">    		res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 遍历候选节点，筛选</span></span><br><span class="line">        <span class="keyword">if</span>(count1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            tmp.push_back(<span class="string">'('</span>);</span><br><span class="line">            count1--;</span><br><span class="line">            dfs(n,element,tmp,count1,count2,res);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            count1++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 反向括号剩下的数量和正括号相等的时候不能选</span></span><br><span class="line">        <span class="keyword">if</span>(count2 &gt; <span class="number">0</span> &amp;&amp; count1 != count2)&#123;</span><br><span class="line">            tmp.push_back(<span class="string">')'</span>);</span><br><span class="line">            count2--;</span><br><span class="line">            dfs(n,element,tmp,count1,count2,res);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>题目直接告诉我用dfs的</p>
<h2 id="标准树相关"><a href="#标准树相关" class="headerlink" title="标准树相关"></a>标准树相关</h2><h3 id="LeetCode100-相同的树"><a href="#LeetCode100-相同的树" class="headerlink" title="LeetCode100:相同的树"></a>LeetCode100:相同的树</h3><p>检查两个二差树是否相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 截止条件</span></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//候选节点，筛选</span></span><br><span class="line">        <span class="keyword">return</span> p -&gt; val == q -&gt; val &amp;&amp;</span><br><span class="line">        isSameTree(p -&gt; left,q -&gt; left) &amp;&amp;</span><br><span class="line">        isSameTree(p -&gt; right,q -&gt; right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode113-路径的总和"><a href="#Leetcode113-路径的总和" class="headerlink" title="Leetcode113 路径的总和"></a>Leetcode113 路径的总和</h3><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    sum -= root -&gt;val;</span><br><span class="line">    tmp.push_back(root -&gt;val);</span><br><span class="line">    dfs(root,sum,res,tmp);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> remain, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; tmp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>)</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 候选节点就是左右子节点</span></span><br><span class="line">    <span class="comment">// 筛选</span></span><br><span class="line">    <span class="keyword">if</span>(root -&gt; left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        tmp.push_back(root-&gt; left -&gt; val);</span><br><span class="line">        dfs(root -&gt; left,remain - root -&gt;left -&gt; val,res,tmp);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        tmp.push_back(root -&gt;right -&gt;val);</span><br><span class="line">        dfs(root -&gt; right,remain - root -&gt; right-&gt; val,res,tmp);</span><br><span class="line">        tmp.pop_back();            </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode129-叶子节点数字之和"><a href="#LeetCode129-叶子节点数字之和" class="headerlink" title="LeetCode129 叶子节点数字之和"></a>LeetCode129 叶子节点数字之和</h3><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        dfs(root,res,root -&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp; res, <span class="keyword">int</span> tmp)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 截止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res += tmp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 候选节点左右，筛选</span></span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            dfs(root-&gt;left,res,tmp*<span class="number">10</span> + root -&gt; left -&gt; val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            dfs(root-&gt;right,res,tmp*<span class="number">10</span> + root -&gt;right-&gt;val);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数组相关dfs"><a href="#数组相关dfs" class="headerlink" title="数组相关dfs"></a>数组相关dfs</h2><h3 id="LeetCode200-岛屿的数量"><a href="#LeetCode200-岛屿的数量" class="headerlink" title="LeetCode200 岛屿的数量"></a>LeetCode200 岛屿的数量</h3><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<p>输入:<br>11110<br>11010<br>11000<br>00000</p>
<p>输出: 1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.size();</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(cols == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; passed(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;cols; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span> &amp;&amp; passed[i][j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    dfs(grid,passed,rows,cols,i,j);</span><br><span class="line">                    res++;                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; passed,<span class="keyword">int</span>&amp; rows,<span class="keyword">int</span>&amp; cols,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 截至条件</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= rows || j &gt;=cols || i &lt;<span class="number">0</span> || j &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;       </span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">'0'</span> || passed[i][j] == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span> &amp;&amp; passed[i][j] == <span class="literal">false</span>)&#123;</span><br><span class="line">            passed[i][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上下左右遍历</span></span><br><span class="line">        dfs(grid,passed,rows,cols,i<span class="number">-1</span>,j);</span><br><span class="line">        dfs(grid,passed,rows,cols,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,passed,rows,cols,i,j<span class="number">-1</span>);</span><br><span class="line">        dfs(grid,passed,rows,cols,i,j+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="剑指Offer矩阵中的路径（时间复杂度？）"><a href="#剑指Offer矩阵中的路径（时间复杂度？）" class="headerlink" title="剑指Offer矩阵中的路径（时间复杂度？）"></a>剑指Offer矩阵中的路径（时间复杂度？）</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题超时，未解决，可能原因，遍历完成所有的路径？</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> rows = board.size();</span><br><span class="line">    	<span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">    	<span class="keyword">if</span>(cols == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; used(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="literal">false</span>));</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)&#123;</span><br><span class="line">    			<span class="keyword">if</span>(board[i][j] == word[<span class="number">0</span>])&#123;</span><br><span class="line">    				<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    				dfs(board,word,<span class="number">0</span>,used,rows,cols,i,j,flag);</span><br><span class="line">    				<span class="keyword">if</span>(flag == <span class="literal">true</span>)</span><br><span class="line">    					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word,<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; used,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">bool</span>&amp; flag)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 截至条件</span></span><br><span class="line">    <span class="keyword">if</span>(index == word.size()<span class="number">-1</span>)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt;<span class="number">0</span> || j &gt;=cols)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(board[i][j] != word[index])</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(used[i][j] == <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	used[i][j] = <span class="literal">true</span>;</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i+<span class="number">1</span>,j,flag);</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i<span class="number">-1</span>,j,flag);</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i,j+<span class="number">1</span>,flag);</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i,j<span class="number">-1</span>,flag);</span><br><span class="line">    used[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这样写就可以，思路相似啊？？？没想懂</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> rows = board.size();</span><br><span class="line">    	<span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">    	<span class="keyword">if</span>(cols == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; used(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols,<span class="literal">false</span>));</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)&#123;</span><br><span class="line">    			<span class="keyword">if</span>(board[i][j] == word[<span class="number">0</span>])&#123;</span><br><span class="line">    				<span class="keyword">if</span>(dfs(board,word,<span class="number">0</span>,used,rows,cols,i,j))</span><br><span class="line">    					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x =&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y = &#123;<span class="number">0.</span><span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word,<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; used,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 截至条件</span></span><br><span class="line">    <span class="keyword">if</span>(index == word.size())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt;<span class="number">0</span> || j &gt;=cols)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(board[i][j] != word[index])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(used[i][j] == <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	used[i][j] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">bool</span> res = dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i+<span class="number">1</span>,j) ||</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i<span class="number">-1</span>,j) ||</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i,j+<span class="number">1</span>) ||</span><br><span class="line">	dfs(board,word,index+<span class="number">1</span>,used,rows,cols,i,j<span class="number">-1</span>);</span><br><span class="line">    used[i][j] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指Offer-13-机器人的运动范围"><a href="#剑指Offer-13-机器人的运动范围" class="headerlink" title="剑指Offer 13. 机器人的运动范围"></a>剑指Offer 13. 机器人的运动范围</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(m &lt;<span class="number">0</span> || n &lt;<span class="number">0</span> || k &lt;<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; used(m,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">    	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    	dfs(m,n,k,<span class="number">0</span>,<span class="number">0</span>,used,count);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; used,<span class="keyword">int</span> &amp; count)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(i &gt;= m || j &gt;= n || i&lt;<span class="number">0</span> || j &lt;<span class="number">0</span> || numberBitSum(i,j) &gt; k)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">if</span>(used[i][j] == <span class="literal">true</span>)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	used[i][j] = <span class="literal">true</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    	dfs(m,n,k,i+<span class="number">1</span>,j,used,count);</span><br><span class="line">    	dfs(m,n,k,i<span class="number">-1</span>,j,used,count);</span><br><span class="line">    	dfs(m,n,k,i,j+<span class="number">1</span>,used,count);</span><br><span class="line">    	dfs(m,n,k,i,j<span class="number">-1</span>,used,count);</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberBitSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span>(i || j)&#123;</span><br><span class="line">    		sum += i %<span class="number">10</span>;</span><br><span class="line">    		sum += j %<span class="number">10</span>;    		</span><br><span class="line">    		i /= <span class="number">10</span>;</span><br><span class="line">    		j /= <span class="number">10</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h1><h2 id="剑指Offer05：替换空格"><a href="#剑指Offer05：替换空格" class="headerlink" title="剑指Offer05：替换空格"></a>剑指Offer05：替换空格</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.size();</span><br><span class="line">        <span class="built_in">string</span> output;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>)</span><br><span class="line">                output += <span class="string">"%20"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                output += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//不采取额外空间怎么做？</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> blankNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">                blankNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> *p = str + length;</span><br><span class="line">        <span class="keyword">char</span> *q = p + blankNum*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*p == <span class="string">' '</span>)&#123;</span><br><span class="line">                *q = <span class="string">'0'</span>;</span><br><span class="line">                q--;</span><br><span class="line">                *q = <span class="string">'2'</span>;</span><br><span class="line">                q--;</span><br><span class="line">                *q = <span class="string">'%'</span>;</span><br><span class="line">                q--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                *q = *p;</span><br><span class="line">                q--;</span><br><span class="line">            &#125;</span><br><span class="line">            p--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer17-打印从1到最大的n位数"><a href="#剑指Offer17-打印从1到最大的n位数" class="headerlink" title="剑指Offer17. 打印从1到最大的n位数"></a>剑指Offer17. 打印从1到最大的n位数</h2><p>难度简单12</p>
<p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大数问题，简单的方法我就不写了，直接dfs</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(n,<span class="string">'0'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        	s[<span class="number">0</span>] = <span class="string">'0'</span> + i;</span><br><span class="line">	        dfs(s,n,<span class="number">0</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="keyword">int</span> n,<span class="keyword">int</span> level,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(level == n <span class="number">-1</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">int</span> sNum = chageStringToNum(s);</span><br><span class="line">            <span class="keyword">if</span>(sNum == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">    		res.push_back(sNum);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	level++;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line">    		s[level] = <span class="string">'0'</span> + i;</span><br><span class="line">    		dfs(s,n,level,res);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将字符串转为数字，记得忽略零</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">chageStringToNum</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> sLen = s.size();</span><br><span class="line">        <span class="keyword">bool</span> isBeginFlag = <span class="literal">false</span>;</span><br><span class="line">    	<span class="keyword">int</span> sNum = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; sLen;++i)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(s[i] == <span class="string">'0'</span> &amp;&amp; !isBeginFlag)</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                isBeginFlag = <span class="literal">true</span>;</span><br><span class="line">    		<span class="keyword">if</span>(isBeginFlag)&#123;</span><br><span class="line">    			sNum *= <span class="number">10</span>;</span><br><span class="line">    			sNum += (s[i] - <span class="string">'0'</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> sNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>做法2 全部按照字符串思考</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    	<span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(n,<span class="string">'0'</span>)</span></span>;</span><br><span class="line">    	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//溢出直接返回false</span></span><br><span class="line">    	<span class="keyword">while</span>(increse(s))&#123;</span><br><span class="line">    		<span class="keyword">int</span> sNum = chageStringToNum(s);</span><br><span class="line">    		<span class="keyword">if</span>(sNum != <span class="number">0</span>)</span><br><span class="line">    			res.push_back(sNum);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">increse</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//进位</span></span><br><span class="line">    	<span class="keyword">int</span> overflow = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> sLen = s.size();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = sLen <span class="number">-1</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">int</span> sNum = s[i] -<span class="string">'0'</span> + overflow;</span><br><span class="line">    		<span class="keyword">if</span>(i == sLen <span class="number">-1</span>)</span><br><span class="line">    			sNum++;</span><br><span class="line">    		<span class="keyword">if</span>(sNum == <span class="number">10</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="comment">//0号不能进位了，最大溢出了</span></span><br><span class="line">    			<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">    				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    			<span class="keyword">else</span>&#123;</span><br><span class="line">                    sNum -=<span class="number">10</span>;</span><br><span class="line">                    s[i] = <span class="string">'0'</span> + sNum;</span><br><span class="line">    				overflow = <span class="number">1</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">else</span>&#123;</span><br><span class="line">    			s[i] = <span class="string">'0'</span> + sNum;</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将字符串转为数字，记得忽略零</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">chageStringToNum</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> sLen = s.size();</span><br><span class="line">        <span class="keyword">bool</span> isBeginFlag = <span class="literal">false</span>;</span><br><span class="line">    	<span class="keyword">int</span> sNum = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; sLen;++i)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(s[i] == <span class="string">'0'</span> &amp;&amp; !isBeginFlag)</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                isBeginFlag = <span class="literal">true</span>;</span><br><span class="line">    		<span class="keyword">if</span>(isBeginFlag)&#123;</span><br><span class="line">    			sNum *= <span class="number">10</span>;</span><br><span class="line">    			sNum += (s[i] - <span class="string">'0'</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> sNum;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer20-表示数值的字符串"><a href="#剑指Offer20-表示数值的字符串" class="headerlink" title="剑指Offer20 表示数值的字符串**"></a>剑指Offer20 表示数值的字符串**</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”及”-1E-16”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//去除后向空格</span></span><br><span class="line">    	<span class="keyword">int</span> sLen = s.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(sLen - <span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; s[sLen <span class="number">-1</span>] == <span class="string">' '</span>)&#123;</span><br><span class="line">            sLen--;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">if</span>(sLen == <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    	<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//去除前向空格</span></span><br><span class="line">        <span class="keyword">while</span>(pos &lt;= sLen &amp;&amp; s[pos] == <span class="string">' '</span>)</span><br><span class="line">            pos++;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">bool</span> numeric = scanSignedInteger(s,sLen,pos);</span><br><span class="line">    	<span class="keyword">if</span>(s[pos] == <span class="string">'.'</span>)&#123;</span><br><span class="line">    		++pos;</span><br><span class="line">    		<span class="comment">// .之前可以没有数，小数点之后可以没有数</span></span><br><span class="line">    		numeric = scanUnsignedInteger(s,sLen,pos) || numeric;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(pos &lt; sLen &amp;&amp; s[pos] == <span class="string">'e'</span> || s[pos] == <span class="string">'E'</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		pos++;</span><br><span class="line">    		numeric = numeric &amp;&amp; scanSignedInteger(s,sLen,pos);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> numeric &amp;&amp; (pos == sLen);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> sLen,<span class="keyword">int</span> &amp; pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> before = pos;</span><br><span class="line">    	<span class="keyword">while</span>(pos &lt; sLen &amp;&amp; s[pos] &gt;= <span class="string">'0'</span> &amp;&amp; s[pos] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">    		pos++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> pos &gt; before;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">scanSignedInteger</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> sLen,<span class="keyword">int</span> &amp; pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(s[pos] == <span class="string">'+'</span> || s[pos] == <span class="string">'-'</span>)</span><br><span class="line">	    	pos++;</span><br><span class="line">    	<span class="keyword">return</span> scanUnsignedInteger(s,sLen,pos);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer-19-正则表达式"><a href="#剑指Offer-19-正则表达式" class="headerlink" title="剑指Offer 19 正则表达式"></a>剑指Offer 19 正则表达式</h2><p>请实现一个函数用来匹配包含’. ‘和’ * ‘的正则表达式。模式中的字符’.’表示任意一个字符，而’ * ‘  表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab * a * a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<h3 id="思路1：-递归写法"><a href="#思路1：-递归写法" class="headerlink" title="思路1： 递归写法"></a>思路1： 递归写法</h3><ul>
<li>当 pattern中的字符不是‘ * ’ 的时候<ul>
<li>当str中第一个字符与pattern中第一个字符相匹配，str和pattern后移一位</li>
<li>否则直接返回false</li>
</ul>
</li>
<li>当pattern中出现的第二个字符是‘ * ’的时候<ul>
<li>如果str中的第一个字符与pattern中的第一个字符不匹配的时候，相当于*前的字符出现了0次，pattern+=2然后继续匹配。</li>
<li>如果str中第一个字符与pattern中第一个字符相匹配之后，有以下三种情况。<ul>
<li>pattern后移两位，str后移一位，相当于之前的字符不再出现。</li>
<li>pattern不动，str后移一位，相当于之前的字符重复出现</li>
<li>pattern后移两位，str不变，相当于匹配到了也不要，因为已有的字符就足够。例子 ‘aa’     ‘ a * aa’ 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size() == <span class="number">0</span> &amp;&amp; p.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isMatch(s,p,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="built_in">string</span>&amp; p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == s.size() &amp;&amp; j == p.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i != s.size() &amp;&amp; j == p.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 下一个字符是*</span></span><br><span class="line">    <span class="keyword">if</span>(j+<span class="number">1</span> &lt; p.size() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != s.size() &amp;&amp; (p[j] == s[i] || p[j] == <span class="string">'.'</span>))</span><br><span class="line">                <span class="comment">//之前的字符重复出现</span></span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p,i+<span class="number">1</span>,j) </span><br><span class="line">                <span class="comment">// 不需要匹配当前字符</span></span><br><span class="line">                || isMatch(s,p,i,j+<span class="number">2</span>)</span><br><span class="line">                <span class="comment">// 之前的字符不再出现</span></span><br><span class="line">                || isMatch(s,p,i+<span class="number">1</span>,j+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 不匹配，跳过</span></span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p,i,j+<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(i != s.size() &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'.'</span>))</span><br><span class="line">        <span class="keyword">return</span> isMatch(s,p,i+<span class="number">1</span>,j+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;            </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer-43-1～n整数中1出现的次数"><a href="#剑指Offer-43-1～n整数中1出现的次数" class="headerlink" title="剑指Offer 43. 1～n整数中1出现的次数**"></a>剑指Offer 43. 1～n整数中1出现的次数**</h2><p>输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p>思路：</p>
<p>将数字转化为字符串之后拆分为三部分</p>
<p>第一个数字出现1的个数</p>
<ul>
<li>如果不为1,则出现的次数为 10^（当前字符串的长度 -1)</li>
<li>如果为1，则为去掉当前的1后续字符串的数字大小+1（e.g 0-123，一共124个数值，对应124个1）</li>
</ul>
<p>第一个数字之外的1的个数</p>
<ul>
<li>第一个数值 × pow(10,length -2) ×length-1，一个数字不东，其余数字0-9随便</li>
</ul>
<p>去掉第一个数字其余的数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;=<span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s = to_string(n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    countDigitOne(s,<span class="number">0</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countDigitOne</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="keyword">int</span> index,<span class="keyword">int</span>&amp; sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> indexNum = s[index] - <span class="string">'0'</span>;</span><br><span class="line">	<span class="keyword">int</span> length = s.size() - index;</span><br><span class="line">	<span class="keyword">if</span>(indexNum == <span class="number">0</span> &amp;&amp; length == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(indexNum &gt; <span class="number">0</span> &amp;&amp; length == <span class="number">1</span>)&#123;</span><br><span class="line">		sum += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(indexNum &gt; <span class="number">1</span>)</span><br><span class="line">		sum += <span class="built_in">pow</span>(<span class="number">10</span>,length<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(indexNum == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">string</span> ss = s.substr(index+<span class="number">1</span>);</span><br><span class="line">		sum += (stoi(ss) +<span class="number">1</span>);            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 剩下的数字除了第一位之外含有的1</span></span><br><span class="line">	sum += indexNum * (length <span class="number">-1</span>) * <span class="built_in">pow</span>(<span class="number">10</span>,length <span class="number">-2</span>);</span><br><span class="line">	<span class="comment">// 递归</span></span><br><span class="line">	countDigitOne(s,index+<span class="number">1</span>,sum);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer44-数字序列中某一位的数字"><a href="#剑指Offer44-数字序列中某一位的数字" class="headerlink" title="剑指Offer44. 数字序列中某一位的数字"></a>剑指Offer44. 数字序列中某一位的数字</h2><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
<p>思路：</p>
<p>分析： 按照位划分数字的个数</p>
<p>1位数 0-9 数字的个数：10</p>
<p>2位数 10-99 数字的个数：2 × 9 × 10 = 180</p>
<p>3位数字 100 - 999 数字的个数 3 × 9 × 100 = 2700</p>
<p>发现规律 大于一位的数i 个数为 i × 9 × pow(10,i-1);</p>
<p>假设数字为1001，那么我们要先找到该数字处在的区间到底是几位数</p>
<p>1001 - 10 = 991 &gt; 0 不是1位数字</p>
<p>991 - 180 = 811 &gt; 0 不是两位数字</p>
<p>881 - 2700 &lt; 0 是三位数字中的1位</p>
<p>计算 881/3 = 270余1 ，所以对应的数字为270+100 = 370， 余1对应数字为7</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> remainNum = n;</span><br><span class="line">	<span class="comment">// 定位在哪个范围</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">int</span> nowNum = countDigitNum(digit);</span><br><span class="line">		<span class="keyword">if</span>(remainNum &lt; nowNum)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			remainNum -= nowNum;</span><br><span class="line">			digit++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定位具体数字</span></span><br><span class="line">	<span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(digit == <span class="number">1</span>)</span><br><span class="line">		number += remainNum;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		number += remainNum/digit + <span class="built_in">pow</span>(<span class="number">10</span>,digit <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">// 计算偏移量,从右到左</span></span><br><span class="line">	<span class="keyword">int</span> offset = digit - remainNum % digit;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; offset;++i)&#123;</span><br><span class="line">		number /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">countDigitNum</span><span class="params">(<span class="keyword">int</span> digit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(digit == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> digit * <span class="number">9</span> * <span class="built_in">pow</span>(<span class="number">10</span>,digit <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer45-把数组排成最小的数"><a href="#剑指Offer45-把数组排成最小的数" class="headerlink" title="剑指Offer45. 把数组排成最小的数"></a>剑指Offer45. 把数组排成最小的数</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>对vector中的数据进行排序将数字转化为字符串，两个数字m,n如果mn &lt; nm 那么m应该排在前面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end(),[](<span class="keyword">const</span> <span class="keyword">int</span>&amp; left,<span class="keyword">const</span> <span class="keyword">int</span>&amp; right)</span><br><span class="line">             &#123;<span class="keyword">return</span> to_string(left)+to_string(right) &lt; to_string(right) + to_string(left);&#125;);</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; nums.size();++i)&#123;</span><br><span class="line">            s += to_string(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer46-把数字翻译成字符串-dfs或者动态规划"><a href="#剑指Offer46-把数字翻译成字符串-dfs或者动态规划" class="headerlink" title="剑指Offer46. 把数字翻译成字符串(dfs或者动态规划)"></a>剑指Offer46. 把数字翻译成字符串(dfs或者动态规划)</h2><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(num &lt;<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> countTrans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        dfs(s,countTrans,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> countTrans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="keyword">int</span>&amp; countTrans,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(index == s.size())&#123;</span><br><span class="line">    		countTrans++;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt;=<span class="number">2</span>; ++i)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(index+i &gt; s.size())</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    		<span class="built_in">string</span> tmp = s.substr(index,i);</span><br><span class="line">    		<span class="keyword">int</span> tmpNum = stoi(tmp);</span><br><span class="line">    		<span class="keyword">if</span>(tmpNum &lt;= <span class="number">25</span> )&#123;</span><br><span class="line">                <span class="comment">//当是十位数，第一个数字不能为0</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">2</span> &amp;&amp; tmp[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    			dfs(s,countTrans,index+i);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>动态规划写法</p>
<p>我们定义f(i)表示从第i位开始的不同翻译数目，那么状态转移方程可以写为</p>
<p>f(i) = f(i+1) + g(i,i+1)*f(i+2)，当第i位和第i+1位拼接在一起的时候数值在10—25的范围内的时候g(i,i+1)为1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(num &lt;<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">string</span> s = to_string(num);</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSum(s.size());</span><br><span class="line">    	translateNum(s,countSum);</span><br><span class="line">    	<span class="keyword">return</span> countSum[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">translateNum</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; countSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> length = s.size();</span><br><span class="line">    	countSum[length<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = length<span class="number">-2</span>; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">    		<span class="keyword">int</span> tmpSum = <span class="number">10</span> * (s[i] - <span class="string">'0'</span>) + s[i+<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    		<span class="keyword">if</span>(tmpSum &gt;=<span class="number">10</span> &amp;&amp; tmpSum &lt;=<span class="number">25</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">                <span class="comment">//特殊情况后续只有一个数字</span></span><br><span class="line">    			<span class="keyword">if</span>(i == length<span class="number">-2</span>)</span><br><span class="line">    				countSum[i] = countSum[i+<span class="number">1</span>] +<span class="number">1</span>;</span><br><span class="line">    			<span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//将后面两组和相加，代表但前可以取值1位或者两位</span></span><br><span class="line">    				countSum[i] = countSum[i+<span class="number">1</span>] +countSum[i+<span class="number">2</span>];</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    			countSum[i] = countSum[i+<span class="number">1</span>];</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer58-I-翻转单词顺序"><a href="#剑指Offer58-I-翻转单词顺序" class="headerlink" title="剑指Offer58 - I. 翻转单词顺序"></a>剑指Offer58 - I. 翻转单词顺序</h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<h3 id="思路1-先整体反转在逐个单词反转"><a href="#思路1-先整体反转在逐个单词反转" class="headerlink" title="思路1,先整体反转在逐个单词反转"></a>思路1,先整体反转在逐个单词反转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> length = s.size();</span><br><span class="line">    	<span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> s;</span><br><span class="line">    	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> right = length <span class="number">-1</span>;</span><br><span class="line">    	reverse(s.begin(),s.end());</span><br><span class="line">    	<span class="keyword">int</span> leftWord = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> rightWord = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span>(leftWord &lt;= length<span class="number">-1</span>)&#123;</span><br><span class="line">    		<span class="keyword">while</span>(leftWord != length &amp;&amp; s[leftWord] == <span class="string">' '</span>)</span><br><span class="line">    			++leftWord;</span><br><span class="line">    		rightWord = leftWord;</span><br><span class="line">    		<span class="keyword">while</span>(rightWord != length &amp;&amp; s[rightWord] != <span class="string">' '</span>)</span><br><span class="line">    			++rightWord;</span><br><span class="line">            <span class="comment">//左闭合右开，所以rightWord的下标为空格的下标</span></span><br><span class="line">           ord</span><br><span class="line">    		reverse(s.begin()+leftWord,s.begin()+rightWord);</span><br><span class="line">    		leftWord = rightWord+<span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//去除开始和结尾的字符</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; s.size() &amp;&amp; s[left] == <span class="string">' '</span>)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span>(right &gt;=<span class="number">0</span> &amp;&amp; s[right] == <span class="string">' '</span>)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="comment">//去除中间多余的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">' '</span>)</span><br><span class="line">                res.push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>] != <span class="string">' '</span>)</span><br><span class="line">                res.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不利用额外空间，原地反转</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    	reverse(s.begin(),s.end());</span><br><span class="line">    	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> right = s.size()<span class="number">-1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(left &lt; s.size() &amp;&amp; s[left] == <span class="string">' '</span>)&#123;</span><br><span class="line">    		left++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">while</span>(right &gt;=<span class="number">0</span> &amp;&amp; s[right] == <span class="string">' '</span>)&#123;</span><br><span class="line">    		right--;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">int</span> ltmp = left;</span><br><span class="line">    	<span class="keyword">while</span>(ltmp &lt;= right)&#123;</span><br><span class="line">    		<span class="keyword">while</span>(ltmp &lt;= right &amp;&amp; s[ltmp]== <span class="string">' '</span>)</span><br><span class="line">    			ltmp++;</span><br><span class="line">    		<span class="keyword">int</span> rtmp = ltmp;</span><br><span class="line">    		<span class="keyword">while</span>(rtmp &lt;= right &amp;&amp; s[rtmp] != <span class="string">' '</span>)</span><br><span class="line">    			rtmp++;</span><br><span class="line">    		reverse(s.begin()+ltmp,s.begin()+rtmp);</span><br><span class="line">    		ltmp = rtmp;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 去除中间空格</span></span><br><span class="line">    	<span class="keyword">int</span> begin = left;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(s[i] == <span class="string">' '</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">' '</span>)</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		s[begin++] = s[i];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> s.substr(left , begin - left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-利用sstream"><a href="#思路2-利用sstream" class="headerlink" title="思路2 利用sstream"></a>思路2 利用sstream</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmpVec;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; tmp)&#123;</span><br><span class="line">            tmpVec.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = tmpVec.size()<span class="number">-1</span>; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            res += tmpVec[i] + <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = res.size();</span><br><span class="line">        <span class="keyword">return</span> res.substr(<span class="number">0</span>,length<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer58-II-左旋转字符串"><a href="#剑指Offer58-II-左旋转字符串" class="headerlink" title="剑指Offer58 - II. 左旋转字符串"></a>剑指Offer58 - II. 左旋转字符串</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单利用substr直接解决</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= s.size())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">string</span> tmp = s.substr(<span class="number">0</span>,n);</span><br><span class="line">        res = s.substr(n) + tmp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 两次反转解决</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.size();</span><br><span class="line">        <span class="keyword">int</span> remian = s.size() - n;</span><br><span class="line">        reverse(s.begin(),s.end());</span><br><span class="line">        reverse(s.begin(),s.begin()+remian);</span><br><span class="line">        reverse(s.begin()+remian,s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer67-把字符串转换成整数"><a href="#剑指Offer67-把字符串转换成整数" class="headerlink" title="剑指Offer67. 把字符串转换成整数"></a>剑指Offer67. 把字符串转换成整数</h2><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">int</span> sLen = str.size();</span><br><span class="line">  		<span class="keyword">if</span>(sLen == <span class="number">0</span>)</span><br><span class="line">  			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		<span class="comment">// 去除空格</span></span><br><span class="line">  		<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  		<span class="keyword">while</span>(start &lt; sLen &amp;&amp; str[start] == <span class="string">' '</span>)</span><br><span class="line">  		&#123;</span><br><span class="line">  			start++;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="comment">//判断是不是负数</span></span><br><span class="line">  		<span class="keyword">bool</span> flagPosOrNeg = <span class="literal">true</span>;</span><br><span class="line">  		<span class="keyword">if</span>(start &lt; sLen)&#123;</span><br><span class="line">  			<span class="keyword">if</span>(str[start] == <span class="string">'+'</span>)&#123;</span><br><span class="line">  				start++;</span><br><span class="line">  				flagPosOrNeg = <span class="literal">true</span>;</span><br><span class="line">  			&#125;</span><br><span class="line">  			<span class="keyword">else</span> <span class="keyword">if</span>(str[start] == <span class="string">'-'</span>)&#123;</span><br><span class="line">  				start++;</span><br><span class="line">  				flagPosOrNeg = <span class="literal">false</span>;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="comment">//取出对应的数转化</span></span><br><span class="line">  		<span class="keyword">int</span> number = unSignedStrToInt(str,start,flagPosOrNeg);      </span><br><span class="line"></span><br><span class="line">  		<span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unSignedStrToInt</span><span class="params">(<span class="built_in">string</span> &amp; str,<span class="keyword">int</span> start,<span class="keyword">bool</span> flagPosOrNeg)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> startTmp = start;</span><br><span class="line">    	<span class="keyword">if</span>(start &gt;= str.size())&#123;</span><br><span class="line">    		valid = <span class="literal">false</span>;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">long</span> <span class="keyword">int</span> totalNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = flagPosOrNeg ? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(startTmp &lt; str.size() &amp;&amp; str[startTmp] &gt;= <span class="string">'0'</span> &amp;&amp; str[startTmp] &lt;=<span class="string">'9'</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		totalNum = totalNum * <span class="number">10</span> + flag * (str[startTmp++] - <span class="string">'0'</span>);</span><br><span class="line">    		<span class="keyword">if</span>(flagPosOrNeg == <span class="literal">true</span> &amp;&amp; totalNum &gt; numeric_limits&lt;<span class="keyword">int</span>&gt;::max())&#123;</span><br><span class="line">    			totalNum = numeric_limits&lt;<span class="keyword">int</span>&gt;::max();</span><br><span class="line">    			valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(flagPosOrNeg == <span class="literal">false</span> &amp;&amp; totalNum &lt; numeric_limits&lt;<span class="keyword">int</span>&gt;::min())&#123;</span><br><span class="line">    			valid = <span class="literal">false</span>;</span><br><span class="line">    			totalNum = numeric_limits&lt;<span class="keyword">int</span>&gt;::min();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span>(startTmp == start)&#123;</span><br><span class="line">    		valid = <span class="literal">false</span>;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> (<span class="keyword">int</span>)totalNum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="剑指Offer-15-二进制中1的个数"><a href="#剑指Offer-15-二进制中1的个数" class="headerlink" title="剑指Offer 15. 二进制中1的个数"></a>剑指Offer 15. 二进制中1的个数</h2><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag &amp; n)</span><br><span class="line">            count++;</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>将n减1，那么得到的数就是n的最后一个1变为0，这个1之后的bit变为1，将两个数想与，那么将两个数字想与，得到的数字就是去掉最后一个1的数字。那么经过<strong>几次减操作在相与</strong>就有几个1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n = n &amp; (n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer65-不用加减乘除做加法"><a href="#剑指Offer65-不用加减乘除做加法" class="headerlink" title="剑指Offer65. 不用加减乘除做加法"></a>剑指Offer65. 不用加减乘除做加法</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 整体和进位</span></span><br><span class="line">        <span class="keyword">int</span> sum,carry;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//不考虑进位</span></span><br><span class="line">            sum = a ^ b;</span><br><span class="line">            <span class="comment">//进位</span></span><br><span class="line">            carry = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;<span class="keyword">while</span>(b != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="优化时间效率"><a href="#优化时间效率" class="headerlink" title="优化时间效率"></a>优化时间效率</h1><h2 id="剑指Offer49-丑数"><a href="#剑指Offer49-丑数" class="headerlink" title="剑指Offer49. 丑数"></a>剑指Offer49. 丑数</h2><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;=<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> uglyCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(uglyCount &lt; n)&#123;</span><br><span class="line">        	<span class="keyword">while</span>(!isUglyNumber(++i))&#123;&#125;</span><br><span class="line">        	uglyCount++;</span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    		n /=<span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">while</span>(n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">    		n/=<span class="number">3</span>;</span><br><span class="line">    	<span class="keyword">while</span>(n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">    		n /=<span class="number">5</span>;</span><br><span class="line">    	<span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之前的丑数乘2,3,5里最小的就是新的丑数，2,3,5系数乘的位置要大于最后丑数的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uglyNums(n,<span class="number">0</span>);</span><br><span class="line">    	uglyNums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> m2 = <span class="number">0</span>,m3=<span class="number">0</span>,m5=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> nextUgly = <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(nextUgly &lt; n)&#123;</span><br><span class="line">    		<span class="keyword">int</span> min = min3(uglyNums[m2]*<span class="number">2</span>,uglyNums[m3]*<span class="number">3</span>,uglyNums[m5]*<span class="number">5</span>);</span><br><span class="line">    		uglyNums[nextUgly] = min;</span><br><span class="line">    		<span class="keyword">while</span>(uglyNums[m2]*<span class="number">2</span> &lt;= min)</span><br><span class="line">    			m2++;</span><br><span class="line">    		<span class="keyword">while</span>(uglyNums[m3]*<span class="number">3</span> &lt;= min)</span><br><span class="line">    			m3++;</span><br><span class="line">    		<span class="keyword">while</span>(uglyNums[m5]*<span class="number">5</span> &lt;= min)</span><br><span class="line">    			m5++;</span><br><span class="line">    		nextUgly++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> uglyNums[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min3</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> min = (a &lt; b) ? a:b;</span><br><span class="line">    	<span class="keyword">return</span> (min &lt; c)? min :c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/yangmiemie99.github.io/tags/剑指Offer/" rel="tag"># 剑指Offer</a>
          
            <a href="/yangmiemie99.github.io/tags/算法/" rel="tag"># 算法</a>
          
            <a href="/yangmiemie99.github.io/tags/数据结构/" rel="tag"># 数据结构</a>
          
            <a href="/yangmiemie99.github.io/tags/LeetCode/" rel="tag"># LeetCode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/yangmiemie99.github.io/2020/02/25/计算机网络/" rel="next" title="计算机网络总结">
                <i class="fa fa-chevron-left"></i> 计算机网络总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/yangmiemie99.github.io/2020/03/08/GIT使用总结/" rel="prev" title="GIT使用总结">
                GIT使用总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/yangmiemie99.github.io/images/touxiang.jpeg" alt="Yang MieMie">
            
              <p class="site-author-name" itemprop="name">Yang MieMie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/yangmiemie99.github.io/archives/">
              
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/yangmiemie99.github.io/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/yangmiemie99.github.io/tags/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yangmiemie99" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer题目3：找出数组中重复的数字。"><span class="nav-number">1.1.</span> <span class="nav-text">剑指Offer题目3：找出数组中重复的数字。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer题目4：二维数组中的查找"><span class="nav-number">1.2.</span> <span class="nav-text">剑指Offer题目4：二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路"><span class="nav-number">1.2.1.</span> <span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer29-顺时针打印数组"><span class="nav-number">1.3.</span> <span class="nav-text">剑指Offer29:顺时针打印数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer53-在排序数组中查找数字"><span class="nav-number">1.4.</span> <span class="nav-text">剑指Offer53:在排序数组中查找数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路："><span class="nav-number">1.4.1.</span> <span class="nav-text">思路：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer53-0-n-1中缺失的数字"><span class="nav-number">1.5.</span> <span class="nav-text">剑指Offer53:0-n-1中缺失的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路：-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">思路：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer11-旋转数组的最小数字"><span class="nav-number">1.6.</span> <span class="nav-text">剑指Offer11. 旋转数组的最小数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer21-调整数组顺序使奇数位于偶数前"><span class="nav-number">1.7.</span> <span class="nav-text">剑指Offer21. 调整数组顺序使奇数位于偶数前</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer-39-数组中出现次数超过一半的数字"><span class="nav-number">1.8.</span> <span class="nav-text">剑指Offer 39. 数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题51-数组中逆序对"><span class="nav-number">1.9.</span> <span class="nav-text">面试题51 数组中逆序对</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查找表"><span class="nav-number">2.</span> <span class="nav-text">查找表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#两类查找问题"><span class="nav-number">2.1.</span> <span class="nav-text">两类查找问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer50-第一个只出现一次的字符"><span class="nav-number">2.2.</span> <span class="nav-text">剑指Offer50:第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer48-最长不含重复的子字符串××××"><span class="nav-number">2.3.</span> <span class="nav-text">剑指Offer48:最长不含重复的子字符串××××</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode349-两个数组的交集"><span class="nav-number">2.4.</span> <span class="nav-text">LeetCode349:两个数组的交集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode350-两个数组的交集"><span class="nav-number">2.5.</span> <span class="nav-text">LeetCode350 两个数组的交集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map默认值"><span class="nav-number">2.6.</span> <span class="nav-text">Map默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#底层实现"><span class="nav-number">2.7.</span> <span class="nav-text">底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据顺序型的作用"><span class="nav-number">2.8.</span> <span class="nav-text">数据顺序型的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode有效的字母异位词"><span class="nav-number">2.9.</span> <span class="nav-text">LeetCode有效的字母异位词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-290单词规律（花费时间长）"><span class="nav-number">2.10.</span> <span class="nav-text">LeetCode 290单词规律（花费时间长）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路：-2"><span class="nav-number">2.10.1.</span> <span class="nav-text">思路：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表"><span class="nav-number">3.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建链表，打印链表"><span class="nav-number">3.1.</span> <span class="nav-text">创建链表，打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer18，删除链表的节点"><span class="nav-number">3.2.</span> <span class="nav-text">剑指Offer18，删除链表的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer面试题22：链表中倒数第k个节点"><span class="nav-number">3.3.</span> <span class="nav-text">剑指Offer面试题22：链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer24-反转链表"><span class="nav-number">3.4.</span> <span class="nav-text">剑指Offer24:反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路：定义三个指针解决问题"><span class="nav-number">3.4.1.</span> <span class="nav-text">思路：定义三个指针解决问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode92-反转链表2"><span class="nav-number">3.5.</span> <span class="nav-text">LeetCode92:反转链表2 ****</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer35-复杂链表的复制"><span class="nav-number">3.6.</span> <span class="nav-text">剑指Offer35:复杂链表的复制**</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路：-3"><span class="nav-number">3.6.1.</span> <span class="nav-text">思路：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer25-合并两个排序的链表"><span class="nav-number">3.7.</span> <span class="nav-text">剑指Offer25. 合并两个排序的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer52-两个链表的第一个公共节点"><span class="nav-number">3.8.</span> <span class="nav-text">剑指Offer52:两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode83删除排序链表中的重复元素"><span class="nav-number">3.9.</span> <span class="nav-text">LeetCode83删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode86-分离链表××××××××××"><span class="nav-number">3.10.</span> <span class="nav-text">LeetCode86:分离链表××××××××××</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer6从头到尾打印链表"><span class="nav-number">3.11.</span> <span class="nav-text">剑指Offer6从头到尾打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer36-二叉搜索树与双向链表"><span class="nav-number">3.12.</span> <span class="nav-text">剑指Offer36. 二叉搜索树与双向链表**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode141-环形链表-给定一个链表，判断链表中是否有环。"><span class="nav-number">3.13.</span> <span class="nav-text">LeetCode141. 环形链表]给定一个链表，判断链表中是否有环。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode142-环形链表2"><span class="nav-number">3.14.</span> <span class="nav-text">LeetCode142 环形链表2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer62-圆圈中最后剩下的数字"><span class="nav-number">3.15.</span> <span class="nav-text">剑指Offer62. 圆圈中最后剩下的数字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#栈和队列"><span class="nav-number">4.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈"><span class="nav-number">4.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列"><span class="nav-number">4.2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer09-用两个栈实现队列"><span class="nav-number">4.3.</span> <span class="nav-text">剑指Offer09 用两个栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer30-包含min函数的栈"><span class="nav-number">4.4.</span> <span class="nav-text">剑指Offer30:包含min函数的栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer59-滑动串口的最大值"><span class="nav-number">4.5.</span> <span class="nav-text">剑指Offer59 滑动串口的最大值* ** ** * *** *</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer59队列的最大值"><span class="nav-number">4.6.</span> <span class="nav-text">剑指Offer59队列的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer-31-栈的压入、弹出序列"><span class="nav-number">4.7.</span> <span class="nav-text">剑指Offer 31. 栈的压入、弹出序列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#优先队列（堆）"><span class="nav-number">5.</span> <span class="nav-text">优先队列（堆）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer40-最小的k个数"><span class="nav-number">5.1.</span> <span class="nav-text">剑指Offer40:最小的k个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer41-数据流中的中位数"><span class="nav-number">5.2.</span> <span class="nav-text">剑指Offer41:数据流中的中位数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树"><span class="nav-number">6.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer34-二差树中和为某一值的路径×××××"><span class="nav-number">6.1.</span> <span class="nav-text">剑指Offer34 二差树中和为某一值的路径×××××</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#后序遍历，非递归实现。"><span class="nav-number">6.1.1.</span> <span class="nav-text">后序遍历，非递归实现。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深度优先搜素，递归实现"><span class="nav-number">6.1.2.</span> <span class="nav-text">深度优先搜素，递归实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer54-二叉搜索树的第k大节点"><span class="nav-number">6.2.</span> <span class="nav-text">剑指Offer54:二叉搜索树的第k大节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中序遍历"><span class="nav-number">6.2.1.</span> <span class="nav-text">中序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer32-从上到下打印二叉树"><span class="nav-number">6.3.</span> <span class="nav-text">剑指Offer32: 从上到下打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#层序遍历"><span class="nav-number">6.3.1.</span> <span class="nav-text">层序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer07-重建二叉树-××"><span class="nav-number">6.4.</span> <span class="nav-text">剑指Offer07 重建二叉树 ××</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer37-序列化二差树"><span class="nav-number">6.5.</span> <span class="nav-text">剑指Offer37 序列化二差树  **  ** **</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer68-二叉搜索数的最近公共祖先"><span class="nav-number">6.6.</span> <span class="nav-text">剑指Offer68 二叉搜索数的最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指26Offer-树的子结构"><span class="nav-number">6.7.</span> <span class="nav-text">剑指26Offer. 树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer55-1-二叉树的深度"><span class="nav-number">6.8.</span> <span class="nav-text">剑指Offer55-1 二叉树的深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer55-2-平衡二叉树"><span class="nav-number">6.9.</span> <span class="nav-text">剑指Offer55-2 平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer27-二叉树的镜像"><span class="nav-number">6.10.</span> <span class="nav-text">剑指Offer27 二叉树的镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer28-对称的二差树"><span class="nav-number">6.11.</span> <span class="nav-text">剑指Offer28 对称的二差树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer33-二叉搜索树的后序遍历序列"><span class="nav-number">6.12.</span> <span class="nav-text">剑指Offer33. 二叉搜索树的后序遍历序列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#递归"><span class="nav-number">7.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer-10-斐波那契数列"><span class="nav-number">7.1.</span> <span class="nav-text">剑指Offer 10 斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leetcode70-爬楼梯剑指Offer10-2-青蛙跳台阶"><span class="nav-number">7.2.</span> <span class="nav-text">Leetcode70. 爬楼梯剑指Offer10 -2 青蛙跳台阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer16-数值的整数次方"><span class="nav-number">7.3.</span> <span class="nav-text">剑指Offer16 数值的整数次方</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态规划"><span class="nav-number">8.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#例子-给一个字符串，不带“-”可能有多少个IP"><span class="nav-number">8.1.</span> <span class="nav-text">例子 给一个字符串，不带“.”可能有多少个IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode120三角型最小路径和"><span class="nav-number">8.2.</span> <span class="nav-text">LeetCode120三角型最小路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer42-连续子数组的最大和"><span class="nav-number">8.3.</span> <span class="nav-text">剑指Offer42 连续子数组的最大和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-300-最长上升子序列"><span class="nav-number">8.4.</span> <span class="nav-text">LeetCode 300. 最长上升子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer63-股票的最大利润"><span class="nav-number">8.5.</span> <span class="nav-text">剑指Offer63 股票的最大利润</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer12-矩阵中的路径"><span class="nav-number">8.6.</span> <span class="nav-text">剑指Offer12 矩阵中的路径 **</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode343面试题14-I-剪绳子"><span class="nav-number">8.7.</span> <span class="nav-text">LeetCode343面试题14- I. 剪绳子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leetcode64面试题47-礼物的最大价值"><span class="nav-number">8.8.</span> <span class="nav-text">Leetcode64面试题47. 礼物的最大价值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-312-戳气球"><span class="nav-number">8.9.</span> <span class="nav-text">LeetCode 312. 戳气球**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加权项目时间计划"><span class="nav-number">8.10.</span> <span class="nav-text">加权项目时间计划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连续数字不相邻最大和"><span class="nav-number">8.11.</span> <span class="nav-text">连续数字不相邻最大和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组中是否有几个数字加和等于指定数字"><span class="nav-number">8.12.</span> <span class="nav-text">数组中是否有几个数字加和等于指定数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#01背包问题"><span class="nav-number">8.13.</span> <span class="nav-text">01背包问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完全背包"><span class="nav-number">8.14.</span> <span class="nav-text">完全背包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重背包"><span class="nav-number">8.15.</span> <span class="nav-text">多重背包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dfs和bfs"><span class="nav-number">9.</span> <span class="nav-text">dfs和bfs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dfs"><span class="nav-number">9.1.</span> <span class="nav-text">dfs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象树"><span class="nav-number">9.2.</span> <span class="nav-text">抽象树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例题1-ABC的全排列"><span class="nav-number">9.2.1.</span> <span class="nav-text">例题1 ABC的全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-93复原IP地址"><span class="nav-number">9.2.2.</span> <span class="nav-text">Leetcode:93复原IP地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode17-电话号码的字母组合"><span class="nav-number">9.2.3.</span> <span class="nav-text">LeetCode17:电话号码的字母组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode-39-组合总和"><span class="nav-number">9.2.4.</span> <span class="nav-text">LeetCode 39 组合总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode46-全排列"><span class="nav-number">9.2.5.</span> <span class="nav-text">LeetCode46:全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指Offer38字符串的排列"><span class="nav-number">9.2.6.</span> <span class="nav-text">剑指Offer38字符串的排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode47-全排列2"><span class="nav-number">9.2.7.</span> <span class="nav-text">LeetCode47 全排列2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode22-括号生成"><span class="nav-number">9.2.8.</span> <span class="nav-text">LeetCode22 括号生成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准树相关"><span class="nav-number">9.3.</span> <span class="nav-text">标准树相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode100-相同的树"><span class="nav-number">9.3.1.</span> <span class="nav-text">LeetCode100:相同的树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode113-路径的总和"><span class="nav-number">9.3.2.</span> <span class="nav-text">Leetcode113 路径的总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode129-叶子节点数字之和"><span class="nav-number">9.3.3.</span> <span class="nav-text">LeetCode129 叶子节点数字之和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组相关dfs"><span class="nav-number">9.4.</span> <span class="nav-text">数组相关dfs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LeetCode200-岛屿的数量"><span class="nav-number">9.4.1.</span> <span class="nav-text">LeetCode200 岛屿的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指Offer矩阵中的路径（时间复杂度？）"><span class="nav-number">9.4.2.</span> <span class="nav-text">剑指Offer矩阵中的路径（时间复杂度？）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指Offer-13-机器人的运动范围"><span class="nav-number">9.4.3.</span> <span class="nav-text">剑指Offer 13. 机器人的运动范围</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串相关"><span class="nav-number">10.</span> <span class="nav-text">字符串相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer05：替换空格"><span class="nav-number">10.1.</span> <span class="nav-text">剑指Offer05：替换空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer17-打印从1到最大的n位数"><span class="nav-number">10.2.</span> <span class="nav-text">剑指Offer17. 打印从1到最大的n位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer20-表示数值的字符串"><span class="nav-number">10.3.</span> <span class="nav-text">剑指Offer20 表示数值的字符串**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer-19-正则表达式"><span class="nav-number">10.4.</span> <span class="nav-text">剑指Offer 19 正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路1：-递归写法"><span class="nav-number">10.4.1.</span> <span class="nav-text">思路1： 递归写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer-43-1～n整数中1出现的次数"><span class="nav-number">10.5.</span> <span class="nav-text">剑指Offer 43. 1～n整数中1出现的次数**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer44-数字序列中某一位的数字"><span class="nav-number">10.6.</span> <span class="nav-text">剑指Offer44. 数字序列中某一位的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer45-把数组排成最小的数"><span class="nav-number">10.7.</span> <span class="nav-text">剑指Offer45. 把数组排成最小的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer46-把数字翻译成字符串-dfs或者动态规划"><span class="nav-number">10.8.</span> <span class="nav-text">剑指Offer46. 把数字翻译成字符串(dfs或者动态规划)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer58-I-翻转单词顺序"><span class="nav-number">10.9.</span> <span class="nav-text">剑指Offer58 - I. 翻转单词顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路1-先整体反转在逐个单词反转"><span class="nav-number">10.9.1.</span> <span class="nav-text">思路1,先整体反转在逐个单词反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路2-利用sstream"><span class="nav-number">10.9.2.</span> <span class="nav-text">思路2 利用sstream</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer58-II-左旋转字符串"><span class="nav-number">10.10.</span> <span class="nav-text">剑指Offer58 - II. 左旋转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer67-把字符串转换成整数"><span class="nav-number">10.11.</span> <span class="nav-text">剑指Offer67. 把字符串转换成整数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#位运算"><span class="nav-number">11.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer-15-二进制中1的个数"><span class="nav-number">11.1.</span> <span class="nav-text">剑指Offer 15. 二进制中1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer65-不用加减乘除做加法"><span class="nav-number">11.2.</span> <span class="nav-text">剑指Offer65. 不用加减乘除做加法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#优化时间效率"><span class="nav-number">12.</span> <span class="nav-text">优化时间效率</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指Offer49-丑数"><span class="nav-number">12.1.</span> <span class="nav-text">剑指Offer49. 丑数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yang MieMie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/yangmiemie99.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/yangmiemie99.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/yangmiemie99.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
